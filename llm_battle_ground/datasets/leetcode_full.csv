question_slug,question_title,frontend_question_id,question_id,raw_content,difficulty,paid_only,cpp_snippet,java_snippet,python_snippet,python3_snippet,c_snippet,csharp_snippet,javascript_snippet,ruby_snippet,swift_snippet,golang_snippet,scala_snippet,kotlin_snippet,rust_snippet,php_snippet,typescript_snippet,racket_snippet,erlang_snippet,elixir_snippet,dart_snippet,react_snippet
apply-operations-to-maximize-score,Apply Operations to Maximize Score,2818.0,3001.0,"<p>You are given an array <code>nums</code> of <code>n</code> positive integers and an integer <code>k</code>.</p>

<p>Initially, you start with a score of <code>1</code>. You have to maximize your score by applying the following operation at most <code>k</code> times:</p>

<ul>
	<li>Choose any <strong>non-empty</strong> subarray <code>nums[l, ..., r]</code> that you haven&#39;t chosen previously.</li>
	<li>Choose an element <code>x</code> of <code>nums[l, ..., r]</code> with the highest <strong>prime score</strong>. If multiple such elements exist, choose the one with the smallest index.</li>
	<li>Multiply your score by <code>x</code>.</li>
</ul>

<p>Here, <code>nums[l, ..., r]</code> denotes the subarray of <code>nums</code> starting at index <code>l</code> and ending at the index <code>r</code>, both ends being inclusive.</p>

<p>The <strong>prime score</strong> of an integer <code>x</code> is equal to the number of distinct prime factors of <code>x</code>. For example, the prime score of <code>300</code> is <code>3</code> since <code>300 = 2 * 2 * 3 * 5 * 5</code>.</p>

<p>Return <em>the <strong>maximum possible score</strong> after applying at most </em><code>k</code><em> operations</em>.</p>

<p>Since the answer may be large, return it modulo <code>10<sup>9 </sup>+ 7</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [8,3,9,3,8], k = 2
<strong>Output:</strong> 81
<strong>Explanation:</strong> To get a score of 81, we can apply the following operations:
- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.
It can be proven that 81 is the highest score one can obtain.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [19,12,14,6,10,18], k = 3
<strong>Output:</strong> 4788
<strong>Explanation:</strong> To get a score of 4788, we can apply the following operations: 
- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.
- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.
It can be proven that 4788 is the highest score one can obtain.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length == n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10<sup>9</sup>)</code></li>
</ul>
",3.0,False,"class Solution {
public:
    int maximumScore(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int maximumScore(List<Integer> nums, int k) {
        
    }
}","class Solution(object):
    def maximumScore(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        ","int maximumScore(int* nums, int numsSize, int k){

}","public class Solution {
    public int MaximumScore(IList<int> nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumScore = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def maximum_score(nums, k)
    
end","class Solution {
    func maximumScore(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func maximumScore(nums []int, k int) int {
    
}","object Solution {
    def maximumScore(nums: List[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun maximumScore(nums: List<Int>, k: Int): Int {
        
    }
}","impl Solution {
    pub fn maximum_score(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function maximumScore($nums, $k) {
        
    }
}","function maximumScore(nums: number[], k: number): number {

};","(define/contract (maximum-score nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec maximum_score(Nums :: [integer()], K :: integer()) -> integer().
maximum_score(Nums, K) ->
  .","defmodule Solution do
  @spec maximum_score(nums :: [integer], k :: integer) :: integer
  def maximum_score(nums, k) do

  end
end","class Solution {
  int maximumScore(List<int> nums, int k) {

  }
}",
minimum-absolute-difference-between-elements-with-constraint,Minimum Absolute Difference Between Elements With Constraint,2817.0,3000.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>x</code>.</p>

<p>Find the <strong>minimum absolute difference</strong> between two elements in the array that are at least <code>x</code> indices apart.</p>

<p>In other words, find two indices <code>i</code> and <code>j</code> such that <code>abs(i - j) &gt;= x</code> and <code>abs(nums[i] - nums[j])</code> is minimized.</p>

<p>Return<em> an integer denoting the <strong>minimum</strong> absolute difference between two elements that are at least</em> <code>x</code> <em>indices apart</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,2,4], x = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong> We can select nums[0] = 4 and nums[3] = 4. 
They are at least 2 indices apart, and their absolute difference is the minimum, 0. 
It can be shown that 0 is the optimal answer.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,3,2,10,15], x = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can select nums[1] = 3 and nums[2] = 2.
They are at least 1 index apart, and their absolute difference is the minimum, 1.
It can be shown that 1 is the optimal answer.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], x = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can select nums[0] = 1 and nums[3] = 4.
They are at least 3 indices apart, and their absolute difference is the minimum, 3.
It can be shown that 3 is the optimal answer.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= x &lt; nums.length</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int minAbsoluteDifference(vector<int>& nums, int x) {
        
    }
};","class Solution {
    public int minAbsoluteDifference(List<Integer> nums, int x) {
        
    }
}","class Solution(object):
    def minAbsoluteDifference(self, nums, x):
        """"""
        :type nums: List[int]
        :type x: int
        :rtype: int
        """"""
        ","class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        ","int minAbsoluteDifference(int* nums, int numsSize, int x){

}","public class Solution {
    public int MinAbsoluteDifference(IList<int> nums, int x) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} x
 * @return {number}
 */
var minAbsoluteDifference = function(nums, x) {
    
};","# @param {Integer[]} nums
# @param {Integer} x
# @return {Integer}
def min_absolute_difference(nums, x)
    
end","class Solution {
    func minAbsoluteDifference(_ nums: [Int], _ x: Int) -> Int {
        
    }
}","func minAbsoluteDifference(nums []int, x int) int {
    
}","object Solution {
    def minAbsoluteDifference(nums: List[Int], x: Int): Int = {
        
    }
}","class Solution {
    fun minAbsoluteDifference(nums: List<Int>, x: Int): Int {
        
    }
}","impl Solution {
    pub fn min_absolute_difference(nums: Vec<i32>, x: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $x
     * @return Integer
     */
    function minAbsoluteDifference($nums, $x) {
        
    }
}","function minAbsoluteDifference(nums: number[], x: number): number {

};","(define/contract (min-absolute-difference nums x)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec min_absolute_difference(Nums :: [integer()], X :: integer()) -> integer().
min_absolute_difference(Nums, X) ->
  .","defmodule Solution do
  @spec min_absolute_difference(nums :: [integer], x :: integer) :: integer
  def min_absolute_difference(nums, x) do

  end
end","class Solution {
  int minAbsoluteDifference(List<int> nums, int x) {

  }
}",
account-balance-after-rounded-purchase,Account Balance After Rounded Purchase,2806.0,2955.0,"<p>Initially, you have a bank account balance of <code>100</code> dollars.</p>

<p>You are given an integer <code>purchaseAmount</code> representing the amount you will spend on a purchase in dollars.</p>

<p>At the store where you will make the purchase, the purchase amount is rounded to the <strong>nearest multiple</strong> of <code>10</code>. In other words, you pay a <strong>non-negative</strong> amount, <code>roundedAmount</code>, such that <code>roundedAmount</code> is a multiple of <code>10</code> and <code>abs(roundedAmount - purchaseAmount)</code> is <strong>minimized</strong>.</p>

<p>If there is more than one nearest multiple of <code>10</code>, the <strong>largest multiple</strong> is chosen.</p>

<p>Return <em>an integer denoting your account balance after making a purchase worth </em><code>purchaseAmount</code><em> dollars from the store.</em></p>

<p><strong>Note:</strong> <code>0</code> is considered to be a multiple of <code>10</code> in this problem.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> purchaseAmount = 9
<strong>Output:</strong> 90
<strong>Explanation:</strong> In this example, the nearest multiple of 10 to 9 is 10. Hence, your account balance becomes 100 - 10 = 90.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> purchaseAmount = 15
<strong>Output:</strong> 80
<strong>Explanation:</strong> In this example, there are two nearest multiples of 10 to 15: 10 and 20. So, the larger multiple, 20, is chosen.
Hence, your account balance becomes 100 - 20 = 80.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= purchaseAmount &lt;= 100</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int accountBalanceAfterPurchase(int purchaseAmount) {
        
    }
};","class Solution {
    public int accountBalanceAfterPurchase(int purchaseAmount) {
        
    }
}","class Solution(object):
    def accountBalanceAfterPurchase(self, purchaseAmount):
        """"""
        :type purchaseAmount: int
        :rtype: int
        """"""
        ","class Solution:
    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:
        ","int accountBalanceAfterPurchase(int purchaseAmount){

}","public class Solution {
    public int AccountBalanceAfterPurchase(int purchaseAmount) {
        
    }
}","/**
 * @param {number} purchaseAmount
 * @return {number}
 */
var accountBalanceAfterPurchase = function(purchaseAmount) {
    
};","# @param {Integer} purchase_amount
# @return {Integer}
def account_balance_after_purchase(purchase_amount)
    
end","class Solution {
    func accountBalanceAfterPurchase(_ purchaseAmount: Int) -> Int {
        
    }
}","func accountBalanceAfterPurchase(purchaseAmount int) int {
    
}","object Solution {
    def accountBalanceAfterPurchase(purchaseAmount: Int): Int = {
        
    }
}","class Solution {
    fun accountBalanceAfterPurchase(purchaseAmount: Int): Int {
        
    }
}","impl Solution {
    pub fn account_balance_after_purchase(purchase_amount: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $purchaseAmount
     * @return Integer
     */
    function accountBalanceAfterPurchase($purchaseAmount) {
        
    }
}","function accountBalanceAfterPurchase(purchaseAmount: number): number {

};","(define/contract (account-balance-after-purchase purchaseAmount)
  (-> exact-integer? exact-integer?)

  )","-spec account_balance_after_purchase(PurchaseAmount :: integer()) -> integer().
account_balance_after_purchase(PurchaseAmount) ->
  .","defmodule Solution do
  @spec account_balance_after_purchase(purchase_amount :: integer) :: integer
  def account_balance_after_purchase(purchase_amount) do

  end
end","class Solution {
  int accountBalanceAfterPurchase(int purchaseAmount) {

  }
}",
minimum-time-to-make-array-sum-at-most-x,Minimum Time to Make Array Sum At Most x,2809.0,2952.0,"<p>You are given two <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code> of equal length. Every second, for all indices <code>0 &lt;= i &lt; nums1.length</code>, value of <code>nums1[i]</code> is incremented by <code>nums2[i]</code>. <strong>After</strong> this is done, you can do the following operation:</p>

<ul>
	<li>Choose an index <code>0 &lt;= i &lt; nums1.length</code> and make <code>nums1[i] = 0</code>.</li>
</ul>

<p>You are also given an integer <code>x</code>.</p>

<p>Return <em>the <strong>minimum</strong> time in which you can make the sum of all elements of </em><code>nums1</code><em> to be<strong> less than or equal</strong> to </em><code>x</code>, <em>or </em><code>-1</code><em> if this is not possible.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3], nums2 = [1,2,3], x = 4
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
For the 1st second, we apply the operation on i = 0. Therefore nums1 = [0,2+2,3+3] = [0,4,6]. 
For the 2nd second, we apply the operation on i = 1. Therefore nums1 = [0+1,0,6+3] = [1,0,9]. 
For the 3rd second, we apply the operation on i = 2. Therefore nums1 = [1+1,0+2,0] = [2,2,0]. 
Now sum of nums1 = 4. It can be shown that these operations are optimal, so we return 3.

</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3], nums2 = [3,3,3], x = 4
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be shown that the sum of nums1 will always be greater than x, no matter which operations are performed.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code><font face=""monospace"">1 &lt;= nums1.length &lt;= 10<sup>3</sup></font></code></li>
	<li><code>1 &lt;= nums1[i] &lt;= 10<sup>3</sup></code></li>
	<li><code>0 &lt;= nums2[i] &lt;= 10<sup>3</sup></code></li>
	<li><code>nums1.length == nums2.length</code></li>
	<li><code>0 &lt;= x &lt;= 10<sup>6</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    int minimumTime(vector<int>& nums1, vector<int>& nums2, int x) {
        
    }
};","class Solution {
    public int minimumTime(List<Integer> nums1, List<Integer> nums2, int x) {
        
    }
}","class Solution(object):
    def minimumTime(self, nums1, nums2, x):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :type x: int
        :rtype: int
        """"""
        ","class Solution:
    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:
        ","int minimumTime(int* nums1, int nums1Size, int* nums2, int nums2Size, int x){

}","public class Solution {
    public int MinimumTime(IList<int> nums1, IList<int> nums2, int x) {
        
    }
}","/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} x
 * @return {number}
 */
var minimumTime = function(nums1, nums2, x) {
    
};","# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @param {Integer} x
# @return {Integer}
def minimum_time(nums1, nums2, x)
    
end","class Solution {
    func minimumTime(_ nums1: [Int], _ nums2: [Int], _ x: Int) -> Int {
        
    }
}","func minimumTime(nums1 []int, nums2 []int, x int) int {
    
}","object Solution {
    def minimumTime(nums1: List[Int], nums2: List[Int], x: Int): Int = {
        
    }
}","class Solution {
    fun minimumTime(nums1: List<Int>, nums2: List<Int>, x: Int): Int {
        
    }
}","impl Solution {
    pub fn minimum_time(nums1: Vec<i32>, nums2: Vec<i32>, x: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @param Integer $x
     * @return Integer
     */
    function minimumTime($nums1, $nums2, $x) {
        
    }
}","function minimumTime(nums1: number[], nums2: number[], x: number): number {

};","(define/contract (minimum-time nums1 nums2 x)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec minimum_time(Nums1 :: [integer()], Nums2 :: [integer()], X :: integer()) -> integer().
minimum_time(Nums1, Nums2, X) ->
  .","defmodule Solution do
  @spec minimum_time(nums1 :: [integer], nums2 :: [integer], x :: integer) :: integer
  def minimum_time(nums1, nums2, x) do

  end
end","class Solution {
  int minimumTime(List<int> nums1, List<int> nums2, int x) {

  }
}",
count-stepping-numbers-in-range,Count Stepping Numbers in Range,2801.0,2921.0,"<p>Given two positive integers <code>low</code> and <code>high</code> represented as strings, find the count of <strong>stepping numbers</strong> in the inclusive range <code>[low, high]</code>.</p>

<p>A <strong>stepping number</strong> is an integer such that all of its adjacent digits have an absolute difference of <strong>exactly</strong> <code>1</code>.</p>

<p>Return <em>an integer denoting the count of stepping numbers in the inclusive range</em> <code>[low, high]</code><em>. </em></p>

<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p><strong>Note:</strong> A stepping number should not have a leading zero.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> low = &quot;1&quot;, high = &quot;11&quot;
<strong>Output:</strong> 10
<strong>Explanation: </strong>The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> low = &quot;90&quot;, high = &quot;101&quot;
<strong>Output:</strong> 2
<strong>Explanation: </strong>The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2. </pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= int(low) &lt;= int(high) &lt; 10<sup>100</sup></code></li>
	<li><code>1 &lt;= low.length, high.length &lt;= 100</code></li>
	<li><code>low</code> and <code>high</code> consist of only digits.</li>
	<li><code>low</code> and <code>high</code> don&#39;t have any leading zeros.</li>
</ul>
",3.0,False,"class Solution {
public:
    int countSteppingNumbers(string low, string high) {
        
    }
};","class Solution {
    public int countSteppingNumbers(String low, String high) {
        
    }
}","class Solution(object):
    def countSteppingNumbers(self, low, high):
        """"""
        :type low: str
        :type high: str
        :rtype: int
        """"""
        ","class Solution:
    def countSteppingNumbers(self, low: str, high: str) -> int:
        ","int countSteppingNumbers(char * low, char * high){

}","public class Solution {
    public int CountSteppingNumbers(string low, string high) {
        
    }
}","/**
 * @param {string} low
 * @param {string} high
 * @return {number}
 */
var countSteppingNumbers = function(low, high) {
    
};","# @param {String} low
# @param {String} high
# @return {Integer}
def count_stepping_numbers(low, high)
    
end","class Solution {
    func countSteppingNumbers(_ low: String, _ high: String) -> Int {
        
    }
}","func countSteppingNumbers(low string, high string) int {
    
}","object Solution {
    def countSteppingNumbers(low: String, high: String): Int = {
        
    }
}","class Solution {
    fun countSteppingNumbers(low: String, high: String): Int {
        
    }
}","impl Solution {
    pub fn count_stepping_numbers(low: String, high: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $low
     * @param String $high
     * @return Integer
     */
    function countSteppingNumbers($low, $high) {
        
    }
}","function countSteppingNumbers(low: string, high: string): number {

};","(define/contract (count-stepping-numbers low high)
  (-> string? string? exact-integer?)

  )","-spec count_stepping_numbers(Low :: unicode:unicode_binary(), High :: unicode:unicode_binary()) -> integer().
count_stepping_numbers(Low, High) ->
  .","defmodule Solution do
  @spec count_stepping_numbers(low :: String.t, high :: String.t) :: integer
  def count_stepping_numbers(low, high) do

  end
end","class Solution {
  int countSteppingNumbers(String low, String high) {

  }
}",
minimum-seconds-to-equalize-a-circular-array,Minimum Seconds to Equalize a Circular Array,2808.0,2920.0,"<p>You are given a <strong>0-indexed</strong> array <code>nums</code> containing <code>n</code> integers.</p>

<p>At each second, you perform the following operation on the array:</p>

<ul>
	<li>For every index <code>i</code> in the range <code>[0, n - 1]</code>, replace <code>nums[i]</code> with either <code>nums[i]</code>, <code>nums[(i - 1 + n) % n]</code>, or <code>nums[(i + 1) % n]</code>.</li>
</ul>

<p><strong>Note</strong> that all the elements get replaced simultaneously.</p>

<p>Return <em>the <strong>minimum</strong> number of seconds needed to make all elements in the array</em> <code>nums</code> <em>equal</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can equalize the array in 1 second in the following way:
- At 1<sup>st</sup> second, replace values at each index with [nums[3],nums[1],nums[3],nums[3]]. After replacement, nums = [2,2,2,2].
It can be proven that 1 second is the minimum amount of seconds needed for equalizing the array.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,3,3,2]
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can equalize the array in 2 seconds in the following way:
- At 1<sup>st</sup> second, replace values at each index with [nums[0],nums[2],nums[2],nums[2],nums[3]]. After replacement, nums = [2,3,3,3,3].
- At 2<sup>nd</sup> second, replace values at each index with [nums[1],nums[1],nums[2],nums[3],nums[4]]. After replacement, nums = [3,3,3,3,3].
It can be proven that 2 seconds is the minimum amount of seconds needed for equalizing the array.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,5,5,5]
<strong>Output:</strong> 0
<strong>Explanation:</strong> We don&#39;t need to perform any operations as all elements in the initial array are the same.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int minimumSeconds(vector<int>& nums) {
        
    }
};","class Solution {
    public int minimumSeconds(List<Integer> nums) {
        
    }
}","class Solution(object):
    def minimumSeconds(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minimumSeconds(self, nums: List[int]) -> int:
        ","int minimumSeconds(int* nums, int numsSize){

}","public class Solution {
    public int MinimumSeconds(IList<int> nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var minimumSeconds = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def minimum_seconds(nums)
    
end","class Solution {
    func minimumSeconds(_ nums: [Int]) -> Int {
        
    }
}","func minimumSeconds(nums []int) int {
    
}","object Solution {
    def minimumSeconds(nums: List[Int]): Int = {
        
    }
}","class Solution {
    fun minimumSeconds(nums: List<Int>): Int {
        
    }
}","impl Solution {
    pub fn minimum_seconds(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function minimumSeconds($nums) {
        
    }
}","function minimumSeconds(nums: number[]): number {

};","(define/contract (minimum-seconds nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec minimum_seconds(Nums :: [integer()]) -> integer().
minimum_seconds(Nums) ->
  .","defmodule Solution do
  @spec minimum_seconds(nums :: [integer]) :: integer
  def minimum_seconds(nums) do

  end
end","class Solution {
  int minimumSeconds(List<int> nums) {

  }
}",
maximum-number-of-groups-with-increasing-length,Maximum Number of Groups With Increasing Length,2790.0,2919.0,"<p>You are given a <strong>0-indexed</strong> array <code>usageLimits</code> of length <code>n</code>.</p>

<p>Your task is to create <strong>groups</strong> using numbers from <code>0</code> to <code>n - 1</code>, ensuring that each number, <code>i</code>, is used no more than <code>usageLimits[i]</code> times in total <strong>across all groups</strong>. You must also satisfy the following conditions:</p>

<ul>
	<li>Each group must consist of <strong>distinct </strong>numbers, meaning that no duplicate numbers are allowed within a single group.</li>
	<li>Each group (except the first one) must have a length <strong>strictly greater</strong> than the previous group.</li>
</ul>

<p>Return <em>an integer denoting the <strong>maximum</strong> number of groups you can create while satisfying these conditions.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> <code>usageLimits</code> = [1,2,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> In this example, we can use 0 at most once, 1 at most twice, and 2 at most five times.
One way of creating the maximum number of groups while satisfying the conditions is: 
Group 1 contains the number [2].
Group 2 contains the numbers [1,2].
Group 3 contains the numbers [0,1,2]. 
It can be shown that the maximum number of groups is 3. 
So, the output is 3. </pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> <code>usageLimits</code> = [2,1,2]
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example, we can use 0 at most twice, 1 at most once, and 2 at most twice.
One way of creating the maximum number of groups while satisfying the conditions is:
Group 1 contains the number [0].
Group 2 contains the numbers [1,2].
It can be shown that the maximum number of groups is 2.
So, the output is 2. 
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> <code>usageLimits</code> = [1,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> In this example, we can use both 0 and 1 at most once.
One way of creating the maximum number of groups while satisfying the conditions is:
Group 1 contains the number [0].
It can be shown that the maximum number of groups is 1.
So, the output is 1. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= usageLimits.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= usageLimits[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    int maxIncreasingGroups(vector<int>& usageLimits) {
        
    }
};","class Solution {
    public int maxIncreasingGroups(List<Integer> usageLimits) {
        
    }
}","class Solution(object):
    def maxIncreasingGroups(self, usageLimits):
        """"""
        :type usageLimits: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:
        ","int maxIncreasingGroups(int* usageLimits, int usageLimitsSize){

}","public class Solution {
    public int MaxIncreasingGroups(IList<int> usageLimits) {
        
    }
}","/**
 * @param {number[]} usageLimits
 * @return {number}
 */
var maxIncreasingGroups = function(usageLimits) {
    
};","# @param {Integer[]} usage_limits
# @return {Integer}
def max_increasing_groups(usage_limits)
    
end","class Solution {
    func maxIncreasingGroups(_ usageLimits: [Int]) -> Int {
        
    }
}","func maxIncreasingGroups(usageLimits []int) int {
    
}","object Solution {
    def maxIncreasingGroups(usageLimits: List[Int]): Int = {
        
    }
}","class Solution {
    fun maxIncreasingGroups(usageLimits: List<Int>): Int {
        
    }
}","impl Solution {
    pub fn max_increasing_groups(usage_limits: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $usageLimits
     * @return Integer
     */
    function maxIncreasingGroups($usageLimits) {
        
    }
}","function maxIncreasingGroups(usageLimits: number[]): number {

};","(define/contract (max-increasing-groups usageLimits)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec max_increasing_groups(UsageLimits :: [integer()]) -> integer().
max_increasing_groups(UsageLimits) ->
  .","defmodule Solution do
  @spec max_increasing_groups(usage_limits :: [integer]) :: integer
  def max_increasing_groups(usage_limits) do

  end
end","class Solution {
  int maxIncreasingGroups(List<int> usageLimits) {

  }
}",
check-if-it-is-possible-to-split-array,Check if it is Possible to Split Array,2811.0,2916.0,"<p>You are given an array <code>nums</code> of length <code>n</code> and an integer <code>m</code>. You need to determine if it is possible to split the array into <code>n</code> <strong>non-empty</strong> arrays by performing a series of steps.</p>

<p>In each step, you can select an existing array (which may be the result of previous steps) with a length of <strong>at least two</strong> and split it into <strong>two </strong>subarrays, if, <strong>for each </strong>resulting subarray, <strong>at least</strong> one of the following holds:</p>

<ul>
	<li>The length of the subarray is one, or</li>
	<li>The sum of elements of the subarray is <strong>greater than or equal</strong> to <code>m</code>.</li>
</ul>

<p>Return <code>true</code><em> if you can split the given array into </em><code>n</code><em> arrays, otherwise return</em> <code>false</code>.</p>

<p><strong>Note:</strong> A subarray is <em>a contiguous non-empty sequence of elements within an array</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2, 2, 1], m = 4
<strong>Output:</strong> true
<strong>Explanation:</strong> We can split the array into [2, 2] and [1] in the first step. Then, in the second step, we can split [2, 2] into [2] and [2]. As a result, the answer is true.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2, 1, 3], m = 5 
<strong>Output:</strong> false
<strong>Explanation: </strong>We can try splitting the array in two different ways: the first way is to have [2, 1] and [3], and the second way is to have [2] and [1, 3]. However, both of these ways are not valid. So, the answer is false.</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [2, 3, 3, 2, 3], m = 6
<strong>Output:</strong> true
<strong>Explanation:</strong> We can split the array into [2, 3, 3, 2] and [3] in the first step. Then, in the second step, we can split [2, 3, 3, 2] into [2, 3, 3] and [2]. Then, in the third step, we can split [2, 3, 3] into [2] and [3, 3]. And in the last step we can split [3, 3] into [3] and [3]. As a result, the answer is true.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
	<li><code>1 &lt;= m &lt;= 200</code></li>
</ul>
",2.0,False,"class Solution {
public:
    bool canSplitArray(vector<int>& nums, int m) {
        
    }
};","class Solution {
    public boolean canSplitArray(List<Integer> nums, int m) {
        
    }
}","class Solution(object):
    def canSplitArray(self, nums, m):
        """"""
        :type nums: List[int]
        :type m: int
        :rtype: bool
        """"""
        ","class Solution:
    def canSplitArray(self, nums: List[int], m: int) -> bool:
        ","bool canSplitArray(int* nums, int numsSize, int m){

}","public class Solution {
    public bool CanSplitArray(IList<int> nums, int m) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} m
 * @return {boolean}
 */
var canSplitArray = function(nums, m) {
    
};","# @param {Integer[]} nums
# @param {Integer} m
# @return {Boolean}
def can_split_array(nums, m)
    
end","class Solution {
    func canSplitArray(_ nums: [Int], _ m: Int) -> Bool {
        
    }
}","func canSplitArray(nums []int, m int) bool {
    
}","object Solution {
    def canSplitArray(nums: List[Int], m: Int): Boolean = {
        
    }
}","class Solution {
    fun canSplitArray(nums: List<Int>, m: Int): Boolean {
        
    }
}","impl Solution {
    pub fn can_split_array(nums: Vec<i32>, m: i32) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $m
     * @return Boolean
     */
    function canSplitArray($nums, $m) {
        
    }
}","function canSplitArray(nums: number[], m: number): boolean {

};","(define/contract (can-split-array nums m)
  (-> (listof exact-integer?) exact-integer? boolean?)

  )","-spec can_split_array(Nums :: [integer()], M :: integer()) -> boolean().
can_split_array(Nums, M) ->
  .","defmodule Solution do
  @spec can_split_array(nums :: [integer], m :: integer) :: boolean
  def can_split_array(nums, m) do

  end
end","class Solution {
  bool canSplitArray(List<int> nums, int m) {

  }
}",
find-the-safest-path-in-a-grid,Find the Safest Path in a Grid,2812.0,2914.0,"<p>You are given a <strong>0-indexed</strong> 2D matrix <code>grid</code> of size <code>n x n</code>, where <code>(r, c)</code> represents:</p>

<ul>
	<li>A cell containing a thief if <code>grid[r][c] = 1</code></li>
	<li>An empty cell if <code>grid[r][c] = 0</code></li>
</ul>

<p>You are initially positioned at cell <code>(0, 0)</code>. In one move, you can move to any adjacent cell in the grid, including cells containing thieves.</p>

<p>The <strong>safeness factor</strong> of a path on the grid is defined as the <strong>minimum</strong> manhattan distance from any cell in the path to any thief in the grid.</p>

<p>Return <em>the <strong>maximum safeness factor</strong> of all paths leading to cell </em><code>(n - 1, n - 1)</code><em>.</em></p>

<p>An <strong>adjacent</strong> cell of cell <code>(r, c)</code>, is one of the cells <code>(r, c + 1)</code>, <code>(r, c - 1)</code>, <code>(r + 1, c)</code> and <code>(r - 1, c)</code> if it exists.</p>

<p>The <strong>Manhattan distance</strong> between two cells <code>(a, b)</code> and <code>(x, y)</code> is equal to <code>|a - x| + |b - y|</code>, where <code>|val|</code> denotes the absolute value of val.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/07/02/example1.png"" style=""width: 362px; height: 242px;"" />
<pre>
<strong>Input:</strong> grid = [[1,0,0],[0,0,0],[0,0,1]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All paths from (0, 0) to (n - 1, n - 1) go through the thieves in cells (0, 0) and (n - 1, n - 1).
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/07/02/example2.png"" style=""width: 362px; height: 242px;"" />
<pre>
<strong>Input:</strong> grid = [[0,0,1],[0,0,0],[0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 2) is cell (0, 0). The distance between them is | 0 - 0 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
</pre>

<p><strong class=""example"">Example 3:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/07/02/example3.png"" style=""width: 362px; height: 242px;"" />
<pre>
<strong>Input:</strong> grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 3) is cell (1, 2). The distance between them is | 0 - 1 | + | 3 - 2 | = 2.
- The closest cell of the path to the thief at cell (3, 0) is cell (3, 2). The distance between them is | 3 - 3 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length == n &lt;= 400</code></li>
	<li><code>grid[i].length == n</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li>There is at least one thief in the <code>grid</code>.</li>
</ul>
",2.0,False,"class Solution {
public:
    int maximumSafenessFactor(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int maximumSafenessFactor(List<List<Integer>> grid) {
        
    }
}","class Solution(object):
    def maximumSafenessFactor(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:
        ","int maximumSafenessFactor(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int MaximumSafenessFactor(IList<IList<int>> grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var maximumSafenessFactor = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def maximum_safeness_factor(grid)
    
end","class Solution {
    func maximumSafenessFactor(_ grid: [[Int]]) -> Int {
        
    }
}","func maximumSafenessFactor(grid [][]int) int {
    
}","object Solution {
    def maximumSafenessFactor(grid: List[List[Int]]): Int = {
        
    }
}","class Solution {
    fun maximumSafenessFactor(grid: List<List<Int>>): Int {
        
    }
}","impl Solution {
    pub fn maximum_safeness_factor(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function maximumSafenessFactor($grid) {
        
    }
}","function maximumSafenessFactor(grid: number[][]): number {

};","(define/contract (maximum-safeness-factor grid)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec maximum_safeness_factor(Grid :: [[integer()]]) -> integer().
maximum_safeness_factor(Grid) ->
  .","defmodule Solution do
  @spec maximum_safeness_factor(grid :: [[integer]]) :: integer
  def maximum_safeness_factor(grid) do

  end
end","class Solution {
  int maximumSafenessFactor(List<List<int>> grid) {

  }
}",
count-paths-that-can-form-a-palindrome-in-a-tree,Count Paths That Can Form a Palindrome in a Tree,2791.0,2905.0,"<p>You are given a <strong>tree</strong> (i.e. a connected, undirected graph that has no cycles) <strong>rooted</strong> at node <code>0</code> consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>. The tree is represented by a <strong>0-indexed</strong> array <code>parent</code> of size <code>n</code>, where <code>parent[i]</code> is the parent of node <code>i</code>. Since node <code>0</code> is the root, <code>parent[0] == -1</code>.</p>

<p>You are also given a string <code>s</code> of length <code>n</code>, where <code>s[i]</code> is the character assigned to the edge between <code>i</code> and <code>parent[i]</code>. <code>s[0]</code> can be ignored.</p>

<p>Return <em>the number of pairs of nodes </em><code>(u, v)</code><em> such that </em><code>u &lt; v</code><em> and the characters assigned to edges on the path from </em><code>u</code><em> to </em><code>v</code><em> can be <strong>rearranged</strong> to form a <strong>palindrome</strong></em>.</p>

<p>A string is a <strong>palindrome</strong> when it reads the same backwards as forwards.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<p><img alt="""" src=""https://assets.leetcode.com/uploads/2023/07/15/treedrawio-8drawio.png"" style=""width: 281px; height: 181px;"" /></p>

<pre>
<strong>Input:</strong> parent = [-1,0,0,1,1,2], s = &quot;acaabc&quot;
<strong>Output:</strong> 8
<strong>Explanation:</strong> The valid pairs are:
- All the pairs (0,1), (0,2), (1,3), (1,4) and (2,5) result in one character which is always a palindrome.
- The pair (2,3) result in the string &quot;aca&quot; which is a palindrome.
- The pair (1,5) result in the string &quot;cac&quot; which is a palindrome.
- The pair (3,5) result in the string &quot;acac&quot; which can be rearranged into the palindrome &quot;acca&quot;.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> parent = [-1,0,0,0,0], s = &quot;aaaaa&quot;
<strong>Output:</strong> 10
<strong>Explanation:</strong> Any pair of nodes (u,v) where u &lt; v is valid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == parent.length == s.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= parent[i] &lt;= n - 1</code> for all <code>i &gt;= 1</code></li>
	<li><code>parent[0] == -1</code></li>
	<li><code>parent</code> represents a valid tree.</li>
	<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
",3.0,False,"class Solution {
public:
    long long countPalindromePaths(vector<int>& parent, string s) {
        
    }
};","class Solution {
    public long countPalindromePaths(List<Integer> parent, String s) {
        
    }
}","class Solution(object):
    def countPalindromePaths(self, parent, s):
        """"""
        :type parent: List[int]
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def countPalindromePaths(self, parent: List[int], s: str) -> int:
        ","long long countPalindromePaths(int* parent, int parentSize, char * s){

}","public class Solution {
    public long CountPalindromePaths(IList<int> parent, string s) {
        
    }
}","/**
 * @param {number[]} parent
 * @param {string} s
 * @return {number}
 */
var countPalindromePaths = function(parent, s) {
    
};","# @param {Integer[]} parent
# @param {String} s
# @return {Integer}
def count_palindrome_paths(parent, s)
    
end","class Solution {
    func countPalindromePaths(_ parent: [Int], _ s: String) -> Int {
        
    }
}","func countPalindromePaths(parent []int, s string) int64 {
    
}","object Solution {
    def countPalindromePaths(parent: List[Int], s: String): Long = {
        
    }
}","class Solution {
    fun countPalindromePaths(parent: List<Int>, s: String): Long {
        
    }
}","impl Solution {
    pub fn count_palindrome_paths(parent: Vec<i32>, s: String) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $parent
     * @param String $s
     * @return Integer
     */
    function countPalindromePaths($parent, $s) {
        
    }
}","function countPalindromePaths(parent: number[], s: string): number {

};","(define/contract (count-palindrome-paths parent s)
  (-> (listof exact-integer?) string? exact-integer?)

  )","-spec count_palindrome_paths(Parent :: [integer()], S :: unicode:unicode_binary()) -> integer().
count_palindrome_paths(Parent, S) ->
  .","defmodule Solution do
  @spec count_palindrome_paths(parent :: [integer], s :: String.t) :: integer
  def count_palindrome_paths(parent, s) do

  end
end","class Solution {
  int countPalindromePaths(List<int> parent, String s) {

  }
}",
insert-greatest-common-divisors-in-linked-list,Insert Greatest Common Divisors in Linked List,2807.0,2903.0,"<p>Given the head of a linked list <code>head</code>, in which each node contains an integer value.</p>

<p>Between every pair of adjacent nodes, insert a new node with a value equal to the <strong>greatest common divisor</strong> of them.</p>

<p>Return <em>the linked list after insertion</em>.</p>

<p>The <strong>greatest common divisor</strong> of two numbers is the largest positive integer that evenly divides both numbers.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/07/18/ex1_copy.png"" style=""width: 641px; height: 181px;"" />
<pre>
<strong>Input:</strong> head = [18,6,10,3]
<strong>Output:</strong> [18,6,6,2,10,1,3]
<strong>Explanation:</strong> The 1<sup>st</sup> diagram denotes the initial linked list and the 2<sup>nd</sup> diagram denotes the linked list after inserting the new nodes (nodes in blue are the inserted nodes).
- We insert the greatest common divisor of 18 and 6 = 6 between the 1<sup>st</sup> and the 2<sup>nd</sup> nodes.
- We insert the greatest common divisor of 6 and 10 = 2 between the 2<sup>nd</sup> and the 3<sup>rd</sup> nodes.
- We insert the greatest common divisor of 10 and 3 = 1 between the 3<sup>rd</sup> and the 4<sup>th</sup> nodes.
There are no more adjacent nodes, so we return the linked list.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/07/18/ex2_copy1.png"" style=""width: 51px; height: 191px;"" />
<pre>
<strong>Input:</strong> head = [7]
<strong>Output:</strong> [7]
<strong>Explanation:</strong> The 1<sup>st</sup> diagram denotes the initial linked list and the 2<sup>nd</sup> diagram denotes the linked list after inserting the new nodes.
There are no pairs of adjacent nodes, so we return the initial linked list.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 5000]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 1000</code></li>
</ul>
",2.0,False,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* insertGreatestCommonDivisors(ListNode* head) {
        
    }
};","/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode insertGreatestCommonDivisors(ListNode head) {
        
    }
}","# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def insertGreatestCommonDivisors(self, head):
        """"""
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """"""
        ","# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:
        ","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* insertGreatestCommonDivisors(struct ListNode* head){

}","/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public int val;
 *     public ListNode next;
 *     public ListNode(int val=0, ListNode next=null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */
public class Solution {
    public ListNode InsertGreatestCommonDivisors(ListNode head) {
        
    }
}","/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var insertGreatestCommonDivisors = function(head) {
    
};","# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @return {ListNode}
def insert_greatest_common_divisors(head)
    
end","/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init() { self.val = 0; self.next = nil; }
 *     public init(_ val: Int) { self.val = val; self.next = nil; }
 *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }
 * }
 */
class Solution {
    func insertGreatestCommonDivisors(_ head: ListNode?) -> ListNode? {
        
    }
}","/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func insertGreatestCommonDivisors(head *ListNode) *ListNode {
    
}","/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def insertGreatestCommonDivisors(head: ListNode): ListNode = {
        
    }
}","/**
 * Example:
 * var li = ListNode(5)
 * var v = li.`val`
 * Definition for singly-linked list.
 * class ListNode(var `val`: Int) {
 *     var next: ListNode? = null
 * }
 */
class Solution {
    fun insertGreatestCommonDivisors(head: ListNode?): ListNode? {
        
    }
}","// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn insert_greatest_common_divisors(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        
    }
}","/**
 * Definition for a singly-linked list.
 * class ListNode {
 *     public $val = 0;
 *     public $next = null;
 *     function __construct($val = 0, $next = null) {
 *         $this->val = $val;
 *         $this->next = $next;
 *     }
 * }
 */
class Solution {

    /**
     * @param ListNode $head
     * @return ListNode
     */
    function insertGreatestCommonDivisors($head) {
        
    }
}","/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function insertGreatestCommonDivisors(head: ListNode | null): ListNode | null {

};","; Definition for singly-linked list:
#|

; val : integer?
; next : (or/c list-node? #f)
(struct list-node
  (val next) #:mutable #:transparent)

; constructor
(define (make-list-node [val 0])
  (list-node val #f))

|#

(define/contract (insert-greatest-common-divisors head)
  (-> (or/c list-node? #f) (or/c list-node? #f))

  )","%% Definition for singly-linked list.
%%
%% -record(list_node, {val = 0 :: integer(),
%%                     next = null :: 'null' | #list_node{}}).

-spec insert_greatest_common_divisors(Head :: #list_node{} | null) -> #list_node{} | null.
insert_greatest_common_divisors(Head) ->
  .","# Definition for singly-linked list.
#
# defmodule ListNode do
#   @type t :: %__MODULE__{
#           val: integer,
#           next: ListNode.t() | nil
#         }
#   defstruct val: 0, next: nil
# end

defmodule Solution do
  @spec insert_greatest_common_divisors(head :: ListNode.t | nil) :: ListNode.t | nil
  def insert_greatest_common_divisors(head) do

  end
end","/**
 * Definition for singly-linked list.
 * class ListNode {
 *   int val;
 *   ListNode? next;
 *   ListNode([this.val = 0, this.next]);
 * }
 */
class Solution {
  ListNode? insertGreatestCommonDivisors(ListNode? head) {

  }
}",
max-pair-sum-in-an-array,Max Pair Sum in an Array,2815.0,2902.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. You have to find the <strong>maximum</strong> sum of a pair of numbers from <code>nums</code> such that the maximum <strong>digit </strong>in both numbers are equal.</p>

<p>Return <em>the maximum sum or</em> <code>-1</code><em> if no such pair exists</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [51,71,17,24,42]
<strong>Output:</strong> 88
<strong>Explanation:</strong> 
For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. 
For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.
It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> -1
<strong>Explanation:</strong> No pair exists in nums with equal maximum digits.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
",1.0,False,"class Solution {
public:
    int maxSum(vector<int>& nums) {
        
    }
};","class Solution {
    public int maxSum(int[] nums) {
        
    }
}","class Solution(object):
    def maxSum(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxSum(self, nums: List[int]) -> int:
        ","int maxSum(int* nums, int numsSize){

}","public class Solution {
    public int MaxSum(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSum = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def max_sum(nums)
    
end","class Solution {
    func maxSum(_ nums: [Int]) -> Int {
        
    }
}","func maxSum(nums []int) int {
    
}","object Solution {
    def maxSum(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxSum(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_sum(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maxSum($nums) {
        
    }
}","function maxSum(nums: number[]): number {

};","(define/contract (max-sum nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec max_sum(Nums :: [integer()]) -> integer().
max_sum(Nums) ->
  .","defmodule Solution do
  @spec max_sum(nums :: [integer]) :: integer
  def max_sum(nums) do

  end
end","class Solution {
  int maxSum(List<int> nums) {

  }
}",
maximum-elegance-of-a-k-length-subsequence,Maximum Elegance of a K-Length Subsequence,2813.0,2894.0,"<p>You are given a <strong>0-indexed</strong> 2D integer array <code>items</code> of length <code>n</code> and an integer <code>k</code>.</p>

<p><code>items[i] = [profit<sub>i</sub>, category<sub>i</sub>]</code>, where <code>profit<sub>i</sub></code> and <code>category<sub>i</sub></code> denote the profit and category of the <code>i<sup>th</sup></code> item respectively.</p>

<p>Let&#39;s define the <strong>elegance</strong> of a <strong>subsequence</strong> of <code>items</code> as <code>total_profit + distinct_categories<sup>2</sup></code>, where <code>total_profit</code> is the sum of all profits in the subsequence, and <code>distinct_categories</code> is the number of <strong>distinct</strong> categories from all the categories in the selected subsequence.</p>

<p>Your task is to find the <strong>maximum elegance</strong> from all subsequences of size <code>k</code> in <code>items</code>.</p>

<p>Return <em>an integer denoting the maximum elegance of a subsequence of </em><code>items</code><em> with size exactly </em><code>k</code>.</p>

<p><strong>Note:</strong> A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> items = [[3,2],[5,1],[10,1]], k = 2
<strong>Output:</strong> 17
<strong>Explanation: </strong>In this example, we have to select a subsequence of size 2.
We can select items[0] = [3,2] and items[2] = [10,1].
The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].
Hence, the elegance is 13 + 2<sup>2</sup> = 17, and we can show that it is the maximum achievable elegance. 
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> items = [[3,1],[3,1],[2,2],[5,3]], k = 3
<strong>Output:</strong> 19
<strong>Explanation:</strong> In this example, we have to select a subsequence of size 3. 
We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. 
The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. 
Hence, the elegance is 10 + 3<sup>2</sup> = 19, and we can show that it is the maximum achievable elegance.</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> items = [[1,1],[2,1],[3,1]], k = 3
<strong>Output:</strong> 7
<strong>Explanation:</strong> In this example, we have to select a subsequence of size 3. 
We should select all the items. 
The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. 
Hence, the maximum elegance is 6 + 1<sup>2</sup> = 7.  </pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= items.length == n &lt;= 10<sup>5</sup></code></li>
	<li><code>items[i].length == 2</code></li>
	<li><code>items[i][0] == profit<sub>i</sub></code></li>
	<li><code>items[i][1] == category<sub>i</sub></code></li>
	<li><code>1 &lt;= profit<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= category<sub>i</sub> &lt;= n </code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
",3.0,False,"class Solution {
public:
    long long findMaximumElegance(vector<vector<int>>& items, int k) {
        
    }
};","class Solution {
    public long findMaximumElegance(int[][] items, int k) {
        
    }
}","class Solution(object):
    def findMaximumElegance(self, items, k):
        """"""
        :type items: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        ","long long findMaximumElegance(int** items, int itemsSize, int* itemsColSize, int k){

}","public class Solution {
    public long FindMaximumElegance(int[][] items, int k) {
        
    }
}","/**
 * @param {number[][]} items
 * @param {number} k
 * @return {number}
 */
var findMaximumElegance = function(items, k) {
    
};","# @param {Integer[][]} items
# @param {Integer} k
# @return {Integer}
def find_maximum_elegance(items, k)
    
end","class Solution {
    func findMaximumElegance(_ items: [[Int]], _ k: Int) -> Int {
        
    }
}","func findMaximumElegance(items [][]int, k int) int64 {
    
}","object Solution {
    def findMaximumElegance(items: Array[Array[Int]], k: Int): Long = {
        
    }
}","class Solution {
    fun findMaximumElegance(items: Array<IntArray>, k: Int): Long {
        
    }
}","impl Solution {
    pub fn find_maximum_elegance(items: Vec<Vec<i32>>, k: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $items
     * @param Integer $k
     * @return Integer
     */
    function findMaximumElegance($items, $k) {
        
    }
}","function findMaximumElegance(items: number[][], k: number): number {

};","(define/contract (find-maximum-elegance items k)
  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)

  )","-spec find_maximum_elegance(Items :: [[integer()]], K :: integer()) -> integer().
find_maximum_elegance(Items, K) ->
  .","defmodule Solution do
  @spec find_maximum_elegance(items :: [[integer]], k :: integer) :: integer
  def find_maximum_elegance(items, k) do

  end
end","class Solution {
  int findMaximumElegance(List<List<int>> items, int k) {

  }
}",
visit-array-positions-to-maximize-score,Visit Array Positions to Maximize Score,2786.0,2893.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and a positive integer <code>x</code>.</p>

<p>You are <strong>initially</strong> at position <code>0</code> in the array and you can visit other positions according to the following rules:</p>

<ul>
	<li>If you are currently in position <code>i</code>, then you can move to <strong>any</strong> position <code>j</code> such that <code>i &lt; j</code>.</li>
	<li>For each position <code>i</code> that you visit, you get a score of <code>nums[i]</code>.</li>
	<li>If you move from a position <code>i</code> to a position <code>j</code> and the <strong>parities</strong> of <code>nums[i]</code> and <code>nums[j]</code> differ, then you lose a score of <code>x</code>.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> total score you can get</em>.</p>

<p><strong>Note</strong> that initially you have <code>nums[0]</code> points.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,6,1,9,2], x = 5
<strong>Output:</strong> 13
<strong>Explanation:</strong> We can visit the following positions in the array: 0 -&gt; 2 -&gt; 3 -&gt; 4.
The corresponding values are 2, 6, 1 and 9. Since the integers 6 and 1 have different parities, the move 2 -&gt; 3 will make you lose a score of x = 5.
The total score will be: 2 + 6 + 1 + 9 - 5 = 13.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,6,8], x = 3
<strong>Output:</strong> 20
<strong>Explanation:</strong> All the integers in the array have the same parities, so we can visit all of them without losing any score.
The total score is: 2 + 4 + 6 + 8 = 20.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], x &lt;= 10<sup>6</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long maxScore(vector<int>& nums, int x) {
        
    }
};","class Solution {
    public long maxScore(int[] nums, int x) {
        
    }
}","class Solution(object):
    def maxScore(self, nums, x):
        """"""
        :type nums: List[int]
        :type x: int
        :rtype: int
        """"""
        ","class Solution:
    def maxScore(self, nums: List[int], x: int) -> int:
        ","long long maxScore(int* nums, int numsSize, int x){

}","public class Solution {
    public long MaxScore(int[] nums, int x) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} x
 * @return {number}
 */
var maxScore = function(nums, x) {
    
};","# @param {Integer[]} nums
# @param {Integer} x
# @return {Integer}
def max_score(nums, x)
    
end","class Solution {
    func maxScore(_ nums: [Int], _ x: Int) -> Int {
        
    }
}","func maxScore(nums []int, x int) int64 {
    
}","object Solution {
    def maxScore(nums: Array[Int], x: Int): Long = {
        
    }
}","class Solution {
    fun maxScore(nums: IntArray, x: Int): Long {
        
    }
}","impl Solution {
    pub fn max_score(nums: Vec<i32>, x: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $x
     * @return Integer
     */
    function maxScore($nums, $x) {
        
    }
}","function maxScore(nums: number[], x: number): number {

};","(define/contract (max-score nums x)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec max_score(Nums :: [integer()], X :: integer()) -> integer().
max_score(Nums, X) ->
  .","defmodule Solution do
  @spec max_score(nums :: [integer], x :: integer) :: integer
  def max_score(nums, x) do

  end
end","class Solution {
  int maxScore(List<int> nums, int x) {

  }
}",
check-if-array-is-good,Check if Array is Good,2784.0,2892.0,"<p>You are given an integer array <code>nums</code>. We consider an array <strong>good </strong>if it is a permutation of an array <code>base[n]</code>.</p>

<p><code>base[n] = [1, 2, ..., n - 1, n, n] </code>(in other words, it is an array of length <code>n + 1</code> which contains <code>1</code> to <code>n - 1 </code>exactly once, plus two occurrences of <code>n</code>). For example, <code>base[1] = [1, 1]</code> and<code> base[3] = [1, 2, 3, 3]</code>.</p>

<p>Return <code>true</code> <em>if the given array is good, otherwise return</em><em> </em><code>false</code>.</p>

<p><strong>Note: </strong>A permutation of integers represents an arrangement of these numbers.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2, 1, 3]
<strong>Output:</strong> false
<strong>Explanation:</strong> Since the maximum element of the array is 3, the only candidate n for which this array could be a permutation of base[n], is n = 3. However, base[3] has four elements but array nums has three. Therefore, it can not be a permutation of base[3] = [1, 2, 3, 3]. So the answer is false.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1, 3, 3, 2]
<strong>Output:</strong> true
<strong>Explanation:</strong> Since the maximum element of the array is 3, the only candidate n for which this array could be a permutation of base[n], is n = 3. It can be seen that nums is a permutation of base[3] = [1, 2, 3, 3] (by swapping the second and fourth elements in nums, we reach base[3]). Therefore, the answer is true.</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1, 1]
<strong>Output:</strong> true
<strong>Explanation:</strong> Since the maximum element of the array is 1, the only candidate n for which this array could be a permutation of base[n], is n = 1. It can be seen that nums is a permutation of base[1] = [1, 1]. Therefore, the answer is true.</pre>

<p><strong class=""example"">Example 4:</strong></p>

<pre>
<strong>Input:</strong> nums = [3, 4, 4, 1, 2, 1]
<strong>Output:</strong> false
<strong>Explanation:</strong> Since the maximum element of the array is 4, the only candidate n for which this array could be a permutation of base[n], is n = 4. However, base[4] has five elements but array nums has six. Therefore, it can not be a permutation of base[4] = [1, 2, 3, 4, 4]. So the answer is false.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= num[i] &lt;= 200</code></li>
</ul>
",1.0,False,"class Solution {
public:
    bool isGood(vector<int>& nums) {
        
    }
};","class Solution {
    public boolean isGood(int[] nums) {
        
    }
}","class Solution(object):
    def isGood(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        ","class Solution:
    def isGood(self, nums: List[int]) -> bool:
        ","bool isGood(int* nums, int numsSize){

}","public class Solution {
    public bool IsGood(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {boolean}
 */
var isGood = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Boolean}
def is_good(nums)
    
end","class Solution {
    func isGood(_ nums: [Int]) -> Bool {
        
    }
}","func isGood(nums []int) bool {
    
}","object Solution {
    def isGood(nums: Array[Int]): Boolean = {
        
    }
}","class Solution {
    fun isGood(nums: IntArray): Boolean {
        
    }
}","impl Solution {
    pub fn is_good(nums: Vec<i32>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Boolean
     */
    function isGood($nums) {
        
    }
}","function isGood(nums: number[]): boolean {

};","(define/contract (is-good nums)
  (-> (listof exact-integer?) boolean?)

  )","-spec is_good(Nums :: [integer()]) -> boolean().
is_good(Nums) ->
  .","defmodule Solution do
  @spec is_good(nums :: [integer]) :: boolean
  def is_good(nums) do

  end
end","class Solution {
  bool isGood(List<int> nums) {

  }
}",
maximum-beauty-of-an-array-after-applying-operation,Maximum Beauty of an Array After Applying Operation,2779.0,2891.0,"<p>You are given a <strong>0-indexed</strong> array <code>nums</code> and a <strong>non-negative</strong> integer <code>k</code>.</p>

<p>In one operation, you can do the following:</p>

<ul>
	<li>Choose an index <code>i</code> that <strong>hasn&#39;t been chosen before</strong> from the range <code>[0, nums.length - 1]</code>.</li>
	<li>Replace <code>nums[i]</code> with any integer from the range <code>[nums[i] - k, nums[i] + k]</code>.</li>
</ul>

<p>The <strong>beauty</strong> of the array is the length of the longest subsequence consisting of equal elements.</p>

<p>Return <em>the <strong>maximum</strong> possible beauty of the array </em><code>nums</code><em> after applying the operation any number of times.</em></p>

<p><strong>Note</strong> that you can apply the operation to each index <strong>only once</strong>.</p>

<p>A&nbsp;<strong>subsequence</strong> of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,6,1,2], k = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong> In this example, we apply the following operations:
- Choose index 1, replace it with 4 (from range [4,8]), nums = [4,4,1,2].
- Choose index 3, replace it with 4 (from range [0,4]), nums = [4,4,1,4].
After the applied operations, the beauty of the array nums is 3 (subsequence consisting of indices 0, 1, and 3).
It can be proven that 3 is the maximum possible length we can achieve.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,1], k = 10
<strong>Output:</strong> 4
<strong>Explanation:</strong> In this example we don&#39;t have to apply any operations.
The beauty of the array nums is 4 (whole array).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i], k &lt;= 10<sup>5</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int maximumBeauty(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int maximumBeauty(int[] nums, int k) {
        
    }
}","class Solution(object):
    def maximumBeauty(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maximumBeauty(self, nums: List[int], k: int) -> int:
        ","int maximumBeauty(int* nums, int numsSize, int k){

}","public class Solution {
    public int MaximumBeauty(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumBeauty = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def maximum_beauty(nums, k)
    
end","class Solution {
    func maximumBeauty(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func maximumBeauty(nums []int, k int) int {
    
}","object Solution {
    def maximumBeauty(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun maximumBeauty(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn maximum_beauty(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function maximumBeauty($nums, $k) {
        
    }
}","function maximumBeauty(nums: number[], k: number): number {

};","(define/contract (maximum-beauty nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec maximum_beauty(Nums :: [integer()], K :: integer()) -> integer().
maximum_beauty(Nums, K) ->
  .","defmodule Solution do
  @spec maximum_beauty(nums :: [integer], k :: integer) :: integer
  def maximum_beauty(nums, k) do

  end
end","class Solution {
  int maximumBeauty(List<int> nums, int k) {

  }
}",
number-of-black-blocks,Number of Black Blocks,2768.0,2889.0,"<p>You are given two integers <code>m</code> and <code>n</code> representing the dimensions of a&nbsp;<strong>0-indexed</strong>&nbsp;<code>m x n</code> grid.</p>

<p>You are also given a <strong>0-indexed</strong> 2D integer matrix <code>coordinates</code>, where <code>coordinates[i] = [x, y]</code> indicates that the cell with coordinates <code>[x, y]</code> is colored <strong>black</strong>. All cells in the grid that do not appear in <code>coordinates</code> are <strong>white</strong>.</p>

<p>A block is defined as a <code>2 x 2</code> submatrix of the grid. More formally, a block with cell <code>[x, y]</code> as its top-left corner where <code>0 &lt;= x &lt; m - 1</code> and <code>0 &lt;= y &lt; n - 1</code> contains the coordinates <code>[x, y]</code>, <code>[x + 1, y]</code>, <code>[x, y + 1]</code>, and <code>[x + 1, y + 1]</code>.</p>

<p>Return <em>a <strong>0-indexed</strong> integer array</em> <code>arr</code> <em>of size</em> <code>5</code> <em>such that</em> <code>arr[i]</code> <em>is the number of blocks that contains exactly</em> <code>i</code> <em><strong>black</strong> cells</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> m = 3, n = 3, coordinates = [[0,0]]
<strong>Output:</strong> [3,1,0,0,0]
<strong>Explanation:</strong> The grid looks like this:
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/06/18/screen-shot-2023-06-18-at-44656-am.png"" style=""width: 150px; height: 128px;"" />
There is only 1 block with one black cell, and it is the block starting with cell [0,0].
The other 3 blocks start with cells [0,1], [1,0] and [1,1]. They all have zero black cells. 
Thus, we return [3,1,0,0,0]. 
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> m = 3, n = 3, coordinates = [[0,0],[1,1],[0,2]]
<strong>Output:</strong> [0,2,2,0,0]
<strong>Explanation:</strong> The grid looks like this:
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/06/18/screen-shot-2023-06-18-at-45018-am.png"" style=""width: 150px; height: 128px;"" />
There are 2 blocks with two black cells (the ones starting with cell coordinates [0,0] and [0,1]).
The other 2 blocks have starting cell coordinates of [1,0] and [1,1]. They both have 1 black cell.
Therefore, we return [0,2,2,0,0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= m &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= coordinates.length &lt;= 10<sup>4</sup></code></li>
	<li><code>coordinates[i].length == 2</code></li>
	<li><code>0 &lt;= coordinates[i][0] &lt; m</code></li>
	<li><code>0 &lt;= coordinates[i][1] &lt; n</code></li>
	<li>It is guaranteed that <code>coordinates</code> contains pairwise distinct coordinates.</li>
</ul>
",2.0,False,"class Solution {
public:
    vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& coordinates) {
        
    }
};","class Solution {
    public long[] countBlackBlocks(int m, int n, int[][] coordinates) {
        
    }
}","class Solution(object):
    def countBlackBlocks(self, m, n, coordinates):
        """"""
        :type m: int
        :type n: int
        :type coordinates: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
long long* countBlackBlocks(int m, int n, int** coordinates, int coordinatesSize, int* coordinatesColSize, int* returnSize){

}","public class Solution {
    public long[] CountBlackBlocks(int m, int n, int[][] coordinates) {
        
    }
}","/**
 * @param {number} m
 * @param {number} n
 * @param {number[][]} coordinates
 * @return {number[]}
 */
var countBlackBlocks = function(m, n, coordinates) {
    
};","# @param {Integer} m
# @param {Integer} n
# @param {Integer[][]} coordinates
# @return {Integer[]}
def count_black_blocks(m, n, coordinates)
    
end","class Solution {
    func countBlackBlocks(_ m: Int, _ n: Int, _ coordinates: [[Int]]) -> [Int] {
        
    }
}","func countBlackBlocks(m int, n int, coordinates [][]int) []int64 {
    
}","object Solution {
    def countBlackBlocks(m: Int, n: Int, coordinates: Array[Array[Int]]): Array[Long] = {
        
    }
}","class Solution {
    fun countBlackBlocks(m: Int, n: Int, coordinates: Array<IntArray>): LongArray {
        
    }
}","impl Solution {
    pub fn count_black_blocks(m: i32, n: i32, coordinates: Vec<Vec<i32>>) -> Vec<i64> {
        
    }
}","class Solution {

    /**
     * @param Integer $m
     * @param Integer $n
     * @param Integer[][] $coordinates
     * @return Integer[]
     */
    function countBlackBlocks($m, $n, $coordinates) {
        
    }
}","function countBlackBlocks(m: number, n: number, coordinates: number[][]): number[] {

};","(define/contract (count-black-blocks m n coordinates)
  (-> exact-integer? exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec count_black_blocks(M :: integer(), N :: integer(), Coordinates :: [[integer()]]) -> [integer()].
count_black_blocks(M, N, Coordinates) ->
  .","defmodule Solution do
  @spec count_black_blocks(m :: integer, n :: integer, coordinates :: [[integer]]) :: [integer]
  def count_black_blocks(m, n, coordinates) do

  end
end","class Solution {
  List<int> countBlackBlocks(int m, int n, List<List<int>> coordinates) {

  }
}",
minimum-index-of-a-valid-split,Minimum Index of a Valid Split,2780.0,2888.0,"<p>An element <code>x</code> of an integer array <code>arr</code> of length <code>m</code> is <strong>dominant</strong> if <code>freq(x) * 2 &gt; m</code>, where <code>freq(x)</code> is the number of occurrences of <code>x</code> in <code>arr</code>. Note that this definition implies that <code>arr</code> can have <strong>at most one</strong> dominant element.</p>

<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code> with one dominant element.</p>

<p>You can split <code>nums</code> at an index <code>i</code> into two arrays <code>nums[0, ..., i]</code> and <code>nums[i + 1, ..., n - 1]</code>, but the split is only <strong>valid</strong> if:</p>

<ul>
	<li><code>0 &lt;= i &lt; n - 1</code></li>
	<li><code>nums[0, ..., i]</code>, and <code>nums[i + 1, ..., n - 1]</code> have the same dominant element.</li>
</ul>

<p>Here, <code>nums[i, ..., j]</code> denotes the subarray of <code>nums</code> starting at index <code>i</code> and ending at index <code>j</code>, both ends being inclusive. Particularly, if <code>j &lt; i</code> then <code>nums[i, ..., j]</code> denotes an empty subarray.</p>

<p>Return <em>the <strong>minimum</strong> index of a <strong>valid split</strong></em>. If no valid split exists, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,2,2]
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can split the array at index 2 to obtain arrays [1,2,2] and [2]. 
In array [1,2,2], element 2 is dominant since it occurs twice in the array and 2 * 2 &gt; 3. 
In array [2], element 2 is dominant since it occurs once in the array and 1 * 2 &gt; 1.
Both [1,2,2] and [2] have the same dominant element as nums, so this is a valid split. 
It can be shown that index 2 is the minimum index of a valid split. </pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,3,1,1,1,7,1,2,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> We can split the array at index 4 to obtain arrays [2,1,3,1,1] and [1,7,1,2,1].
In array [2,1,3,1,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 &gt; 5.
In array [1,7,1,2,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 &gt; 5.
Both [2,1,3,1,1] and [1,7,1,2,1] have the same dominant element as nums, so this is a valid split.
It can be shown that index 4 is the minimum index of a valid split.</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,3,3,3,7,2,2]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be shown that there is no valid split.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>nums</code> has exactly one dominant element.</li>
</ul>
",2.0,False,"class Solution {
public:
    int minimumIndex(vector<int>& nums) {
        
    }
};","class Solution {
    public int minimumIndex(List<Integer> nums) {
        
    }
}","class Solution(object):
    def minimumIndex(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minimumIndex(self, nums: List[int]) -> int:
        ","int minimumIndex(int* nums, int numsSize){

}","public class Solution {
    public int MinimumIndex(IList<int> nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var minimumIndex = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def minimum_index(nums)
    
end","class Solution {
    func minimumIndex(_ nums: [Int]) -> Int {
        
    }
}","func minimumIndex(nums []int) int {
    
}","object Solution {
    def minimumIndex(nums: List[Int]): Int = {
        
    }
}","class Solution {
    fun minimumIndex(nums: List<Int>): Int {
        
    }
}","impl Solution {
    pub fn minimum_index(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function minimumIndex($nums) {
        
    }
}","function minimumIndex(nums: number[]): number {

};","(define/contract (minimum-index nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec minimum_index(Nums :: [integer()]) -> integer().
minimum_index(Nums) ->
  .","defmodule Solution do
  @spec minimum_index(nums :: [integer]) :: integer
  def minimum_index(nums) do

  end
end","class Solution {
  int minimumIndex(List<int> nums) {

  }
}",
sort-vowels-in-a-string,Sort Vowels in a String,2785.0,2887.0,"<p>Given a <strong>0-indexed</strong> string <code>s</code>, <strong>permute</strong> <code>s</code> to get a new string <code>t</code> such that:</p>

<ul>
	<li>All consonants remain in their original places. More formally, if there is an index <code>i</code> with <code>0 &lt;= i &lt; s.length</code> such that <code>s[i]</code> is a consonant, then <code>t[i] = s[i]</code>.</li>
	<li>The vowels must be sorted in the <strong>nondecreasing</strong> order of their <strong>ASCII</strong> values. More formally, for pairs of indices <code>i</code>, <code>j</code> with <code>0 &lt;= i &lt; j &lt; s.length</code> such that <code>s[i]</code> and <code>s[j]</code> are vowels, then <code>t[i]</code> must not have a higher ASCII value than <code>t[j]</code>.</li>
</ul>

<p>Return <em>the resulting string</em>.</p>

<p>The vowels are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>, and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;lEetcOde&quot;
<strong>Output:</strong> &quot;lEOtcede&quot;
<strong>Explanation:</strong> &#39;E&#39;, &#39;O&#39;, and &#39;e&#39; are the vowels in s; &#39;l&#39;, &#39;t&#39;, &#39;c&#39;, and &#39;d&#39; are all consonants. The vowels are sorted according to their ASCII values, and the consonants remain in the same places.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;lYmpH&quot;
<strong>Output:</strong> &quot;lYmpH&quot;
<strong>Explanation:</strong> There are no vowels in s (all characters in s are consonants), so we return &quot;lYmpH&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists only of letters of the&nbsp;English alphabet&nbsp;in <strong>uppercase and lowercase</strong>.</li>
</ul>
",2.0,False,"class Solution {
public:
    string sortVowels(string s) {
        
    }
};","class Solution {
    public String sortVowels(String s) {
        
    }
}","class Solution(object):
    def sortVowels(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        ","class Solution:
    def sortVowels(self, s: str) -> str:
        ","char * sortVowels(char * s){

}","public class Solution {
    public string SortVowels(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {string}
 */
var sortVowels = function(s) {
    
};","# @param {String} s
# @return {String}
def sort_vowels(s)
    
end","class Solution {
    func sortVowels(_ s: String) -> String {
        
    }
}","func sortVowels(s string) string {
    
}","object Solution {
    def sortVowels(s: String): String = {
        
    }
}","class Solution {
    fun sortVowels(s: String): String {
        
    }
}","impl Solution {
    pub fn sort_vowels(s: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return String
     */
    function sortVowels($s) {
        
    }
}","function sortVowels(s: string): string {

};","(define/contract (sort-vowels s)
  (-> string? string?)

  )","-spec sort_vowels(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
sort_vowels(S) ->
  .","defmodule Solution do
  @spec sort_vowels(s :: String.t) :: String.t
  def sort_vowels(s) do

  end
end","class Solution {
  String sortVowels(String s) {

  }
}",
faulty-keyboard,Faulty Keyboard,2810.0,2886.0,"<p>Your laptop keyboard is faulty, and whenever you type a character <code>&#39;i&#39;</code> on it, it reverses the string that you have written. Typing other characters works as expected.</p>

<p>You are given a <strong>0-indexed</strong> string <code>s</code>, and you type each character of <code>s</code> using your faulty keyboard.</p>

<p>Return <em>the final string that will be present on your laptop screen.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;string&quot;
<strong>Output:</strong> &quot;rtsng&quot;
<strong>Explanation:</strong> 
After typing first character, the text on the screen is &quot;s&quot;.
After the second character, the text is &quot;st&quot;. 
After the third character, the text is &quot;str&quot;.
Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.
After the fifth character, the text is &quot;rtsn&quot;. 
After the sixth character, the text is &quot;rtsng&quot;. 
Therefore, we return &quot;rtsng&quot;.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;poiinter&quot;
<strong>Output:</strong> &quot;ponter&quot;
<strong>Explanation:</strong> 
After the first character, the text on the screen is &quot;p&quot;.
After the second character, the text is &quot;po&quot;. 
Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. 
Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.
After the fifth character, the text is &quot;pon&quot;.
After the sixth character, the text is &quot;pont&quot;. 
After the seventh character, the text is &quot;ponte&quot;. 
After the eighth character, the text is &quot;ponter&quot;. 
Therefore, we return &quot;ponter&quot;.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
	<li><code>s[0] != &#39;i&#39;</code></li>
</ul>
",1.0,False,"class Solution {
public:
    string finalString(string s) {
        
    }
};","class Solution {
    public String finalString(String s) {
        
    }
}","class Solution(object):
    def finalString(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        ","class Solution:
    def finalString(self, s: str) -> str:
        ","char * finalString(char * s){

}","public class Solution {
    public string FinalString(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {string}
 */
var finalString = function(s) {
    
};","# @param {String} s
# @return {String}
def final_string(s)
    
end","class Solution {
    func finalString(_ s: String) -> String {
        
    }
}","func finalString(s string) string {
    
}","object Solution {
    def finalString(s: String): String = {
        
    }
}","class Solution {
    fun finalString(s: String): String {
        
    }
}","impl Solution {
    pub fn final_string(s: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return String
     */
    function finalString($s) {
        
    }
}","function finalString(s: string): string {

};","(define/contract (final-string s)
  (-> string? string?)

  )","-spec final_string(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
final_string(S) ->
  .","defmodule Solution do
  @spec final_string(s :: String.t) :: String.t
  def final_string(s) do

  end
end","class Solution {
  String finalString(String s) {

  }
}","export function finalString() {
  
}"
length-of-the-longest-valid-substring,Length of the Longest Valid Substring,2781.0,2884.0,"<p>You are given a string <code>word</code> and an array of strings <code>forbidden</code>.</p>

<p>A string is called <strong>valid</strong> if none of its substrings are present in <code>forbidden</code>.</p>

<p>Return <em>the length of the <strong>longest valid substring</strong> of the string </em><code>word</code>.</p>

<p>A <strong>substring</strong> is a contiguous sequence of characters in a string, possibly empty.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;cbaaaabc&quot;, forbidden = [&quot;aaa&quot;,&quot;cb&quot;]
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 11 valid substrings in word: &quot;c&quot;, &quot;b&quot;, &quot;a&quot;, &quot;ba&quot;, &quot;aa&quot;, &quot;bc&quot;, &quot;baa&quot;, &quot;aab&quot;, &quot;ab&quot;, &quot;abc&quot;and &quot;aabc&quot;. The length of the longest valid substring is 4. 
It can be shown that all other substrings contain either &quot;aaa&quot; or &quot;cb&quot; as a substring. </pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;leetcode&quot;, forbidden = [&quot;de&quot;,&quot;le&quot;,&quot;e&quot;]
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 11 valid substrings in word: &quot;l&quot;, &quot;t&quot;, &quot;c&quot;, &quot;o&quot;, &quot;d&quot;, &quot;tc&quot;, &quot;co&quot;, &quot;od&quot;, &quot;tco&quot;, &quot;cod&quot;, and &quot;tcod&quot;. The length of the longest valid substring is 4.
It can be shown that all other substrings contain either &quot;de&quot;, &quot;le&quot;, or &quot;e&quot; as a substring. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 10<sup>5</sup></code></li>
	<li><code>word</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= forbidden.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= forbidden[i].length &lt;= 10</code></li>
	<li><code>forbidden[i]</code> consists only of lowercase English letters.</li>
</ul>
",3.0,False,"class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        
    }
};","class Solution {
    public int longestValidSubstring(String word, List<String> forbidden) {
        
    }
}","class Solution(object):
    def longestValidSubstring(self, word, forbidden):
        """"""
        :type word: str
        :type forbidden: List[str]
        :rtype: int
        """"""
        ","class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        ","int longestValidSubstring(char * word, char ** forbidden, int forbiddenSize){

}","public class Solution {
    public int LongestValidSubstring(string word, IList<string> forbidden) {
        
    }
}","/**
 * @param {string} word
 * @param {string[]} forbidden
 * @return {number}
 */
var longestValidSubstring = function(word, forbidden) {
    
};","# @param {String} word
# @param {String[]} forbidden
# @return {Integer}
def longest_valid_substring(word, forbidden)
    
end","class Solution {
    func longestValidSubstring(_ word: String, _ forbidden: [String]) -> Int {
        
    }
}","func longestValidSubstring(word string, forbidden []string) int {
    
}","object Solution {
    def longestValidSubstring(word: String, forbidden: List[String]): Int = {
        
    }
}","class Solution {
    fun longestValidSubstring(word: String, forbidden: List<String>): Int {
        
    }
}","impl Solution {
    pub fn longest_valid_substring(word: String, forbidden: Vec<String>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $word
     * @param String[] $forbidden
     * @return Integer
     */
    function longestValidSubstring($word, $forbidden) {
        
    }
}","function longestValidSubstring(word: string, forbidden: string[]): number {

};","(define/contract (longest-valid-substring word forbidden)
  (-> string? (listof string?) exact-integer?)

  )","-spec longest_valid_substring(Word :: unicode:unicode_binary(), Forbidden :: [unicode:unicode_binary()]) -> integer().
longest_valid_substring(Word, Forbidden) ->
  .","defmodule Solution do
  @spec longest_valid_substring(word :: String.t, forbidden :: [String.t]) :: integer
  def longest_valid_substring(word, forbidden) do

  end
end","class Solution {
  int longestValidSubstring(String word, List<String> forbidden) {

  }
}",
partition-string-into-minimum-beautiful-substrings,Partition String Into Minimum Beautiful Substrings,2767.0,2883.0,"<p>Given a binary string <code>s</code>, partition the string into one or more <strong>substrings</strong> such that each substring is <strong>beautiful</strong>.</p>

<p>A string is <strong>beautiful</strong> if:</p>

<ul>
	<li>It doesn&#39;t contain leading zeros.</li>
	<li>It&#39;s the <strong>binary</strong> representation of a number that is a power of <code>5</code>.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> number of substrings in such partition. </em>If it is impossible to partition the string <code>s</code> into beautiful substrings,&nbsp;return <code>-1</code>.</p>

<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;1011&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can paritition the given string into [&quot;101&quot;, &quot;1&quot;].
- The string &quot;101&quot; does not contain leading zeros and is the binary representation of integer 5<sup>1</sup> = 5.
- The string &quot;1&quot; does not contain leading zeros and is the binary representation of integer 5<sup>0</sup> = 1.
It can be shown that 2 is the minimum number of beautiful substrings that s can be partitioned into.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;111&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can paritition the given string into [&quot;1&quot;, &quot;1&quot;, &quot;1&quot;].
- The string &quot;1&quot; does not contain leading zeros and is the binary representation of integer 5<sup>0</sup> = 1.
It can be shown that 3 is the minimum number of beautiful substrings that s can be partitioned into.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;0&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> We can not partition the given string into beautiful substrings.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 15</code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
",2.0,False,"class Solution {
public:
    int minimumBeautifulSubstrings(string s) {
        
    }
};","class Solution {
    public int minimumBeautifulSubstrings(String s) {
        
    }
}","class Solution(object):
    def minimumBeautifulSubstrings(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def minimumBeautifulSubstrings(self, s: str) -> int:
        ","int minimumBeautifulSubstrings(char * s){

}","public class Solution {
    public int MinimumBeautifulSubstrings(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var minimumBeautifulSubstrings = function(s) {
    
};","# @param {String} s
# @return {Integer}
def minimum_beautiful_substrings(s)
    
end","class Solution {
    func minimumBeautifulSubstrings(_ s: String) -> Int {
        
    }
}","func minimumBeautifulSubstrings(s string) int {
    
}","object Solution {
    def minimumBeautifulSubstrings(s: String): Int = {
        
    }
}","class Solution {
    fun minimumBeautifulSubstrings(s: String): Int {
        
    }
}","impl Solution {
    pub fn minimum_beautiful_substrings(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function minimumBeautifulSubstrings($s) {
        
    }
}","function minimumBeautifulSubstrings(s: string): number {

};","(define/contract (minimum-beautiful-substrings s)
  (-> string? exact-integer?)

  )","-spec minimum_beautiful_substrings(S :: unicode:unicode_binary()) -> integer().
minimum_beautiful_substrings(S) ->
  .","defmodule Solution do
  @spec minimum_beautiful_substrings(s :: String.t) :: integer
  def minimum_beautiful_substrings(s) do

  end
end","class Solution {
  int minimumBeautifulSubstrings(String s) {

  }
}",
ways-to-express-an-integer-as-sum-of-powers,Ways to Express an Integer as Sum of Powers,2787.0,2882.0,"<p>Given two <strong>positive</strong> integers <code>n</code> and <code>x</code>.</p>

<p>Return <em>the number of ways </em><code>n</code><em> can be expressed as the sum of the </em><code>x<sup>th</sup></code><em> power of <strong>unique</strong> positive integers, in other words, the number of sets of unique integers </em><code>[n<sub>1</sub>, n<sub>2</sub>, ..., n<sub>k</sub>]</code><em> where </em><code>n = n<sub>1</sub><sup>x</sup> + n<sub>2</sub><sup>x</sup> + ... + n<sub>k</sub><sup>x</sup></code><em>.</em></p>

<p>Since the result can be very large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>

<p>For example, if <code>n = 160</code> and <code>x = 3</code>, one way to express <code>n</code> is <code>n = 2<sup>3</sup> + 3<sup>3</sup> + 5<sup>3</sup></code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 10, x = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can express n as the following: n = 3<sup>2</sup> + 1<sup>2</sup> = 10.
It can be shown that it is the only way to express 10 as the sum of the 2<sup>nd</sup> power of unique integers.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 4, x = 1
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can express n in the following ways:
- n = 4<sup>1</sup> = 4.
- n = 3<sup>1</sup> + 1<sup>1</sup> = 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 300</code></li>
	<li><code>1 &lt;= x &lt;= 5</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int numberOfWays(int n, int x) {
        
    }
};","class Solution {
    public int numberOfWays(int n, int x) {
        
    }
}","class Solution(object):
    def numberOfWays(self, n, x):
        """"""
        :type n: int
        :type x: int
        :rtype: int
        """"""
        ","class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        ","int numberOfWays(int n, int x){

}","public class Solution {
    public int NumberOfWays(int n, int x) {
        
    }
}","/**
 * @param {number} n
 * @param {number} x
 * @return {number}
 */
var numberOfWays = function(n, x) {
    
};","# @param {Integer} n
# @param {Integer} x
# @return {Integer}
def number_of_ways(n, x)
    
end","class Solution {
    func numberOfWays(_ n: Int, _ x: Int) -> Int {
        
    }
}","func numberOfWays(n int, x int) int {
    
}","object Solution {
    def numberOfWays(n: Int, x: Int): Int = {
        
    }
}","class Solution {
    fun numberOfWays(n: Int, x: Int): Int {
        
    }
}","impl Solution {
    pub fn number_of_ways(n: i32, x: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $x
     * @return Integer
     */
    function numberOfWays($n, $x) {
        
    }
}","function numberOfWays(n: number, x: number): number {

};","(define/contract (number-of-ways n x)
  (-> exact-integer? exact-integer? exact-integer?)

  )","-spec number_of_ways(N :: integer(), X :: integer()) -> integer().
number_of_ways(N, X) ->
  .","defmodule Solution do
  @spec number_of_ways(n :: integer, x :: integer) :: integer
  def number_of_ways(n, x) do

  end
end","class Solution {
  int numberOfWays(int n, int x) {

  }
}",
split-strings-by-separator,Split Strings by Separator,2788.0,2881.0,"<p>Given an array of strings <code>words</code> and a character <code>separator</code>, <strong>split</strong> each string in <code>words</code> by <code>separator</code>.</p>

<p>Return <em>an array of strings containing the new strings formed after the splits, <strong>excluding empty strings</strong>.</em></p>

<p><strong>Notes</strong></p>

<ul>
	<li><code>separator</code> is used to determine where the split should occur, but it is not included as part of the resulting strings.</li>
	<li>A split may result in more than two strings.</li>
	<li>The resulting strings must maintain the same order as they were initially given.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;one.two.three&quot;,&quot;four.five&quot;,&quot;six&quot;], separator = &quot;.&quot;
<strong>Output:</strong> [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;]
<strong>Explanation: </strong>In this example we split as follows:

&quot;one.two.three&quot; splits into &quot;one&quot;, &quot;two&quot;, &quot;three&quot;
&quot;four.five&quot; splits into &quot;four&quot;, &quot;five&quot;
&quot;six&quot; splits into &quot;six&quot; 

Hence, the resulting array is [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;].</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;$easy$&quot;,&quot;$problem$&quot;], separator = &quot;$&quot;
<strong>Output:</strong> [&quot;easy&quot;,&quot;problem&quot;]
<strong>Explanation:</strong> In this example we split as follows: 

&quot;$easy$&quot; splits into &quot;easy&quot; (excluding empty strings)
&quot;$problem$&quot; splits into &quot;problem&quot; (excluding empty strings)

Hence, the resulting array is [&quot;easy&quot;,&quot;problem&quot;].
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;|||&quot;], separator = &quot;|&quot;
<strong>Output:</strong> []
<strong>Explanation:</strong> In this example the resulting split of &quot;|||&quot; will contain only empty strings, so we return an empty array []. </pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 20</code></li>
	<li>characters in <code>words[i]</code> are either lowercase English letters or characters from the string <code>&quot;.,|$#@&quot;</code> (excluding the quotes)</li>
	<li><code>separator</code> is a character from the string <code>&quot;.,|$#@&quot;</code> (excluding the quotes)</li>
</ul>
",1.0,False,"class Solution {
public:
    vector<string> splitWordsBySeparator(vector<string>& words, char separator) {
        
    }
};","class Solution {
    public List<String> splitWordsBySeparator(List<String> words, char separator) {
        
    }
}","class Solution(object):
    def splitWordsBySeparator(self, words, separator):
        """"""
        :type words: List[str]
        :type separator: str
        :rtype: List[str]
        """"""
        ","class Solution:
    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** splitWordsBySeparator(char ** words, int wordsSize, char separator, int* returnSize){

}","public class Solution {
    public IList<string> SplitWordsBySeparator(IList<string> words, char separator) {
        
    }
}","/**
 * @param {string[]} words
 * @param {character} separator
 * @return {string[]}
 */
var splitWordsBySeparator = function(words, separator) {
    
};","# @param {String[]} words
# @param {Character} separator
# @return {String[]}
def split_words_by_separator(words, separator)
    
end","class Solution {
    func splitWordsBySeparator(_ words: [String], _ separator: Character) -> [String] {
        
    }
}","func splitWordsBySeparator(words []string, separator byte) []string {
    
}","object Solution {
    def splitWordsBySeparator(words: List[String], separator: Char): List[String] = {
        
    }
}","class Solution {
    fun splitWordsBySeparator(words: List<String>, separator: Char): List<String> {
        
    }
}","impl Solution {
    pub fn split_words_by_separator(words: Vec<String>, separator: char) -> Vec<String> {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @param String $separator
     * @return String[]
     */
    function splitWordsBySeparator($words, $separator) {
        
    }
}","function splitWordsBySeparator(words: string[], separator: string): string[] {

};","(define/contract (split-words-by-separator words separator)
  (-> (listof string?) char? (listof string?))

  )","-spec split_words_by_separator(Words :: [unicode:unicode_binary()], Separator :: char()) -> [unicode:unicode_binary()].
split_words_by_separator(Words, Separator) ->
  .","defmodule Solution do
  @spec split_words_by_separator(words :: [String.t], separator :: char) :: [String.t]
  def split_words_by_separator(words, separator) do

  end
end","class Solution {
  List<String> splitWordsBySeparator(List<String> words, String separator) {

  }
}",
apply-operations-to-make-all-array-elements-equal-to-zero,Apply Operations to Make All Array Elements Equal to Zero,2772.0,2878.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and a positive integer <code>k</code>.</p>

<p>You can apply the following operation on the array <strong>any</strong> number of times:</p>

<ul>
	<li>Choose <strong>any</strong> subarray of size <code>k</code> from the array and <strong>decrease</strong> all its elements by <code>1</code>.</li>
</ul>

<p>Return <code>true</code><em> if you can make all the array elements equal to </em><code>0</code><em>, or </em><code>false</code><em> otherwise</em>.</p>

<p>A <strong>subarray</strong> is a contiguous non-empty part of an array.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,3,1,1,0], k = 3
<strong>Output:</strong> true
<strong>Explanation:</strong> We can do the following operations:
- Choose the subarray [2,2,3]. The resulting array will be nums = [<strong><u>1</u></strong>,<strong><u>1</u></strong>,<strong><u>2</u></strong>,1,1,0].
- Choose the subarray [2,1,1]. The resulting array will be nums = [1,1,<strong><u>1</u></strong>,<strong><u>0</u></strong>,<strong><u>0</u></strong>,0].
- Choose the subarray [1,1,1]. The resulting array will be nums = [<u><strong>0</strong></u>,<u><strong>0</strong></u>,<u><strong>0</strong></u>,0,0,0].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,1,1], k = 2
<strong>Output:</strong> false
<strong>Explanation:</strong> It is not possible to make all the array elements equal to 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    bool checkArray(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public boolean checkArray(int[] nums, int k) {
        
    }
}","class Solution(object):
    def checkArray(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """"""
        ","class Solution:
    def checkArray(self, nums: List[int], k: int) -> bool:
        ","bool checkArray(int* nums, int numsSize, int k){

}","public class Solution {
    public bool CheckArray(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var checkArray = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Boolean}
def check_array(nums, k)
    
end","class Solution {
    func checkArray(_ nums: [Int], _ k: Int) -> Bool {
        
    }
}","func checkArray(nums []int, k int) bool {
    
}","object Solution {
    def checkArray(nums: Array[Int], k: Int): Boolean = {
        
    }
}","class Solution {
    fun checkArray(nums: IntArray, k: Int): Boolean {
        
    }
}","impl Solution {
    pub fn check_array(nums: Vec<i32>, k: i32) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Boolean
     */
    function checkArray($nums, $k) {
        
    }
}","function checkArray(nums: number[], k: number): boolean {

};","(define/contract (check-array nums k)
  (-> (listof exact-integer?) exact-integer? boolean?)

  )","-spec check_array(Nums :: [integer()], K :: integer()) -> boolean().
check_array(Nums, K) ->
  .","defmodule Solution do
  @spec check_array(nums :: [integer], k :: integer) :: boolean
  def check_array(nums, k) do

  end
end","class Solution {
  bool checkArray(List<int> nums, int k) {

  }
}",
shortest-string-that-contains-three-strings,Shortest String That Contains Three Strings,2800.0,2877.0,"Given three strings <code>a</code>, <code>b</code>, and <code>c</code>, your task is to find a string that has the<strong> minimum</strong> length and contains all three strings as <strong>substrings</strong>.
<p>If there are multiple such strings, return the<em> </em><strong>lexicographically<em> </em>smallest </strong>one.</p>

<p>Return <em>a string denoting the answer to the problem.</em></p>

<p><strong>Notes</strong></p>

<ul>
	<li>A string <code>a</code> is <strong>lexicographically smaller</strong> than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears <strong>earlier </strong>in the alphabet than the corresponding letter in <code>b</code>.</li>
	<li>A <strong>substring</strong> is a contiguous sequence of characters within a string.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> a = &quot;abc&quot;, b = &quot;bca&quot;, c = &quot;aaa&quot;
<strong>Output:</strong> &quot;aaabca&quot;
<strong>Explanation:</strong>  We show that &quot;aaabca&quot; contains all the given strings: a = ans[2...4], b = ans[3..5], c = ans[0..2]. It can be shown that the length of the resulting string would be at least 6 and &quot;aaabca&quot; is the lexicographically smallest one.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> a = &quot;ab&quot;, b = &quot;ba&quot;, c = &quot;aba&quot;
<strong>Output:</strong> &quot;aba&quot;
<strong>Explanation: </strong>We show that the string &quot;aba&quot; contains all the given strings: a = ans[0..1], b = ans[1..2], c = ans[0..2]. Since the length of c is 3, the length of the resulting string would be at least 3. It can be shown that &quot;aba&quot; is the lexicographically smallest one.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= a.length, b.length, c.length &lt;= 100</code></li>
	<li><code>a</code>, <code>b</code>, <code>c</code> consist only of lowercase English letters.</li>
</ul>
",2.0,False,"class Solution {
public:
    string minimumString(string a, string b, string c) {
        
    }
};","class Solution {
    public String minimumString(String a, String b, String c) {
        
    }
}","class Solution(object):
    def minimumString(self, a, b, c):
        """"""
        :type a: str
        :type b: str
        :type c: str
        :rtype: str
        """"""
        ","class Solution:
    def minimumString(self, a: str, b: str, c: str) -> str:
        ","char * minimumString(char * a, char * b, char * c){

}","public class Solution {
    public string MinimumString(string a, string b, string c) {
        
    }
}","/**
 * @param {string} a
 * @param {string} b
 * @param {string} c
 * @return {string}
 */
var minimumString = function(a, b, c) {
    
};","# @param {String} a
# @param {String} b
# @param {String} c
# @return {String}
def minimum_string(a, b, c)
    
end","class Solution {
    func minimumString(_ a: String, _ b: String, _ c: String) -> String {
        
    }
}","func minimumString(a string, b string, c string) string {
    
}","object Solution {
    def minimumString(a: String, b: String, c: String): String = {
        
    }
}","class Solution {
    fun minimumString(a: String, b: String, c: String): String {
        
    }
}","impl Solution {
    pub fn minimum_string(a: String, b: String, c: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $a
     * @param String $b
     * @param String $c
     * @return String
     */
    function minimumString($a, $b, $c) {
        
    }
}","function minimumString(a: string, b: string, c: string): string {

};","(define/contract (minimum-string a b c)
  (-> string? string? string? string?)

  )","-spec minimum_string(A :: unicode:unicode_binary(), B :: unicode:unicode_binary(), C :: unicode:unicode_binary()) -> unicode:unicode_binary().
minimum_string(A, B, C) ->
  .","defmodule Solution do
  @spec minimum_string(a :: String.t, b :: String.t, c :: String.t) :: String.t
  def minimum_string(a, b, c) do

  end
end","class Solution {
  String minimumString(String a, String b, String c) {

  }
}",
number-of-employees-who-met-the-target,Number of Employees Who Met the Target,2798.0,2876.0,"<p>There are <code>n</code> employees in a company, numbered from <code>0</code> to <code>n - 1</code>. Each employee <code>i</code> has worked for <code>hours[i]</code> hours in the company.</p>

<p>The company requires each employee to work for <strong>at least</strong> <code>target</code> hours.</p>

<p>You are given a <strong>0-indexed</strong> array of non-negative integers <code>hours</code> of length <code>n</code> and a non-negative integer <code>target</code>.</p>

<p>Return <em>the integer denoting the number of employees who worked at least</em> <code>target</code> <em>hours</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> hours = [0,1,2,3,4], target = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong> The company wants each employee to work for at least 2 hours.
- Employee 0 worked for 0 hours and didn&#39;t meet the target.
- Employee 1 worked for 1 hours and didn&#39;t meet the target.
- Employee 2 worked for 2 hours and met the target.
- Employee 3 worked for 3 hours and met the target.
- Employee 4 worked for 4 hours and met the target.
There are 3 employees who met the target.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> hours = [5,1,4,2,2], target = 6
<strong>Output:</strong> 0
<strong>Explanation:</strong> The company wants each employee to work for at least 6 hours.
There are 0 employees who met the target.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == hours.length &lt;= 50</code></li>
	<li><code>0 &lt;=&nbsp;hours[i], target &lt;= 10<sup>5</sup></code></li>
</ul>
",1.0,False,"class Solution {
public:
    int numberOfEmployeesWhoMetTarget(vector<int>& hours, int target) {
        
    }
};","class Solution {
    public int numberOfEmployeesWhoMetTarget(int[] hours, int target) {
        
    }
}","class Solution(object):
    def numberOfEmployeesWhoMetTarget(self, hours, target):
        """"""
        :type hours: List[int]
        :type target: int
        :rtype: int
        """"""
        ","class Solution:
    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:
        ","int numberOfEmployeesWhoMetTarget(int* hours, int hoursSize, int target){

}","public class Solution {
    public int NumberOfEmployeesWhoMetTarget(int[] hours, int target) {
        
    }
}","/**
 * @param {number[]} hours
 * @param {number} target
 * @return {number}
 */
var numberOfEmployeesWhoMetTarget = function(hours, target) {
    
};","# @param {Integer[]} hours
# @param {Integer} target
# @return {Integer}
def number_of_employees_who_met_target(hours, target)
    
end","class Solution {
    func numberOfEmployeesWhoMetTarget(_ hours: [Int], _ target: Int) -> Int {
        
    }
}","func numberOfEmployeesWhoMetTarget(hours []int, target int) int {
    
}","object Solution {
    def numberOfEmployeesWhoMetTarget(hours: Array[Int], target: Int): Int = {
        
    }
}","class Solution {
    fun numberOfEmployeesWhoMetTarget(hours: IntArray, target: Int): Int {
        
    }
}","impl Solution {
    pub fn number_of_employees_who_met_target(hours: Vec<i32>, target: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $hours
     * @param Integer $target
     * @return Integer
     */
    function numberOfEmployeesWhoMetTarget($hours, $target) {
        
    }
}","function numberOfEmployeesWhoMetTarget(hours: number[], target: number): number {

};","(define/contract (number-of-employees-who-met-target hours target)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec number_of_employees_who_met_target(Hours :: [integer()], Target :: integer()) -> integer().
number_of_employees_who_met_target(Hours, Target) ->
  .","defmodule Solution do
  @spec number_of_employees_who_met_target(hours :: [integer], target :: integer) :: integer
  def number_of_employees_who_met_target(hours, target) do

  end
end","class Solution {
  int numberOfEmployeesWhoMetTarget(List<int> hours, int target) {

  }
}",
prime-pairs-with-target-sum,Prime Pairs With Target Sum,2761.0,2873.0,"<p>You are given an integer <code>n</code>. We say that two integers <code>x</code> and <code>y</code> form a prime number pair if:</p>

<ul>
	<li><code>1 &lt;= x &lt;= y &lt;= n</code></li>
	<li><code>x + y == n</code></li>
	<li><code>x</code> and <code>y</code> are prime numbers</li>
</ul>

<p>Return <em>the 2D sorted list of prime number pairs</em> <code>[x<sub>i</sub>, y<sub>i</sub>]</code>. The list should be sorted in <strong>increasing</strong> order of <code>x<sub>i</sub></code>. If there are no prime number pairs at all, return <em>an empty array</em>.</p>

<p><strong>Note:</strong> A prime number is a natural number greater than <code>1</code> with only two factors, itself and <code>1</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 10
<strong>Output:</strong> [[3,7],[5,5]]
<strong>Explanation:</strong> In this example, there are two prime pairs that satisfy the criteria. 
These pairs are [3,7] and [5,5], and we return them in the sorted order as described in the problem statement.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> []
<strong>Explanation:</strong> We can show that there is no prime number pair that gives a sum of 2, so we return an empty array. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>6</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<vector<int>> findPrimePairs(int n) {
        
    }
};","class Solution {
    public List<List<Integer>> findPrimePairs(int n) {
        
    }
}","class Solution(object):
    def findPrimePairs(self, n):
        """"""
        :type n: int
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def findPrimePairs(self, n: int) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** findPrimePairs(int n, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public IList<IList<int>> FindPrimePairs(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number[][]}
 */
var findPrimePairs = function(n) {
    
};","# @param {Integer} n
# @return {Integer[][]}
def find_prime_pairs(n)
    
end","class Solution {
    func findPrimePairs(_ n: Int) -> [[Int]] {
        
    }
}","func findPrimePairs(n int) [][]int {
    
}","object Solution {
    def findPrimePairs(n: Int): List[List[Int]] = {
        
    }
}","class Solution {
    fun findPrimePairs(n: Int): List<List<Int>> {
        
    }
}","impl Solution {
    pub fn find_prime_pairs(n: i32) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer[][]
     */
    function findPrimePairs($n) {
        
    }
}","function findPrimePairs(n: number): number[][] {

};","(define/contract (find-prime-pairs n)
  (-> exact-integer? (listof (listof exact-integer?)))

  )","-spec find_prime_pairs(N :: integer()) -> [[integer()]].
find_prime_pairs(N) ->
  .","defmodule Solution do
  @spec find_prime_pairs(n :: integer) :: [[integer]]
  def find_prime_pairs(n) do

  end
end","class Solution {
  List<List<int>> findPrimePairs(int n) {

  }
}",
largest-element-in-an-array-after-merge-operations,Largest Element in an Array after Merge Operations,2789.0,2872.0,"<p>You are given a <strong>0-indexed</strong> array <code>nums</code> consisting of positive integers.</p>

<p>You can do the following operation on the array <strong>any</strong> number of times:</p>

<ul>
	<li>Choose an integer <code>i</code> such that <code>0 &lt;= i &lt; nums.length - 1</code> and <code>nums[i] &lt;= nums[i + 1]</code>. Replace the element <code>nums[i + 1]</code> with <code>nums[i] + nums[i + 1]</code> and delete the element <code>nums[i]</code> from the array.</li>
</ul>

<p>Return <em>the value of the <b>largest</b> element that you can possibly obtain in the final array.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,7,9,3]
<strong>Output:</strong> 21
<strong>Explanation:</strong> We can apply the following operations on the array:
- Choose i = 0. The resulting array will be nums = [<u>5</u>,7,9,3].
- Choose i = 1. The resulting array will be nums = [5,<u>16</u>,3].
- Choose i = 0. The resulting array will be nums = [<u>21</u>,3].
The largest element in the final array is 21. It can be shown that we cannot obtain a larger element.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,3,3]
<strong>Output:</strong> 11
<strong>Explanation:</strong> We can do the following operations on the array:
- Choose i = 1. The resulting array will be nums = [5,<u>6</u>].
- Choose i = 0. The resulting array will be nums = [<u>11</u>].
There is only one element in the final array, which is 11.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long maxArrayValue(vector<int>& nums) {
        
    }
};","class Solution {
    public long maxArrayValue(int[] nums) {
        
    }
}","class Solution(object):
    def maxArrayValue(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxArrayValue(self, nums: List[int]) -> int:
        ","long long maxArrayValue(int* nums, int numsSize){

}","public class Solution {
    public long MaxArrayValue(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var maxArrayValue = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def max_array_value(nums)
    
end","class Solution {
    func maxArrayValue(_ nums: [Int]) -> Int {
        
    }
}","func maxArrayValue(nums []int) int64 {
    
}","object Solution {
    def maxArrayValue(nums: Array[Int]): Long = {
        
    }
}","class Solution {
    fun maxArrayValue(nums: IntArray): Long {
        
    }
}","impl Solution {
    pub fn max_array_value(nums: Vec<i32>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maxArrayValue($nums) {
        
    }
}","function maxArrayValue(nums: number[]): number {

};","(define/contract (max-array-value nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec max_array_value(Nums :: [integer()]) -> integer().
max_array_value(Nums) ->
  .","defmodule Solution do
  @spec max_array_value(nums :: [integer]) :: integer
  def max_array_value(nums) do

  end
end","class Solution {
  int maxArrayValue(List<int> nums) {

  }
}",
double-a-number-represented-as-a-linked-list,Double a Number Represented as a Linked List,2816.0,2871.0,"<p>You are given the <code>head</code> of a <strong>non-empty</strong> linked list representing a non-negative integer without leading zeroes.</p>

<p>Return <em>the </em><code>head</code><em> of the linked list after <strong>doubling</strong> it</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/05/28/example.png"" style=""width: 401px; height: 81px;"" />
<pre>
<strong>Input:</strong> head = [1,8,9]
<strong>Output:</strong> [3,7,8]
<strong>Explanation:</strong> The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/05/28/example2.png"" style=""width: 401px; height: 81px;"" />
<pre>
<strong>Input:</strong> head = [9,9,9]
<strong>Output:</strong> [1,9,9,8]
<strong>Explanation:</strong> The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 10<sup>4</sup>]</code></li>
	<li><font face=""monospace""><code>0 &lt;= Node.val &lt;= 9</code></font></li>
	<li>The input is generated such that the list represents a number that does not have leading zeros, except the number <code>0</code> itself.</li>
</ul>
",2.0,False,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* doubleIt(ListNode* head) {
        
    }
};","/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode doubleIt(ListNode head) {
        
    }
}","# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def doubleIt(self, head):
        """"""
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """"""
        ","# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        ","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* doubleIt(struct ListNode* head){

}","/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public int val;
 *     public ListNode next;
 *     public ListNode(int val=0, ListNode next=null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */
public class Solution {
    public ListNode DoubleIt(ListNode head) {
        
    }
}","/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var doubleIt = function(head) {
    
};","# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @return {ListNode}
def double_it(head)
    
end","/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init() { self.val = 0; self.next = nil; }
 *     public init(_ val: Int) { self.val = val; self.next = nil; }
 *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }
 * }
 */
class Solution {
    func doubleIt(_ head: ListNode?) -> ListNode? {
        
    }
}","/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func doubleIt(head *ListNode) *ListNode {
    
}","/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def doubleIt(head: ListNode): ListNode = {
        
    }
}","/**
 * Example:
 * var li = ListNode(5)
 * var v = li.`val`
 * Definition for singly-linked list.
 * class ListNode(var `val`: Int) {
 *     var next: ListNode? = null
 * }
 */
class Solution {
    fun doubleIt(head: ListNode?): ListNode? {
        
    }
}","// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn double_it(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        
    }
}","/**
 * Definition for a singly-linked list.
 * class ListNode {
 *     public $val = 0;
 *     public $next = null;
 *     function __construct($val = 0, $next = null) {
 *         $this->val = $val;
 *         $this->next = $next;
 *     }
 * }
 */
class Solution {

    /**
     * @param ListNode $head
     * @return ListNode
     */
    function doubleIt($head) {
        
    }
}","/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function doubleIt(head: ListNode | null): ListNode | null {

};","; Definition for singly-linked list:
#|

; val : integer?
; next : (or/c list-node? #f)
(struct list-node
  (val next) #:mutable #:transparent)

; constructor
(define (make-list-node [val 0])
  (list-node val #f))

|#

(define/contract (double-it head)
  (-> (or/c list-node? #f) (or/c list-node? #f))

  )","%% Definition for singly-linked list.
%%
%% -record(list_node, {val = 0 :: integer(),
%%                     next = null :: 'null' | #list_node{}}).

-spec double_it(Head :: #list_node{} | null) -> #list_node{} | null.
double_it(Head) ->
  .","# Definition for singly-linked list.
#
# defmodule ListNode do
#   @type t :: %__MODULE__{
#           val: integer,
#           next: ListNode.t() | nil
#         }
#   defstruct val: 0, next: nil
# end

defmodule Solution do
  @spec double_it(head :: ListNode.t | nil) :: ListNode.t | nil
  def double_it(head) do

  end
end","/**
 * Definition for singly-linked list.
 * class ListNode {
 *   int val;
 *   ListNode? next;
 *   ListNode([this.val = 0, this.next]);
 * }
 */
class Solution {
  ListNode? doubleIt(ListNode? head) {

  }
}",
longest-alternating-subarray,Longest Alternating Subarray,2765.0,2870.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. A subarray <code>s</code> of length <code>m</code> is called <strong>alternating</strong> if:</p>

<ul>
	<li><code>m</code> is greater than <code>1</code>.</li>
	<li><code>s<sub>1</sub> = s<sub>0</sub> + 1</code>.</li>
	<li>The <strong>0-indexed</strong> subarray <code>s</code> looks like <code>[s<sub>0</sub>, s<sub>1</sub>, s<sub>0</sub>, s<sub>1</sub>,...,s<sub>(m-1) % 2</sub>]</code>. In other words, <code>s<sub>1</sub> - s<sub>0</sub> = 1</code>, <code>s<sub>2</sub> - s<sub>1</sub> = -1</code>, <code>s<sub>3</sub> - s<sub>2</sub> = 1</code>, <code>s<sub>4</sub> - s<sub>3</sub> = -1</code>, and so on up to <code>s[m - 1] - s[m - 2] = (-1)<sup>m</sup></code>.</li>
</ul>

<p>Return <em>the maximum length of all <strong>alternating</strong> subarrays present in </em><code>nums</code> <em>or </em><code>-1</code><em> if no such subarray exists</em><em>.</em></p>

<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,4,3,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The alternating subarrays are [3,4], [3,4,3], and [3,4,3,4]. The longest of these is [3,4,3,4], which is of length 4.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,5,6]
<strong>Output:</strong> 2
<strong>Explanation:</strong> [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
",1.0,False,"class Solution {
public:
    int alternatingSubarray(vector<int>& nums) {
        
    }
};","class Solution {
    public int alternatingSubarray(int[] nums) {
        
    }
}","class Solution(object):
    def alternatingSubarray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def alternatingSubarray(self, nums: List[int]) -> int:
        ","int alternatingSubarray(int* nums, int numsSize){

}","public class Solution {
    public int AlternatingSubarray(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var alternatingSubarray = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def alternating_subarray(nums)
    
end","class Solution {
    func alternatingSubarray(_ nums: [Int]) -> Int {
        
    }
}","func alternatingSubarray(nums []int) int {
    
}","object Solution {
    def alternatingSubarray(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun alternatingSubarray(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn alternating_subarray(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function alternatingSubarray($nums) {
        
    }
}","function alternatingSubarray(nums: number[]): number {

};","(define/contract (alternating-subarray nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec alternating_subarray(Nums :: [integer()]) -> integer().
alternating_subarray(Nums) ->
  .","defmodule Solution do
  @spec alternating_subarray(nums :: [integer]) :: integer
  def alternating_subarray(nums) do

  end
end","class Solution {
  int alternatingSubarray(List<int> nums) {

  }
}",
longest-non-decreasing-subarray-from-two-arrays,Longest Non-decreasing Subarray From Two Arrays,2771.0,2869.0,"<p>You are given two <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code> of length <code>n</code>.</p>

<p>Let&#39;s define another <strong>0-indexed</strong> integer array, <code>nums3</code>, of length <code>n</code>. For each index <code>i</code> in the range <code>[0, n - 1]</code>, you can assign either <code>nums1[i]</code> or <code>nums2[i]</code> to <code>nums3[i]</code>.</p>

<p>Your task is to maximize the length of the <strong>longest non-decreasing subarray</strong> in <code>nums3</code> by choosing its values optimally.</p>

<p>Return <em>an integer representing the length of the <strong>longest non-decreasing</strong> subarray in</em> <code>nums3</code>.</p>

<p><strong>Note: </strong>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,3,1], nums2 = [1,2,1]
<strong>Output:</strong> 2
<strong>Explanation: </strong>One way to construct nums3 is: 
nums3 = [nums1[0], nums2[1], nums2[2]] =&gt; [2,2,1]. 
The subarray starting from index 0 and ending at index 1, [2,2], forms a non-decreasing subarray of length 2. 
We can show that 2 is the maximum achievable length.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,3,2,1], nums2 = [2,2,3,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One way to construct nums3 is: 
nums3 = [nums1[0], nums2[1], nums2[2], nums2[3]] =&gt; [1,2,3,4]. 
The entire array forms a non-decreasing subarray of length 4, making it the maximum achievable length.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,1], nums2 = [2,2]
<strong>Output:</strong> 2
<strong>Explanation:</strong> One way to construct nums3 is: 
nums3 = [nums1[0], nums1[1]] =&gt; [1,1]. 
The entire array forms a non-decreasing subarray of length 2, making it the maximum achievable length.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length == nums2.length == n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int maxNonDecreasingLength(vector<int>& nums1, vector<int>& nums2) {
        
    }
};","class Solution {
    public int maxNonDecreasingLength(int[] nums1, int[] nums2) {
        
    }
}","class Solution(object):
    def maxNonDecreasingLength(self, nums1, nums2):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:
        ","int maxNonDecreasingLength(int* nums1, int nums1Size, int* nums2, int nums2Size){

}","public class Solution {
    public int MaxNonDecreasingLength(int[] nums1, int[] nums2) {
        
    }
}","/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var maxNonDecreasingLength = function(nums1, nums2) {
    
};","# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @return {Integer}
def max_non_decreasing_length(nums1, nums2)
    
end","class Solution {
    func maxNonDecreasingLength(_ nums1: [Int], _ nums2: [Int]) -> Int {
        
    }
}","func maxNonDecreasingLength(nums1 []int, nums2 []int) int {
    
}","object Solution {
    def maxNonDecreasingLength(nums1: Array[Int], nums2: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxNonDecreasingLength(nums1: IntArray, nums2: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_non_decreasing_length(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @return Integer
     */
    function maxNonDecreasingLength($nums1, $nums2) {
        
    }
}","function maxNonDecreasingLength(nums1: number[], nums2: number[]): number {

};","(define/contract (max-non-decreasing-length nums1 nums2)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)

  )","-spec max_non_decreasing_length(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().
max_non_decreasing_length(Nums1, Nums2) ->
  .","defmodule Solution do
  @spec max_non_decreasing_length(nums1 :: [integer], nums2 :: [integer]) :: integer
  def max_non_decreasing_length(nums1, nums2) do

  end
end","class Solution {
  int maxNonDecreasingLength(List<int> nums1, List<int> nums2) {

  }
}",
continuous-subarrays,Continuous Subarrays,2762.0,2868.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. A subarray of <code>nums</code> is called <strong>continuous</strong> if:</p>

<ul>
	<li>Let <code>i</code>, <code>i + 1</code>, ..., <code>j</code><sub> </sub>be the indices in the subarray. Then, for each pair of indices <code>i &lt;= i<sub>1</sub>, i<sub>2</sub> &lt;= j</code>, <code><font face=""monospace"">0 &lt;=</font> |nums[i<sub>1</sub>] - nums[i<sub>2</sub>]| &lt;= 2</code>.</li>
</ul>

<p>Return <em>the total number of <strong>continuous</strong> subarrays.</em></p>

<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,4,2,4]
<strong>Output:</strong> 8
<strong>Explanation:</strong> 
Continuous subarray of size 1: [5], [4], [2], [4].
Continuous subarray of size 2: [5,4], [4,2], [2,4].
Continuous subarray of size 3: [4,2,4].
Thereare no subarrys of size 4.
Total continuous subarrays = 4 + 3 + 1 = 8.
It can be shown that there are no more continuous subarrays.
</pre>

<p>&nbsp;</p>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 6
<strong>Explanation:</strong> 
Continuous subarray of size 1: [1], [2], [3].
Continuous subarray of size 2: [1,2], [2,3].
Continuous subarray of size 3: [1,2,3].
Total continuous subarrays = 3 + 2 + 1 = 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long continuousSubarrays(vector<int>& nums) {
        
    }
};","class Solution {
    public long continuousSubarrays(int[] nums) {
        
    }
}","class Solution(object):
    def continuousSubarrays(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def continuousSubarrays(self, nums: List[int]) -> int:
        ","long long continuousSubarrays(int* nums, int numsSize){

}","public class Solution {
    public long ContinuousSubarrays(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var continuousSubarrays = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def continuous_subarrays(nums)
    
end","class Solution {
    func continuousSubarrays(_ nums: [Int]) -> Int {
        
    }
}","func continuousSubarrays(nums []int) int64 {
    
}","object Solution {
    def continuousSubarrays(nums: Array[Int]): Long = {
        
    }
}","class Solution {
    fun continuousSubarrays(nums: IntArray): Long {
        
    }
}","impl Solution {
    pub fn continuous_subarrays(nums: Vec<i32>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function continuousSubarrays($nums) {
        
    }
}","function continuousSubarrays(nums: number[]): number {

};","(define/contract (continuous-subarrays nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec continuous_subarrays(Nums :: [integer()]) -> integer().
continuous_subarrays(Nums) ->
  .","defmodule Solution do
  @spec continuous_subarrays(nums :: [integer]) :: integer
  def continuous_subarrays(nums) do

  end
end","class Solution {
  int continuousSubarrays(List<int> nums) {

  }
}",
ways-to-split-array-into-good-subarrays,Ways to Split Array Into Good Subarrays,2750.0,2867.0,"<p>You are given a binary array <code>nums</code>.</p>

<p>A subarray of an array is <strong>good</strong> if it contains <strong>exactly</strong> <strong>one</strong> element with the value <code>1</code>.</p>

<p>Return <em>an integer denoting the number of ways to split the array </em><code>nums</code><em> into <strong>good</strong> subarrays</em>. As the number may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,0,0,1]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 ways to split nums into good subarrays:
- [0,1] [0,0,1]
- [0,1,0] [0,1]
- [0,1,0,0] [1]
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,0]
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is 1 way to split nums into good subarrays:
- [0,1,0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int numberOfGoodSubarraySplits(vector<int>& nums) {
        
    }
};","class Solution {
    public int numberOfGoodSubarraySplits(int[] nums) {
        
    }
}","class Solution(object):
    def numberOfGoodSubarraySplits(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:
        ","int numberOfGoodSubarraySplits(int* nums, int numsSize){

}","public class Solution {
    public int NumberOfGoodSubarraySplits(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var numberOfGoodSubarraySplits = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def number_of_good_subarray_splits(nums)
    
end","class Solution {
    func numberOfGoodSubarraySplits(_ nums: [Int]) -> Int {
        
    }
}","func numberOfGoodSubarraySplits(nums []int) int {
    
}","object Solution {
    def numberOfGoodSubarraySplits(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun numberOfGoodSubarraySplits(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn number_of_good_subarray_splits(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function numberOfGoodSubarraySplits($nums) {
        
    }
}","function numberOfGoodSubarraySplits(nums: number[]): number {

};","(define/contract (number-of-good-subarray-splits nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec number_of_good_subarray_splits(Nums :: [integer()]) -> integer().
number_of_good_subarray_splits(Nums) ->
  .","defmodule Solution do
  @spec number_of_good_subarray_splits(nums :: [integer]) :: integer
  def number_of_good_subarray_splits(nums) do

  end
end","class Solution {
  int numberOfGoodSubarraySplits(List<int> nums) {

  }
}",
longest-even-odd-subarray-with-threshold,Longest Even Odd Subarray With Threshold,2760.0,2866.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>threshold</code>.</p>

<p>Find the length of the <strong>longest subarray</strong> of <code>nums</code> starting at index <code>l</code> and ending at index <code>r</code> <code>(0 &lt;= l &lt;= r &lt; nums.length)</code> that satisfies the following conditions:</p>

<ul>
	<li><code>nums[l] % 2 == 0</code></li>
	<li>For all indices <code>i</code> in the range <code>[l, r - 1]</code>, <code>nums[i] % 2 != nums[i + 1] % 2</code></li>
	<li>For all indices <code>i</code> in the range <code>[l, r]</code>, <code>nums[i] &lt;= threshold</code></li>
</ul>

<p>Return <em>an integer denoting the length of the longest such subarray.</em></p>

<p><strong>Note:</strong> A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,5,4], threshold = 5
<strong>Output:</strong> 3
<strong>Explanation:</strong> In this example, we can select the subarray that starts at l = 1 and ends at r = 3 =&gt; [2,5,4]. This subarray satisfies the conditions.
Hence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2], threshold = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> In this example, we can select the subarray that starts at l = 1 and ends at r = 1 =&gt; [2]. 
It satisfies all the conditions and we can show that 1 is the maximum possible achievable length.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,4,5], threshold = 4
<strong>Output:</strong> 3
<strong>Explanation:</strong> In this example, we can select the subarray that starts at l = 0 and ends at r = 2 =&gt; [2,3,4]. 
It satisfies all the conditions.
Hence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100 </code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100 </code></li>
	<li><code>1 &lt;= threshold &lt;= 100</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int longestAlternatingSubarray(vector<int>& nums, int threshold) {
        
    }
};","class Solution {
    public int longestAlternatingSubarray(int[] nums, int threshold) {
        
    }
}","class Solution(object):
    def longestAlternatingSubarray(self, nums, threshold):
        """"""
        :type nums: List[int]
        :type threshold: int
        :rtype: int
        """"""
        ","class Solution:
    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:
        ","int longestAlternatingSubarray(int* nums, int numsSize, int threshold){

}","public class Solution {
    public int LongestAlternatingSubarray(int[] nums, int threshold) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} threshold
 * @return {number}
 */
var longestAlternatingSubarray = function(nums, threshold) {
    
};","# @param {Integer[]} nums
# @param {Integer} threshold
# @return {Integer}
def longest_alternating_subarray(nums, threshold)
    
end","class Solution {
    func longestAlternatingSubarray(_ nums: [Int], _ threshold: Int) -> Int {
        
    }
}","func longestAlternatingSubarray(nums []int, threshold int) int {
    
}","object Solution {
    def longestAlternatingSubarray(nums: Array[Int], threshold: Int): Int = {
        
    }
}","class Solution {
    fun longestAlternatingSubarray(nums: IntArray, threshold: Int): Int {
        
    }
}","impl Solution {
    pub fn longest_alternating_subarray(nums: Vec<i32>, threshold: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $threshold
     * @return Integer
     */
    function longestAlternatingSubarray($nums, $threshold) {
        
    }
}","function longestAlternatingSubarray(nums: number[], threshold: number): number {

};","(define/contract (longest-alternating-subarray nums threshold)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec longest_alternating_subarray(Nums :: [integer()], Threshold :: integer()) -> integer().
longest_alternating_subarray(Nums, Threshold) ->
  .","defmodule Solution do
  @spec longest_alternating_subarray(nums :: [integer], threshold :: integer) :: integer
  def longest_alternating_subarray(nums, threshold) do

  end
end","class Solution {
  int longestAlternatingSubarray(List<int> nums, int threshold) {

  }
}",
total-distance-traveled,Total Distance Traveled,2739.0,2857.0,"<p>A truck has two fuel tanks. You are given two integers, <code>mainTank</code> representing the fuel present in the main tank in liters and <code>additionalTank</code> representing the fuel present in the additional tank in liters.</p>

<p>The truck has a mileage of <code>10</code> km per liter. Whenever <code>5</code> liters of fuel get&nbsp;used up in the main tank,&nbsp;if the additional tank has at least <code>1</code> liters of fuel, <code>1</code> liters of fuel will be transferred from the additional tank to the main tank.</p>

<p>Return <em>the maximum distance which can be traveled.</em></p>

<p><strong>Note: </strong>Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> mainTank = 5, additionalTank = 10
<strong>Output:</strong> 60
<strong>Explanation:</strong> 
After spending 5 litre of fuel, fuel remaining is (5 - 5 + 1) = 1 litre and distance traveled is 50km.
After spending another 1 litre of fuel, no fuel gets injected in the main tank and the main tank becomes empty.
Total distance traveled is 60km.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mainTank = 1, additionalTank = 2
<strong>Output:</strong> 10
<strong>Explanation:</strong> 
After spending 1 litre of fuel, the main tank becomes empty.
Total distance traveled is 10km.

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= mainTank, additionalTank &lt;= 100</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int distanceTraveled(int mainTank, int additionalTank) {
        
    }
};","class Solution {
    public int distanceTraveled(int mainTank, int additionalTank) {
        
    }
}","class Solution(object):
    def distanceTraveled(self, mainTank, additionalTank):
        """"""
        :type mainTank: int
        :type additionalTank: int
        :rtype: int
        """"""
        ","class Solution:
    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:
        ","int distanceTraveled(int mainTank, int additionalTank){

}","public class Solution {
    public int DistanceTraveled(int mainTank, int additionalTank) {
        
    }
}","/**
 * @param {number} mainTank
 * @param {number} additionalTank
 * @return {number}
 */
var distanceTraveled = function(mainTank, additionalTank) {
    
};","# @param {Integer} main_tank
# @param {Integer} additional_tank
# @return {Integer}
def distance_traveled(main_tank, additional_tank)
    
end","class Solution {
    func distanceTraveled(_ mainTank: Int, _ additionalTank: Int) -> Int {
        
    }
}","func distanceTraveled(mainTank int, additionalTank int) int {
    
}","object Solution {
    def distanceTraveled(mainTank: Int, additionalTank: Int): Int = {
        
    }
}","class Solution {
    fun distanceTraveled(mainTank: Int, additionalTank: Int): Int {
        
    }
}","impl Solution {
    pub fn distance_traveled(main_tank: i32, additional_tank: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $mainTank
     * @param Integer $additionalTank
     * @return Integer
     */
    function distanceTraveled($mainTank, $additionalTank) {
        
    }
}","function distanceTraveled(mainTank: number, additionalTank: number): number {

};","(define/contract (distance-traveled mainTank additionalTank)
  (-> exact-integer? exact-integer? exact-integer?)

  )","-spec distance_traveled(MainTank :: integer(), AdditionalTank :: integer()) -> integer().
distance_traveled(MainTank, AdditionalTank) ->
  .","defmodule Solution do
  @spec distance_traveled(main_tank :: integer, additional_tank :: integer) :: integer
  def distance_traveled(main_tank, additional_tank) do

  end
end","class Solution {
  int distanceTraveled(int mainTank, int additionalTank) {

  }
}",
count-complete-subarrays-in-an-array,Count Complete Subarrays in an Array,2799.0,2856.0,"<p>You are given an array <code>nums</code> consisting of <strong>positive</strong> integers.</p>

<p>We call a subarray of an array <strong>complete</strong> if the following condition is satisfied:</p>

<ul>
	<li>The number of <strong>distinct</strong> elements in the subarray is equal to the number of distinct elements in the whole array.</li>
</ul>

<p>Return <em>the number of <strong>complete</strong> subarrays</em>.</p>

<p>A <strong>subarray</strong> is a contiguous non-empty part of an array.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,1,2,2]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The complete subarrays are the following: [1,3,1,2], [1,3,1,2,2], [3,1,2] and [3,1,2,2].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,5,5,5]
<strong>Output:</strong> 10
<strong>Explanation:</strong> The array consists only of the integer 5, so any subarray is complete. The number of subarrays that we can choose is 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 2000</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int countCompleteSubarrays(vector<int>& nums) {
        
    }
};","class Solution {
    public int countCompleteSubarrays(int[] nums) {
        
    }
}","class Solution(object):
    def countCompleteSubarrays(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def countCompleteSubarrays(self, nums: List[int]) -> int:
        ","int countCompleteSubarrays(int* nums, int numsSize){

}","public class Solution {
    public int CountCompleteSubarrays(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var countCompleteSubarrays = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def count_complete_subarrays(nums)
    
end","class Solution {
    func countCompleteSubarrays(_ nums: [Int]) -> Int {
        
    }
}","func countCompleteSubarrays(nums []int) int {
    
}","object Solution {
    def countCompleteSubarrays(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun countCompleteSubarrays(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn count_complete_subarrays(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function countCompleteSubarrays($nums) {
        
    }
}","function countCompleteSubarrays(nums: number[]): number {

};","(define/contract (count-complete-subarrays nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec count_complete_subarrays(Nums :: [integer()]) -> integer().
count_complete_subarrays(Nums) ->
  .","defmodule Solution do
  @spec count_complete_subarrays(nums :: [integer]) :: integer
  def count_complete_subarrays(nums) do

  end
end","class Solution {
  int countCompleteSubarrays(List<int> nums) {

  }
}",
maximum-number-of-jumps-to-reach-the-last-index,Maximum Number of Jumps to Reach the Last Index,2770.0,2855.0,"<p>You are given a <strong>0-indexed</strong> array <code>nums</code> of <code>n</code> integers and an integer <code>target</code>.</p>

<p>You are initially positioned at index <code>0</code>. In one step, you can jump from index <code>i</code> to any index <code>j</code> such that:</p>

<ul>
	<li><code>0 &lt;= i &lt; j &lt; n</code></li>
	<li><code>-target &lt;= nums[j] - nums[i] &lt;= target</code></li>
</ul>

<p>Return <em>the <strong>maximum number of jumps</strong> you can make to reach index</em> <code>n - 1</code>.</p>

<p>If there is no way to reach index <code>n - 1</code>, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,6,4,1,2], target = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong> To go from index 0 to index n - 1 with the maximum number of jumps, you can perform the following jumping sequence:
- Jump from index 0 to index 1. 
- Jump from index 1 to index 3.
- Jump from index 3 to index 5.
It can be proven that there is no other jumping sequence that goes from 0 to n - 1 with more than 3 jumps. Hence, the answer is 3. </pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,6,4,1,2], target = 3
<strong>Output:</strong> 5
<strong>Explanation:</strong> To go from index 0 to index n - 1 with the maximum number of jumps, you can perform the following jumping sequence:
- Jump from index 0 to index 1.
- Jump from index 1 to index 2.
- Jump from index 2 to index 3.
- Jump from index 3 to index 4.
- Jump from index 4 to index 5.
It can be proven that there is no other jumping sequence that goes from 0 to n - 1 with more than 5 jumps. Hence, the answer is 5. </pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,6,4,1,2], target = 0
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be proven that there is no jumping sequence that goes from 0 to n - 1. Hence, the answer is -1. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length == n &lt;= 1000</code></li>
	<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= target &lt;= 2 * 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int maximumJumps(vector<int>& nums, int target) {
        
    }
};","class Solution {
    public int maximumJumps(int[] nums, int target) {
        
    }
}","class Solution(object):
    def maximumJumps(self, nums, target):
        """"""
        :type nums: List[int]
        :type target: int
        :rtype: int
        """"""
        ","class Solution:
    def maximumJumps(self, nums: List[int], target: int) -> int:
        ","int maximumJumps(int* nums, int numsSize, int target){

}","public class Solution {
    public int MaximumJumps(int[] nums, int target) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var maximumJumps = function(nums, target) {
    
};","# @param {Integer[]} nums
# @param {Integer} target
# @return {Integer}
def maximum_jumps(nums, target)
    
end","class Solution {
    func maximumJumps(_ nums: [Int], _ target: Int) -> Int {
        
    }
}","func maximumJumps(nums []int, target int) int {
    
}","object Solution {
    def maximumJumps(nums: Array[Int], target: Int): Int = {
        
    }
}","class Solution {
    fun maximumJumps(nums: IntArray, target: Int): Int {
        
    }
}","impl Solution {
    pub fn maximum_jumps(nums: Vec<i32>, target: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $target
     * @return Integer
     */
    function maximumJumps($nums, $target) {
        
    }
}","function maximumJumps(nums: number[], target: number): number {

};","(define/contract (maximum-jumps nums target)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec maximum_jumps(Nums :: [integer()], Target :: integer()) -> integer().
maximum_jumps(Nums, Target) ->
  .","defmodule Solution do
  @spec maximum_jumps(nums :: [integer], target :: integer) :: integer
  def maximum_jumps(nums, target) do

  end
end","class Solution {
  int maximumJumps(List<int> nums, int target) {

  }
}",
decremental-string-concatenation,Decremental String Concatenation,2746.0,2854.0,"<p>You are given a <strong>0-indexed</strong> array <code>words</code> containing <code>n</code> strings.</p>

<p>Let&#39;s define a <strong>join</strong> operation <code>join(x, y)</code> between two strings <code>x</code> and <code>y</code> as concatenating them into <code>xy</code>. However, if the last character of <code>x</code> is equal to the first character of <code>y</code>, one of them is <strong>deleted</strong>.</p>

<p>For example <code>join(&quot;ab&quot;, &quot;ba&quot;) = &quot;aba&quot;</code> and <code>join(&quot;ab&quot;, &quot;cde&quot;) = &quot;abcde&quot;</code>.</p>

<p>You are to perform <code>n - 1</code> <strong>join</strong> operations. Let <code>str<sub>0</sub> = words[0]</code>. Starting from <code>i = 1</code> up to <code>i = n - 1</code>, for the <code>i<sup>th</sup></code> operation, you can do one of the following:</p>

<ul>
	<li>Make <code>str<sub>i</sub> = join(str<sub>i - 1</sub>, words[i])</code></li>
	<li>Make <code>str<sub>i</sub> = join(words[i], str<sub>i - 1</sub>)</code></li>
</ul>

<p>Your task is to <strong>minimize</strong> the length of <code>str<sub>n - 1</sub></code>.</p>

<p>Return <em>an integer denoting the minimum possible length of</em> <code>str<sub>n - 1</sub></code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;aa&quot;,&quot;ab&quot;,&quot;bc&quot;]
<strong>Output:</strong> 4
<strong>Explanation: </strong>In this example, we can perform join operations in the following order to minimize the length of str<sub>2</sub>: 
str<sub>0</sub> = &quot;aa&quot;
str<sub>1</sub> = join(str<sub>0</sub>, &quot;ab&quot;) = &quot;aab&quot;
str<sub>2</sub> = join(str<sub>1</sub>, &quot;bc&quot;) = &quot;aabc&quot; 
It can be shown that the minimum possible length of str<sub>2</sub> is 4.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;ab&quot;,&quot;b&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example, str<sub>0</sub> = &quot;ab&quot;, there are two ways to get str<sub>1</sub>: 
join(str<sub>0</sub>, &quot;b&quot;) = &quot;ab&quot; or join(&quot;b&quot;, str<sub>0</sub>) = &quot;bab&quot;. 
The first string, &quot;ab&quot;, has the minimum length. Hence, the answer is 2.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;aaa&quot;,&quot;c&quot;,&quot;aba&quot;]
<strong>Output:</strong> 6
<strong>Explanation:</strong> In this example, we can perform join operations in the following order to minimize the length of str<sub>2</sub>: 
str<sub>0</sub> = &quot;aaa&quot;
str<sub>1</sub> = join(str<sub>0</sub>, &quot;c&quot;) = &quot;aaac&quot;
str<sub>2</sub> = join(&quot;aba&quot;, str<sub>1</sub>) = &quot;abaaac&quot;
It can be shown that the minimum possible length of str<sub>2</sub> is 6.
</pre>

<div class=""notranslate"" style=""all: initial;"">&nbsp;</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 1000</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 50</code></li>
	<li>Each character in <code>words[i]</code> is an English lowercase letter</li>
</ul>
",2.0,False,"class Solution {
public:
    int minimizeConcatenatedLength(vector<string>& words) {
        
    }
};","class Solution {
    public int minimizeConcatenatedLength(String[] words) {
        
    }
}","class Solution(object):
    def minimizeConcatenatedLength(self, words):
        """"""
        :type words: List[str]
        :rtype: int
        """"""
        ","class Solution:
    def minimizeConcatenatedLength(self, words: List[str]) -> int:
        ","int minimizeConcatenatedLength(char ** words, int wordsSize){

}","public class Solution {
    public int MinimizeConcatenatedLength(string[] words) {
        
    }
}","/**
 * @param {string[]} words
 * @return {number}
 */
var minimizeConcatenatedLength = function(words) {
    
};","# @param {String[]} words
# @return {Integer}
def minimize_concatenated_length(words)
    
end","class Solution {
    func minimizeConcatenatedLength(_ words: [String]) -> Int {
        
    }
}","func minimizeConcatenatedLength(words []string) int {
    
}","object Solution {
    def minimizeConcatenatedLength(words: Array[String]): Int = {
        
    }
}","class Solution {
    fun minimizeConcatenatedLength(words: Array<String>): Int {
        
    }
}","impl Solution {
    pub fn minimize_concatenated_length(words: Vec<String>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @return Integer
     */
    function minimizeConcatenatedLength($words) {
        
    }
}","function minimizeConcatenatedLength(words: string[]): number {

};","(define/contract (minimize-concatenated-length words)
  (-> (listof string?) exact-integer?)

  )","-spec minimize_concatenated_length(Words :: [unicode:unicode_binary()]) -> integer().
minimize_concatenated_length(Words) ->
  .","defmodule Solution do
  @spec minimize_concatenated_length(words :: [String.t]) :: integer
  def minimize_concatenated_length(words) do

  end
end","class Solution {
  int minimizeConcatenatedLength(List<String> words) {

  }
}",
construct-the-longest-new-string,Construct the Longest New String,2745.0,2850.0,"<p>You are given three integers <code>x</code>, <code>y</code>, and <code>z</code>.</p>

<p>You have <code>x</code> strings equal to <code>&quot;AA&quot;</code>, <code>y</code> strings equal to <code>&quot;BB&quot;</code>, and <code>z</code> strings equal to <code>&quot;AB&quot;</code>. You want to choose some (possibly all or none) of these strings and concactenate them in some order to form a new string. This new string must not contain <code>&quot;AAA&quot;</code> or <code>&quot;BBB&quot;</code> as a substring.</p>

<p>Return <em>the maximum possible length of the new string</em>.</p>

<p>A <b>substring</b> is a contiguous <strong>non-empty</strong> sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> x = 2, y = 5, z = 1
<strong>Output:</strong> 12
<strong>Explanation: </strong>We can concactenate the strings &quot;BB&quot;, &quot;AA&quot;, &quot;BB&quot;, &quot;AA&quot;, &quot;BB&quot;, and &quot;AB&quot; in that order. Then, our new string is &quot;BBAABBAABBAB&quot;. 
That string has length 12, and we can show that it is impossible to construct a string of longer length.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> x = 3, y = 2, z = 2
<strong>Output:</strong> 14
<strong>Explanation:</strong> We can concactenate the strings &quot;AB&quot;, &quot;AB&quot;, &quot;AA&quot;, &quot;BB&quot;, &quot;AA&quot;, &quot;BB&quot;, and &quot;AA&quot; in that order. Then, our new string is &quot;ABABAABBAABBAA&quot;. 
That string has length 14, and we can show that it is impossible to construct a string of longer length.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= x, y, z &lt;= 50</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int longestString(int x, int y, int z) {
        
    }
};","class Solution {
    public int longestString(int x, int y, int z) {
        
    }
}","class Solution(object):
    def longestString(self, x, y, z):
        """"""
        :type x: int
        :type y: int
        :type z: int
        :rtype: int
        """"""
        ","class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:
        ","int longestString(int x, int y, int z){

}","public class Solution {
    public int LongestString(int x, int y, int z) {
        
    }
}","/**
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @return {number}
 */
var longestString = function(x, y, z) {
    
};","# @param {Integer} x
# @param {Integer} y
# @param {Integer} z
# @return {Integer}
def longest_string(x, y, z)
    
end","class Solution {
    func longestString(_ x: Int, _ y: Int, _ z: Int) -> Int {
        
    }
}","func longestString(x int, y int, z int) int {
    
}","object Solution {
    def longestString(x: Int, y: Int, z: Int): Int = {
        
    }
}","class Solution {
    fun longestString(x: Int, y: Int, z: Int): Int {
        
    }
}","impl Solution {
    pub fn longest_string(x: i32, y: i32, z: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $x
     * @param Integer $y
     * @param Integer $z
     * @return Integer
     */
    function longestString($x, $y, $z) {
        
    }
}","function longestString(x: number, y: number, z: number): number {

};","(define/contract (longest-string x y z)
  (-> exact-integer? exact-integer? exact-integer? exact-integer?)

  )","-spec longest_string(X :: integer(), Y :: integer(), Z :: integer()) -> integer().
longest_string(X, Y, Z) ->
  .","defmodule Solution do
  @spec longest_string(x :: integer, y :: integer, z :: integer) :: integer
  def longest_string(x, y, z) do

  end
end","class Solution {
  int longestString(int x, int y, int z) {

  }
}",
sum-of-imbalance-numbers-of-all-subarrays,Sum of Imbalance Numbers of All Subarrays,2763.0,2849.0,"<p>The <strong>imbalance number</strong> of a <strong>0-indexed</strong> integer array <code>arr</code> of length <code>n</code> is defined as the number of indices in <code>sarr = sorted(arr)</code> such that:</p>

<ul>
	<li><code>0 &lt;= i &lt; n - 1</code>, and</li>
	<li><code>sarr[i+1] - sarr[i] &gt; 1</code></li>
</ul>

<p>Here, <code>sorted(arr)</code> is the function that returns the sorted version of <code>arr</code>.</p>

<p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, return <em>the <strong>sum of imbalance numbers</strong> of all its <strong>subarrays</strong></em>.</p>

<p>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,1,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 subarrays with non-zero<strong> </strong>imbalance numbers:
- Subarray [3, 1] with an imbalance number of 1.
- Subarray [3, 1, 4] with an imbalance number of 1.
- Subarray [1, 4] with an imbalance number of 1.
The imbalance number of all other subarrays is 0. Hence, the sum of imbalance numbers of all the subarrays of nums is 3. 
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,3,3,5]
<strong>Output:</strong> 8
<strong>Explanation:</strong> There are 7 subarrays with non-zero imbalance numbers:
- Subarray [1, 3] with an imbalance number of 1.
- Subarray [1, 3, 3] with an imbalance number of 1.
- Subarray [1, 3, 3, 3] with an imbalance number of 1.
- Subarray [1, 3, 3, 3, 5] with an imbalance number of 2. 
- Subarray [3, 3, 3, 5] with an imbalance number of 1. 
- Subarray [3, 3, 5] with an imbalance number of 1.
- Subarray [3, 5] with an imbalance number of 1.
The imbalance number of all other subarrays is 0. Hence, the sum of imbalance numbers of all the subarrays of nums is 8. </pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
</ul>
",3.0,False,"class Solution {
public:
    int sumImbalanceNumbers(vector<int>& nums) {
        
    }
};","class Solution {
    public int sumImbalanceNumbers(int[] nums) {
        
    }
}","class Solution(object):
    def sumImbalanceNumbers(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def sumImbalanceNumbers(self, nums: List[int]) -> int:
        ","int sumImbalanceNumbers(int* nums, int numsSize){

}","public class Solution {
    public int SumImbalanceNumbers(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var sumImbalanceNumbers = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def sum_imbalance_numbers(nums)
    
end","class Solution {
    func sumImbalanceNumbers(_ nums: [Int]) -> Int {
        
    }
}","func sumImbalanceNumbers(nums []int) int {
    
}","object Solution {
    def sumImbalanceNumbers(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun sumImbalanceNumbers(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn sum_imbalance_numbers(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function sumImbalanceNumbers($nums) {
        
    }
}","function sumImbalanceNumbers(nums: number[]): number {

};","(define/contract (sum-imbalance-numbers nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec sum_imbalance_numbers(Nums :: [integer()]) -> integer().
sum_imbalance_numbers(Nums) ->
  .","defmodule Solution do
  @spec sum_imbalance_numbers(nums :: [integer]) :: integer
  def sum_imbalance_numbers(nums) do

  end
end","class Solution {
  int sumImbalanceNumbers(List<int> nums) {

  }
}",
special-permutations,Special Permutations,2741.0,2848.0,"<p>You are given a&nbsp;<strong>0-indexed</strong>&nbsp;integer array&nbsp;<code>nums</code>&nbsp;containing&nbsp;<code>n</code>&nbsp;<strong>distinct</strong> positive integers. A permutation of&nbsp;<code>nums</code>&nbsp;is called special if:</p>

<ul>
	<li>For all indexes&nbsp;<code>0 &lt;= i &lt; n - 1</code>, either&nbsp;<code>nums[i] % nums[i+1] == 0</code>&nbsp;or&nbsp;<code>nums[i+1] % nums[i] == 0</code>.</li>
</ul>

<p>Return&nbsp;<em>the total number of special permutations.&nbsp;</em>As the answer could be large, return it&nbsp;<strong>modulo&nbsp;</strong><code>10<sup>9&nbsp;</sup>+ 7</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,6]
<strong>Output:</strong> 2
<strong>Explanation:</strong> [3,6,2] and [2,6,3] are the two special permutations of nums.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> [3,1,4] and [4,1,3] are the two special permutations of nums.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 14</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int specialPerm(vector<int>& nums) {
        
    }
};","class Solution {
    public int specialPerm(int[] nums) {
        
    }
}","class Solution(object):
    def specialPerm(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def specialPerm(self, nums: List[int]) -> int:
        ","int specialPerm(int* nums, int numsSize){

}","public class Solution {
    public int SpecialPerm(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var specialPerm = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def special_perm(nums)
    
end","class Solution {
    func specialPerm(_ nums: [Int]) -> Int {
        
    }
}","func specialPerm(nums []int) int {
    
}","object Solution {
    def specialPerm(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun specialPerm(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn special_perm(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function specialPerm($nums) {
        
    }
}","function specialPerm(nums: number[]): number {

};","(define/contract (special-perm nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec special_perm(Nums :: [integer()]) -> integer().
special_perm(Nums) ->
  .","defmodule Solution do
  @spec special_perm(nums :: [integer]) :: integer
  def special_perm(nums) do

  end
end","class Solution {
  int specialPerm(List<int> nums) {

  }
}",
find-maximum-number-of-string-pairs,Find Maximum Number of String Pairs,2744.0,2847.0,"<p>You are given a <strong>0-indexed</strong> array <code>words</code> consisting of <strong>distinct</strong> strings.</p>

<p>The string <code>words[i]</code> can be paired with the string <code>words[j]</code> if:</p>

<ul>
	<li>The string <code>words[i]</code> is equal to the reversed string of <code>words[j]</code>.</li>
	<li><code>0 &lt;= i &lt; j &lt; words.length</code>.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of pairs that can be formed from the array </em><code>words</code><em>.</em></p>

<p>Note that&nbsp;each string can belong in&nbsp;<strong>at most one</strong> pair.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;cd&quot;,&quot;ac&quot;,&quot;dc&quot;,&quot;ca&quot;,&quot;zz&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example, we can form 2 pair of strings in the following way:
- We pair the 0<sup>th</sup> string with the 2<sup>nd</sup> string, as the reversed string of word[0] is &quot;dc&quot; and is equal to words[2].
- We pair the 1<sup>st</sup> string with the 3<sup>rd</sup> string, as the reversed string of word[1] is &quot;ca&quot; and is equal to words[3].
It can be proven that 2 is the maximum number of pairs that can be formed.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;ab&quot;,&quot;ba&quot;,&quot;cc&quot;]
<strong>Output:</strong> 1
<strong>Explanation:</strong> In this example, we can form 1 pair of strings in the following way:
- We pair the 0<sup>th</sup> string with the 1<sup>st</sup> string, as the reversed string of words[1] is &quot;ab&quot; and is equal to words[0].
It can be proven that 1 is the maximum number of pairs that can be formed.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;aa&quot;,&quot;ab&quot;]
<strong>Output:</strong> 0
<strong>Explanation:</strong> In this example, we are unable to form any pair of strings.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 50</code></li>
	<li><code>words[i].length == 2</code></li>
	<li><code>words</code>&nbsp;consists of distinct strings.</li>
	<li><code>words[i]</code>&nbsp;contains only lowercase English letters.</li>
</ul>
",1.0,False,"class Solution {
public:
    int maximumNumberOfStringPairs(vector<string>& words) {
        
    }
};","class Solution {
    public int maximumNumberOfStringPairs(String[] words) {
        
    }
}","class Solution(object):
    def maximumNumberOfStringPairs(self, words):
        """"""
        :type words: List[str]
        :rtype: int
        """"""
        ","class Solution:
    def maximumNumberOfStringPairs(self, words: List[str]) -> int:
        ","int maximumNumberOfStringPairs(char ** words, int wordsSize){

}","public class Solution {
    public int MaximumNumberOfStringPairs(string[] words) {
        
    }
}","/**
 * @param {string[]} words
 * @return {number}
 */
var maximumNumberOfStringPairs = function(words) {
    
};","# @param {String[]} words
# @return {Integer}
def maximum_number_of_string_pairs(words)
    
end","class Solution {
    func maximumNumberOfStringPairs(_ words: [String]) -> Int {
        
    }
}","func maximumNumberOfStringPairs(words []string) int {
    
}","object Solution {
    def maximumNumberOfStringPairs(words: Array[String]): Int = {
        
    }
}","class Solution {
    fun maximumNumberOfStringPairs(words: Array<String>): Int {
        
    }
}","impl Solution {
    pub fn maximum_number_of_string_pairs(words: Vec<String>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @return Integer
     */
    function maximumNumberOfStringPairs($words) {
        
    }
}","function maximumNumberOfStringPairs(words: string[]): number {

};","(define/contract (maximum-number-of-string-pairs words)
  (-> (listof string?) exact-integer?)

  )","-spec maximum_number_of_string_pairs(Words :: [unicode:unicode_binary()]) -> integer().
maximum_number_of_string_pairs(Words) ->
  .","defmodule Solution do
  @spec maximum_number_of_string_pairs(words :: [String.t]) :: integer
  def maximum_number_of_string_pairs(words) do

  end
end","class Solution {
  int maximumNumberOfStringPairs(List<String> words) {

  }
}",
robot-collisions,Robot Collisions,2751.0,2846.0,"<p>There are <code>n</code> <strong>1-indexed</strong> robots, each having a position on a line, health, and movement direction.</p>

<p>You are given <strong>0-indexed</strong> integer arrays <code>positions</code>, <code>healths</code>, and a string <code>directions</code> (<code>directions[i]</code> is either <strong>&#39;L&#39;</strong> for <strong>left</strong> or <strong>&#39;R&#39;</strong> for <strong>right</strong>). All integers in <code>positions</code> are <strong>unique</strong>.</p>

<p>All robots start moving on the line<strong> simultaneously</strong> at the <strong>same speed </strong>in their given directions. If two robots ever share the same position while moving, they will <strong>collide</strong>.</p>

<p>If two robots collide, the robot with <strong>lower health</strong> is <strong>removed</strong> from the line, and the health of the other robot <strong>decreases</strong> <strong>by one</strong>. The surviving robot continues in the <strong>same</strong> direction it was going. If both robots have the <strong>same</strong> health, they are both<strong> </strong>removed from the line.</p>

<p>Your task is to determine the <strong>health</strong> of the robots that survive the collisions, in the same <strong>order </strong>that the robots were given,<strong> </strong>i.e. final heath of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array.</p>

<p>Return <em>an array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur.</em></p>

<p><strong>Note:</strong> The positions may be unsorted.</p>

<div class=""notranslate"" style=""all: initial;"">&nbsp;</div>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<p><img height=""169"" src=""https://assets.leetcode.com/uploads/2023/05/15/image-20230516011718-12.png"" width=""808"" /></p>

<pre>
<strong>Input:</strong> positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = &quot;RRRRR&quot;
<strong>Output:</strong> [2,17,9,15,10]
<strong>Explanation:</strong> No collision occurs in this example, since all robots are moving in the same direction. So, the health of the robots in order from the first robot is returned, [2, 17, 9, 15, 10].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<p><img height=""176"" src=""https://assets.leetcode.com/uploads/2023/05/15/image-20230516004433-7.png"" width=""717"" /></p>

<pre>
<strong>Input:</strong> positions = [3,5,2,6], healths = [10,10,15,12], directions = &quot;RLRL&quot;
<strong>Output:</strong> [14]
<strong>Explanation:</strong> There are 2 collisions in this example. Firstly, robot 1 and robot 2 will collide, and since both have the same health, they will be removed from the line. Next, robot 3 and robot 4 will collide and since robot 4&#39;s health is smaller, it gets removed, and robot 3&#39;s health becomes 15 - 1 = 14. Only robot 3 remains, so we return [14].
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<p><img height=""172"" src=""https://assets.leetcode.com/uploads/2023/05/15/image-20230516005114-9.png"" width=""732"" /></p>

<pre>
<strong>Input:</strong> positions = [1,2,5,6], healths = [10,10,11,11], directions = &quot;RLRL&quot;
<strong>Output:</strong> []
<strong>Explanation:</strong> Robot 1 and robot 2 will collide and since both have the same health, they are both removed. Robot 3 and 4 will collide and since both have the same health, they are both removed. So, we return an empty array, [].</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= positions.length == healths.length == directions.length == n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= positions[i], healths[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>directions[i] == &#39;L&#39;</code> or <code>directions[i] == &#39;R&#39;</code></li>
	<li>All values in <code>positions</code> are distinct</li>
</ul>
",3.0,False,"class Solution {
public:
    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {
        
    }
};","class Solution {
    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {
        
    }
}","class Solution(object):
    def survivedRobotsHealths(self, positions, healths, directions):
        """"""
        :type positions: List[int]
        :type healths: List[int]
        :type directions: str
        :rtype: List[int]
        """"""
        ","class Solution:
    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* survivedRobotsHealths(int* positions, int positionsSize, int* healths, int healthsSize, char * directions, int* returnSize){

}","public class Solution {
    public IList<int> SurvivedRobotsHealths(int[] positions, int[] healths, string directions) {
        
    }
}","/**
 * @param {number[]} positions
 * @param {number[]} healths
 * @param {string} directions
 * @return {number[]}
 */
var survivedRobotsHealths = function(positions, healths, directions) {
    
};","# @param {Integer[]} positions
# @param {Integer[]} healths
# @param {String} directions
# @return {Integer[]}
def survived_robots_healths(positions, healths, directions)
    
end","class Solution {
    func survivedRobotsHealths(_ positions: [Int], _ healths: [Int], _ directions: String) -> [Int] {
        
    }
}","func survivedRobotsHealths(positions []int, healths []int, directions string) []int {
    
}","object Solution {
    def survivedRobotsHealths(positions: Array[Int], healths: Array[Int], directions: String): List[Int] = {
        
    }
}","class Solution {
    fun survivedRobotsHealths(positions: IntArray, healths: IntArray, directions: String): List<Int> {
        
    }
}","impl Solution {
    pub fn survived_robots_healths(positions: Vec<i32>, healths: Vec<i32>, directions: String) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $positions
     * @param Integer[] $healths
     * @param String $directions
     * @return Integer[]
     */
    function survivedRobotsHealths($positions, $healths, $directions) {
        
    }
}","function survivedRobotsHealths(positions: number[], healths: number[], directions: string): number[] {

};","(define/contract (survived-robots-healths positions healths directions)
  (-> (listof exact-integer?) (listof exact-integer?) string? (listof exact-integer?))

  )","-spec survived_robots_healths(Positions :: [integer()], Healths :: [integer()], Directions :: unicode:unicode_binary()) -> [integer()].
survived_robots_healths(Positions, Healths, Directions) ->
  .","defmodule Solution do
  @spec survived_robots_healths(positions :: [integer], healths :: [integer], directions :: String.t) :: [integer]
  def survived_robots_healths(positions, healths, directions) do

  end
end","class Solution {
  List<int> survivedRobotsHealths(List<int> positions, List<int> healths, String directions) {

  }
}",
find-the-value-of-the-partition,Find the Value of the Partition,2740.0,2845.0,"<p>You are given a <strong>positive</strong> integer array <code>nums</code>.</p>

<p>Partition <code>nums</code> into two arrays,&nbsp;<code>nums1</code> and <code>nums2</code>, such that:</p>

<ul>
	<li>Each element of the array <code>nums</code> belongs to either the array <code>nums1</code> or the array <code>nums2</code>.</li>
	<li>Both arrays are <strong>non-empty</strong>.</li>
	<li>The value of the partition is <strong>minimized</strong>.</li>
</ul>

<p>The value of the partition is <code>|max(nums1) - min(nums2)|</code>.</p>

<p>Here, <code>max(nums1)</code> denotes the maximum element of the array <code>nums1</code>, and <code>min(nums2)</code> denotes the minimum element of the array <code>nums2</code>.</p>

<p>Return <em>the integer denoting the value of such partition</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,2,4]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can partition the array nums into nums1 = [1,2] and nums2 = [3,4].
- The maximum element of the array nums1 is equal to 2.
- The minimum element of the array nums2 is equal to 3.
The value of the partition is |2 - 3| = 1. 
It can be proven that 1 is the minimum value out of all partitions.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [100,1,10]
<strong>Output:</strong> 9
<strong>Explanation:</strong> We can partition the array nums into nums1 = [10] and nums2 = [100,1].
- The maximum element of the array nums1 is equal to 10.
- The minimum element of the array nums2 is equal to 1.
The value of the partition is |10 - 1| = 9.
It can be proven that 9 is the minimum value out of all partitions.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int findValueOfPartition(vector<int>& nums) {
        
    }
};","class Solution {
    public int findValueOfPartition(int[] nums) {
        
    }
}","class Solution(object):
    def findValueOfPartition(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def findValueOfPartition(self, nums: List[int]) -> int:
        ","int findValueOfPartition(int* nums, int numsSize){

}","public class Solution {
    public int FindValueOfPartition(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var findValueOfPartition = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def find_value_of_partition(nums)
    
end","class Solution {
    func findValueOfPartition(_ nums: [Int]) -> Int {
        
    }
}","func findValueOfPartition(nums []int) int {
    
}","object Solution {
    def findValueOfPartition(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun findValueOfPartition(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn find_value_of_partition(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findValueOfPartition($nums) {
        
    }
}","function findValueOfPartition(nums: number[]): number {

};","(define/contract (find-value-of-partition nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec find_value_of_partition(Nums :: [integer()]) -> integer().
find_value_of_partition(Nums) ->
  .","defmodule Solution do
  @spec find_value_of_partition(nums :: [integer]) :: integer
  def find_value_of_partition(nums) do

  end
end","class Solution {
  int findValueOfPartition(List<int> nums) {

  }
}",
sum-of-squares-of-special-elements,Sum of Squares of Special Elements ,2778.0,2844.0,"<p>You are given a <strong>1-indexed</strong> integer array <code>nums</code> of length <code>n</code>.</p>

<p>An element <code>nums[i]</code> of <code>nums</code> is called <strong>special</strong> if <code>i</code> divides <code>n</code>, i.e. <code>n % i == 0</code>.</p>

<p>Return <em>the <strong>sum of the squares</strong> of all <strong>special</strong> elements of </em><code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 21
<strong>Explanation:</strong> There are exactly 3 special elements in nums: nums[1] since 1 divides 4, nums[2] since 2 divides 4, and nums[4] since 4 divides 4. 
Hence, the sum of the squares of all special elements of nums is nums[1] * nums[1] + nums[2] * nums[2] + nums[4] * nums[4] = 1 * 1 + 2 * 2 + 4 * 4 = 21.  
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,7,1,19,18,3]
<strong>Output:</strong> 63
<strong>Explanation:</strong> There are exactly 4 special elements in nums: nums[1] since 1 divides 6, nums[2] since 2 divides 6, nums[3] since 3 divides 6, and nums[6] since 6 divides 6. 
Hence, the sum of the squares of all special elements of nums is nums[1] * nums[1] + nums[2] * nums[2] + nums[3] * nums[3] + nums[6] * nums[6] = 2 * 2 + 7 * 7 + 1 * 1 + 3 * 3 = 63. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length == n &lt;= 50</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 50</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int sumOfSquares(vector<int>& nums) {
        
    }
};","class Solution {
    public int sumOfSquares(int[] nums) {
        
    }
}","class Solution(object):
    def sumOfSquares(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def sumOfSquares(self, nums: List[int]) -> int:
        ","int sumOfSquares(int* nums, int numsSize){

}","public class Solution {
    public int SumOfSquares(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var sumOfSquares = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def sum_of_squares(nums)
    
end","class Solution {
    func sumOfSquares(_ nums: [Int]) -> Int {
        
    }
}","func sumOfSquares(nums []int) int {
    
}","object Solution {
    def sumOfSquares(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun sumOfSquares(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn sum_of_squares(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function sumOfSquares($nums) {
        
    }
}","function sumOfSquares(nums: number[]): number {

};","(define/contract (sum-of-squares nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec sum_of_squares(Nums :: [integer()]) -> integer().
sum_of_squares(Nums) ->
  .","defmodule Solution do
  @spec sum_of_squares(nums :: [integer]) :: integer
  def sum_of_squares(nums) do

  end
end","class Solution {
  int sumOfSquares(List<int> nums) {

  }
}",
maximum-sum-queries,Maximum Sum Queries,2736.0,2839.0,"<p>You are given two <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, each of length <code>n</code>, and a <strong>1-indexed 2D array</strong> <code>queries</code> where <code>queries[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>.</p>

<p>For the <code>i<sup>th</sup></code> query, find the <strong>maximum value</strong> of <code>nums1[j] + nums2[j]</code> among all indices <code>j</code> <code>(0 &lt;= j &lt; n)</code>, where <code>nums1[j] &gt;= x<sub>i</sub></code> and <code>nums2[j] &gt;= y<sub>i</sub></code>, or <strong>-1</strong> if there is no <code>j</code> satisfying the constraints.</p>

<p>Return <em>an array </em><code>answer</code><em> where </em><code>answer[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]
<strong>Output:</strong> [6,10,7]
<strong>Explanation:</strong> 
For the 1st query <code node=""[object Object]"">x<sub>i</sub> = 4</code>&nbsp;and&nbsp;<code node=""[object Object]"">y<sub>i</sub> = 1</code>, we can select index&nbsp;<code node=""[object Object]"">j = 0</code>&nbsp;since&nbsp;<code node=""[object Object]"">nums1[j] &gt;= 4</code>&nbsp;and&nbsp;<code node=""[object Object]"">nums2[j] &gt;= 1</code>. The sum&nbsp;<code node=""[object Object]"">nums1[j] + nums2[j]</code>&nbsp;is 6, and we can show that 6 is the maximum we can obtain.

For the 2nd query <code node=""[object Object]"">x<sub>i</sub> = 1</code>&nbsp;and&nbsp;<code node=""[object Object]"">y<sub>i</sub> = 3</code>, we can select index&nbsp;<code node=""[object Object]"">j = 2</code>&nbsp;since&nbsp;<code node=""[object Object]"">nums1[j] &gt;= 1</code>&nbsp;and&nbsp;<code node=""[object Object]"">nums2[j] &gt;= 3</code>. The sum&nbsp;<code node=""[object Object]"">nums1[j] + nums2[j]</code>&nbsp;is 10, and we can show that 10 is the maximum we can obtain. 

For the 3rd query <code node=""[object Object]"">x<sub>i</sub> = 2</code>&nbsp;and&nbsp;<code node=""[object Object]"">y<sub>i</sub> = 5</code>, we can select index&nbsp;<code node=""[object Object]"">j = 3</code>&nbsp;since&nbsp;<code node=""[object Object]"">nums1[j] &gt;= 2</code>&nbsp;and&nbsp;<code node=""[object Object]"">nums2[j] &gt;= 5</code>. The sum&nbsp;<code node=""[object Object]"">nums1[j] + nums2[j]</code>&nbsp;is 7, and we can show that 7 is the maximum we can obtain.

Therefore, we return&nbsp;<code node=""[object Object]"">[6,10,7]</code>.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]
<strong>Output:</strong> [9,9,9]
<strong>Explanation:</strong> For this example, we can use index&nbsp;<code node=""[object Object]"">j = 2</code>&nbsp;for all the queries since it satisfies the constraints for each query.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]
<strong>Output:</strong> [-1]
<strong>Explanation:</strong> There is one query in this example with <code node=""[object Object]"">x<sub>i</sub></code> = 3 and <code node=""[object Object]"">y<sub>i</sub></code> = 3. For every index, j, either nums1[j] &lt; <code node=""[object Object]"">x<sub>i</sub></code> or nums2[j] &lt; <code node=""[object Object]"">y<sub>i</sub></code>. Hence, there is no solution. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>nums1.length == nums2.length</code>&nbsp;</li>
	<li><code>n ==&nbsp;nums1.length&nbsp;</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup>&nbsp;</code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length ==&nbsp;2</code></li>
	<li><code>x<sub>i</sub>&nbsp;== queries[i][1]</code></li>
	<li><code>y<sub>i</sub> == queries[i][2]</code></li>
	<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {
        
    }
};","class Solution {
    public int[] maximumSumQueries(int[] nums1, int[] nums2, int[][] queries) {
        
    }
}","class Solution(object):
    def maximumSumQueries(self, nums1, nums2, queries):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :type queries: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* maximumSumQueries(int* nums1, int nums1Size, int* nums2, int nums2Size, int** queries, int queriesSize, int* queriesColSize, int* returnSize){

}","public class Solution {
    public int[] MaximumSumQueries(int[] nums1, int[] nums2, int[][] queries) {
        
    }
}","/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number[][]} queries
 * @return {number[]}
 */
var maximumSumQueries = function(nums1, nums2, queries) {
    
};","# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @param {Integer[][]} queries
# @return {Integer[]}
def maximum_sum_queries(nums1, nums2, queries)
    
end","class Solution {
    func maximumSumQueries(_ nums1: [Int], _ nums2: [Int], _ queries: [[Int]]) -> [Int] {
        
    }
}","func maximumSumQueries(nums1 []int, nums2 []int, queries [][]int) []int {
    
}","object Solution {
    def maximumSumQueries(nums1: Array[Int], nums2: Array[Int], queries: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun maximumSumQueries(nums1: IntArray, nums2: IntArray, queries: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn maximum_sum_queries(nums1: Vec<i32>, nums2: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @param Integer[][] $queries
     * @return Integer[]
     */
    function maximumSumQueries($nums1, $nums2, $queries) {
        
    }
}","function maximumSumQueries(nums1: number[], nums2: number[], queries: number[][]): number[] {

};","(define/contract (maximum-sum-queries nums1 nums2 queries)
  (-> (listof exact-integer?) (listof exact-integer?) (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec maximum_sum_queries(Nums1 :: [integer()], Nums2 :: [integer()], Queries :: [[integer()]]) -> [integer()].
maximum_sum_queries(Nums1, Nums2, Queries) ->
  .","defmodule Solution do
  @spec maximum_sum_queries(nums1 :: [integer], nums2 :: [integer], queries :: [[integer]]) :: [integer]
  def maximum_sum_queries(nums1, nums2, queries) do

  end
end","class Solution {
  List<int> maximumSumQueries(List<int> nums1, List<int> nums2, List<List<int>> queries) {

  }
}",
sum-of-matrix-after-queries,Sum of Matrix After Queries,2718.0,2838.0,"<p>You are given an integer <code>n</code> and a <strong>0-indexed</strong>&nbsp;<strong>2D array</strong> <code>queries</code> where <code>queries[i] = [type<sub>i</sub>, index<sub>i</sub>, val<sub>i</sub>]</code>.</p>

<p>Initially, there is a <strong>0-indexed</strong> <code>n x n</code> matrix filled with <code>0</code>&#39;s. For each query, you must apply one of the following changes:</p>

<ul>
	<li>if <code>type<sub>i</sub> == 0</code>, set the values in the row with <code>index<sub>i</sub></code> to <code>val<sub>i</sub></code>, overwriting any previous values.</li>
	<li>if <code>type<sub>i</sub> == 1</code>, set the values in the column with <code>index<sub>i</sub></code> to <code>val<sub>i</sub></code>, overwriting any previous values.</li>
</ul>

<p>Return <em>the sum of integers in the matrix after all queries are applied</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/05/11/exm1.png"" style=""width: 681px; height: 161px;"" />
<pre>
<strong>Input:</strong> n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]]
<strong>Output:</strong> 23
<strong>Explanation:</strong> The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 23. 
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/05/11/exm2.png"" style=""width: 681px; height: 331px;"" />
<pre>
<strong>Input:</strong> n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]]
<strong>Output:</strong> 17
<strong>Explanation:</strong> The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 17.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>queries[i].length == 3</code></li>
	<li><code>0 &lt;= type<sub>i</sub> &lt;= 1</code></li>
	<li><code>0 &lt;= index<sub>i</sub>&nbsp;&lt; n</code></li>
	<li><code>0 &lt;= val<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long matrixSumQueries(int n, vector<vector<int>>& queries) {
        
    }
};","class Solution {
    public long matrixSumQueries(int n, int[][] queries) {
        
    }
}","class Solution(object):
    def matrixSumQueries(self, n, queries):
        """"""
        :type n: int
        :type queries: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:
        ","long long matrixSumQueries(int n, int** queries, int queriesSize, int* queriesColSize){

}","public class Solution {
    public long MatrixSumQueries(int n, int[][] queries) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} queries
 * @return {number}
 */
var matrixSumQueries = function(n, queries) {
    
};","# @param {Integer} n
# @param {Integer[][]} queries
# @return {Integer}
def matrix_sum_queries(n, queries)
    
end","class Solution {
    func matrixSumQueries(_ n: Int, _ queries: [[Int]]) -> Int {
        
    }
}","func matrixSumQueries(n int, queries [][]int) int64 {
    
}","object Solution {
    def matrixSumQueries(n: Int, queries: Array[Array[Int]]): Long = {
        
    }
}","class Solution {
    fun matrixSumQueries(n: Int, queries: Array<IntArray>): Long {
        
    }
}","impl Solution {
    pub fn matrix_sum_queries(n: i32, queries: Vec<Vec<i32>>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $queries
     * @return Integer
     */
    function matrixSumQueries($n, $queries) {
        
    }
}","function matrixSumQueries(n: number, queries: number[][]): number {

};","(define/contract (matrix-sum-queries n queries)
  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)

  )","-spec matrix_sum_queries(N :: integer(), Queries :: [[integer()]]) -> integer().
matrix_sum_queries(N, Queries) ->
  .","defmodule Solution do
  @spec matrix_sum_queries(n :: integer, queries :: [[integer]]) :: integer
  def matrix_sum_queries(n, queries) do

  end
end","class Solution {
  int matrixSumQueries(int n, List<List<int>> queries) {

  }
}",
minimum-operations-to-make-the-integer-zero,Minimum Operations to Make the Integer Zero,2749.0,2837.0,"<p>You are given two integers <code>num1</code> and <code>num2</code>.</p>

<p>In one operation, you can choose integer <code>i</code> in the range <code>[0, 60]</code> and subtract <code>2<sup>i</sup> + num2</code> from <code>num1</code>.</p>

<p>Return <em>the integer denoting the <strong>minimum</strong> number of operations needed to make</em> <code>num1</code> <em>equal to</em> <code>0</code>.</p>

<p>If it is impossible to make <code>num1</code> equal to <code>0</code>, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num1 = 3, num2 = -2
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can make 3 equal to 0 with the following operations:
- We choose i = 2 and substract 2<sup>2</sup> + (-2) from 3, 3 - (4 + (-2)) = 1.
- We choose i = 2 and substract 2<sup>2</sup>&nbsp;+ (-2) from 1, 1 - (4 + (-2)) = -1.
- We choose i = 0 and substract 2<sup>0</sup>&nbsp;+ (-2) from -1, (-1) - (1 + (-2)) = 0.
It can be proven, that 3 is the minimum number of operations that we need to perform.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num1 = 5, num2 = 7
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be proven, that it is impossible to make 5 equal to 0 with the given operation.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= num1 &lt;= 10<sup>9</sup></code></li>
	<li><code><font face=""monospace"">-10<sup>9</sup>&nbsp;&lt;= num2 &lt;= 10<sup>9</sup></font></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int makeTheIntegerZero(int num1, int num2) {
        
    }
};","class Solution {
    public int makeTheIntegerZero(int num1, int num2) {
        
    }
}","class Solution(object):
    def makeTheIntegerZero(self, num1, num2):
        """"""
        :type num1: int
        :type num2: int
        :rtype: int
        """"""
        ","class Solution:
    def makeTheIntegerZero(self, num1: int, num2: int) -> int:
        ","int makeTheIntegerZero(int num1, int num2){

}","public class Solution {
    public int MakeTheIntegerZero(int num1, int num2) {
        
    }
}","/**
 * @param {number} num1
 * @param {number} num2
 * @return {number}
 */
var makeTheIntegerZero = function(num1, num2) {
    
};","# @param {Integer} num1
# @param {Integer} num2
# @return {Integer}
def make_the_integer_zero(num1, num2)
    
end","class Solution {
    func makeTheIntegerZero(_ num1: Int, _ num2: Int) -> Int {
        
    }
}","func makeTheIntegerZero(num1 int, num2 int) int {
    
}","object Solution {
    def makeTheIntegerZero(num1: Int, num2: Int): Int = {
        
    }
}","class Solution {
    fun makeTheIntegerZero(num1: Int, num2: Int): Int {
        
    }
}","impl Solution {
    pub fn make_the_integer_zero(num1: i32, num2: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $num1
     * @param Integer $num2
     * @return Integer
     */
    function makeTheIntegerZero($num1, $num2) {
        
    }
}","function makeTheIntegerZero(num1: number, num2: number): number {

};","(define/contract (make-the-integer-zero num1 num2)
  (-> exact-integer? exact-integer? exact-integer?)

  )","-spec make_the_integer_zero(Num1 :: integer(), Num2 :: integer()) -> integer().
make_the_integer_zero(Num1, Num2) ->
  .","defmodule Solution do
  @spec make_the_integer_zero(num1 :: integer, num2 :: integer) :: integer
  def make_the_integer_zero(num1, num2) do

  end
end","class Solution {
  int makeTheIntegerZero(int num1, int num2) {

  }
}",
neither-minimum-nor-maximum,Neither Minimum nor Maximum,2733.0,2836.0,"<p>Given an integer array <code>nums</code> containing <strong>distinct</strong> <strong>positive</strong> integers, find and return <strong>any</strong> number from the array that is neither the <strong>minimum</strong> nor the <strong>maximum</strong> value in the array, or <strong><code>-1</code></strong> if there is no such number.</p>

<p>Return <em>the selected integer.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,1,4]
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example, the minimum value is 1 and the maximum value is 4. Therefore, either 2 or 3 can be valid answers.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2]
<strong>Output:</strong> -1
<strong>Explanation:</strong> Since there is no number in nums that is neither the maximum nor the minimum, we cannot select a number that satisfies the given condition. Therefore, there is no answer.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Since 2 is neither the maximum nor the minimum value in nums, it is the only valid answer. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
	<li>All values in <code>nums</code> are distinct</li>
</ul>
",1.0,False,"class Solution {
public:
    int findNonMinOrMax(vector<int>& nums) {
        
    }
};","class Solution {
    public int findNonMinOrMax(int[] nums) {
        
    }
}","class Solution(object):
    def findNonMinOrMax(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def findNonMinOrMax(self, nums: List[int]) -> int:
        ","int findNonMinOrMax(int* nums, int numsSize){

}","public class Solution {
    public int FindNonMinOrMax(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var findNonMinOrMax = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def find_non_min_or_max(nums)
    
end","class Solution {
    func findNonMinOrMax(_ nums: [Int]) -> Int {
        
    }
}","func findNonMinOrMax(nums []int) int {
    
}","object Solution {
    def findNonMinOrMax(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun findNonMinOrMax(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn find_non_min_or_max(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findNonMinOrMax($nums) {
        
    }
}","function findNonMinOrMax(nums: number[]): number {

};","(define/contract (find-non-min-or-max nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec find_non_min_or_max(Nums :: [integer()]) -> integer().
find_non_min_or_max(Nums) ->
  .","defmodule Solution do
  @spec find_non_min_or_max(nums :: [integer]) :: integer
  def find_non_min_or_max(nums) do

  end
end","class Solution {
  int findNonMinOrMax(List<int> nums) {

  }
}",
relocate-marbles,Relocate Marbles,2766.0,2834.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> representing the initial positions of some marbles. You are also given two <strong>0-indexed </strong>integer arrays <code>moveFrom</code> and <code>moveTo</code> of <strong>equal</strong> length.</p>

<p>Throughout <code>moveFrom.length</code> steps, you will change the positions of the marbles. On the <code>i<sup>th</sup></code> step, you will move <strong>all</strong> marbles at position <code>moveFrom[i]</code> to position <code>moveTo[i]</code>.</p>

<p>After completing all the steps, return <em>the sorted list of <strong>occupied</strong> positions</em>.</p>

<p><strong>Notes:</strong></p>

<ul>
	<li>We call a position <strong>occupied</strong> if there is at least one marble in that position.</li>
	<li>There may be multiple marbles in a single position.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,6,7,8], moveFrom = [1,7,2], moveTo = [2,9,5]
<strong>Output:</strong> [5,6,8,9]
<strong>Explanation:</strong> Initially, the marbles are at positions 1,6,7,8.
At the i = 0th step, we move the marbles at position 1 to position 2. Then, positions 2,6,7,8 are occupied.
At the i = 1st step, we move the marbles at position 7 to position 9. Then, positions 2,6,8,9 are occupied.
At the i = 2nd step, we move the marbles at position 2 to position 5. Then, positions 5,6,8,9 are occupied.
At the end, the final positions containing at least one marbles are [5,6,8,9].</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,3,3], moveFrom = [1,3], moveTo = [2,2]
<strong>Output:</strong> [2]
<strong>Explanation:</strong> Initially, the marbles are at positions [1,1,3,3].
At the i = 0th step, we move all the marbles at position 1 to position 2. Then, the marbles are at positions [2,2,3,3].
At the i = 1st step, we move all the marbles at position 3 to position 2. Then, the marbles are at positions [2,2,2,2].
Since 2 is the only occupied position, we return [2].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= moveFrom.length &lt;= 10<sup>5</sup></code></li>
	<li><code>moveFrom.length == moveTo.length</code></li>
	<li><code>1 &lt;= nums[i], moveFrom[i], moveTo[i] &lt;= 10<sup>9</sup></code></li>
	<li>The test cases are generated such that there is at least a marble in&nbsp;<code>moveFrom[i]</code>&nbsp;at the moment we want to apply&nbsp;the <code>i<sup>th</sup></code>&nbsp;move.</li>
</ul>
",2.0,False,"class Solution {
public:
    vector<int> relocateMarbles(vector<int>& nums, vector<int>& moveFrom, vector<int>& moveTo) {
        
    }
};","class Solution {
    public List<Integer> relocateMarbles(int[] nums, int[] moveFrom, int[] moveTo) {
        
    }
}","class Solution(object):
    def relocateMarbles(self, nums, moveFrom, moveTo):
        """"""
        :type nums: List[int]
        :type moveFrom: List[int]
        :type moveTo: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* relocateMarbles(int* nums, int numsSize, int* moveFrom, int moveFromSize, int* moveTo, int moveToSize, int* returnSize){

}","public class Solution {
    public IList<int> RelocateMarbles(int[] nums, int[] moveFrom, int[] moveTo) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number[]} moveFrom
 * @param {number[]} moveTo
 * @return {number[]}
 */
var relocateMarbles = function(nums, moveFrom, moveTo) {
    
};","# @param {Integer[]} nums
# @param {Integer[]} move_from
# @param {Integer[]} move_to
# @return {Integer[]}
def relocate_marbles(nums, move_from, move_to)
    
end","class Solution {
    func relocateMarbles(_ nums: [Int], _ moveFrom: [Int], _ moveTo: [Int]) -> [Int] {
        
    }
}","func relocateMarbles(nums []int, moveFrom []int, moveTo []int) []int {
    
}","object Solution {
    def relocateMarbles(nums: Array[Int], moveFrom: Array[Int], moveTo: Array[Int]): List[Int] = {
        
    }
}","class Solution {
    fun relocateMarbles(nums: IntArray, moveFrom: IntArray, moveTo: IntArray): List<Int> {
        
    }
}","impl Solution {
    pub fn relocate_marbles(nums: Vec<i32>, move_from: Vec<i32>, move_to: Vec<i32>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer[] $moveFrom
     * @param Integer[] $moveTo
     * @return Integer[]
     */
    function relocateMarbles($nums, $moveFrom, $moveTo) {
        
    }
}","function relocateMarbles(nums: number[], moveFrom: number[], moveTo: number[]): number[] {

};","(define/contract (relocate-marbles nums moveFrom moveTo)
  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?) (listof exact-integer?))

  )","-spec relocate_marbles(Nums :: [integer()], MoveFrom :: [integer()], MoveTo :: [integer()]) -> [integer()].
relocate_marbles(Nums, MoveFrom, MoveTo) ->
  .","defmodule Solution do
  @spec relocate_marbles(nums :: [integer], move_from :: [integer], move_to :: [integer]) :: [integer]
  def relocate_marbles(nums, move_from, move_to) do

  end
end","class Solution {
  List<int> relocateMarbles(List<int> nums, List<int> moveFrom, List<int> moveTo) {

  }
}",
count-zero-request-servers,Count Zero Request Servers,2747.0,2833.0,"<p>You are given an integer <code>n</code> denoting the total number of servers and a <strong>2D</strong> <strong>0-indexed </strong>integer array <code>logs</code>, where <code>logs[i] = [server_id, time]</code> denotes that the server with id <code>server_id</code> received a request at time <code>time</code>.</p>

<p>You are also given an integer <code>x</code> and a <strong>0-indexed</strong> integer array <code>queries</code>.</p>

<p>Return <em>a <strong>0-indexed</strong> integer array</em> <code>arr</code> <em>of length</em> <code>queries.length</code> <em>where</em> <code>arr[i]</code> <em>represents the number of servers that <strong>did not receive</strong> any requests during the time interval</em> <code>[queries[i] - x, queries[i]]</code>.</p>

<p>Note that the time intervals are inclusive.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3, logs = [[1,3],[2,6],[1,5]], x = 5, queries = [10,11]
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> 
For queries[0]: The servers with ids 1 and 2 get requests in the duration of [5, 10]. Hence, only server 3 gets zero requests.
For queries[1]: Only the server with id 2 gets a request in duration of [6,11]. Hence, the servers with ids 1 and 3 are the only servers that do not receive any requests during that time period.

</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, logs = [[2,4],[2,1],[1,2],[3,1]], x = 2, queries = [3,4]
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong> 
For queries[0]: All servers get at least one request in the duration of [1, 3].
For queries[1]: Only server with id 3 gets no request in the duration [2,4].

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= logs.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code><font face=""monospace"">logs[i].length == 2</font></code></li>
	<li><code>1 &lt;= logs[i][0] &lt;= n</code></li>
	<li><code>1 &lt;= logs[i][1] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= x &lt;= 10<sup>5</sup></code></li>
	<li><code>x &lt;&nbsp;queries[i]&nbsp;&lt;= 10<sup>6</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<int> countServers(int n, vector<vector<int>>& logs, int x, vector<int>& queries) {
        
    }
};","class Solution {
    public int[] countServers(int n, int[][] logs, int x, int[] queries) {
        
    }
}","class Solution(object):
    def countServers(self, n, logs, x, queries):
        """"""
        :type n: int
        :type logs: List[List[int]]
        :type x: int
        :type queries: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* countServers(int n, int** logs, int logsSize, int* logsColSize, int x, int* queries, int queriesSize, int* returnSize){

}","public class Solution {
    public int[] CountServers(int n, int[][] logs, int x, int[] queries) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} logs
 * @param {number} x
 * @param {number[]} queries
 * @return {number[]}
 */
var countServers = function(n, logs, x, queries) {
    
};","# @param {Integer} n
# @param {Integer[][]} logs
# @param {Integer} x
# @param {Integer[]} queries
# @return {Integer[]}
def count_servers(n, logs, x, queries)
    
end","class Solution {
    func countServers(_ n: Int, _ logs: [[Int]], _ x: Int, _ queries: [Int]) -> [Int] {
        
    }
}","func countServers(n int, logs [][]int, x int, queries []int) []int {
    
}","object Solution {
    def countServers(n: Int, logs: Array[Array[Int]], x: Int, queries: Array[Int]): Array[Int] = {
        
    }
}","class Solution {
    fun countServers(n: Int, logs: Array<IntArray>, x: Int, queries: IntArray): IntArray {
        
    }
}","impl Solution {
    pub fn count_servers(n: i32, logs: Vec<Vec<i32>>, x: i32, queries: Vec<i32>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $logs
     * @param Integer $x
     * @param Integer[] $queries
     * @return Integer[]
     */
    function countServers($n, $logs, $x, $queries) {
        
    }
}","function countServers(n: number, logs: number[][], x: number, queries: number[]): number[] {

};","(define/contract (count-servers n logs x queries)
  (-> exact-integer? (listof (listof exact-integer?)) exact-integer? (listof exact-integer?) (listof exact-integer?))

  )","-spec count_servers(N :: integer(), Logs :: [[integer()]], X :: integer(), Queries :: [integer()]) -> [integer()].
count_servers(N, Logs, X, Queries) ->
  .","defmodule Solution do
  @spec count_servers(n :: integer, logs :: [[integer]], x :: integer, queries :: [integer]) :: [integer]
  def count_servers(n, logs, x, queries) do

  end
end","class Solution {
  List<int> countServers(int n, List<List<int>> logs, int x, List<int> queries) {

  }
}",
number-of-beautiful-pairs,Number of Beautiful Pairs,2748.0,2831.0,"<p>You are given a <strong>0-indexed </strong>integer array <code>nums</code>. A pair of indices <code>i</code>, <code>j</code> where <code>0 &lt;=&nbsp;i &lt; j &lt; nums.length</code> is called beautiful if the <strong>first digit</strong> of <code>nums[i]</code> and the <strong>last digit</strong> of <code>nums[j]</code> are <strong>coprime</strong>.</p>

<p>Return <em>the total number of beautiful pairs in </em><code>nums</code>.</p>

<p>Two integers <code>x</code> and <code>y</code> are <strong>coprime</strong> if there is no integer greater than 1 that divides both of them. In other words, <code>x</code> and <code>y</code> are coprime if <code>gcd(x, y) == 1</code>, where <code>gcd(x, y)</code> is the <strong>greatest common divisor</strong> of <code>x</code> and <code>y</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,5,1,4]
<strong>Output:</strong> 5
<strong>Explanation:</strong> There are 5 beautiful pairs in nums:
When i = 0 and j = 1: the first digit of nums[0] is 2, and the last digit of nums[1] is 5. We can confirm that 2 and 5 are coprime, since gcd(2,5) == 1.
When i = 0 and j = 2: the first digit of nums[0] is 2, and the last digit of nums[2] is 1. Indeed, gcd(2,1) == 1.
When i = 1 and j = 2: the first digit of nums[1] is 5, and the last digit of nums[2] is 1. Indeed, gcd(5,1) == 1.
When i = 1 and j = 3: the first digit of nums[1] is 5, and the last digit of nums[3] is 4. Indeed, gcd(5,4) == 1.
When i = 2 and j = 3: the first digit of nums[2] is 1, and the last digit of nums[3] is 4. Indeed, gcd(1,4) == 1.
Thus, we return 5.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [11,21,12]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 2 beautiful pairs:
When i = 0 and j = 1: the first digit of nums[0] is 1, and the last digit of nums[1] is 1. Indeed, gcd(1,1) == 1.
When i = 0 and j = 2: the first digit of nums[0] is 1, and the last digit of nums[2] is 2. Indeed, gcd(1,2) == 1.
Thus, we return 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 9999</code></li>
	<li><code>nums[i] % 10 != 0</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int countBeautifulPairs(vector<int>& nums) {
        
    }
};","class Solution {
    public int countBeautifulPairs(int[] nums) {
        
    }
}","class Solution(object):
    def countBeautifulPairs(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def countBeautifulPairs(self, nums: List[int]) -> int:
        ","int countBeautifulPairs(int* nums, int numsSize){

}","public class Solution {
    public int CountBeautifulPairs(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var countBeautifulPairs = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def count_beautiful_pairs(nums)
    
end","class Solution {
    func countBeautifulPairs(_ nums: [Int]) -> Int {
        
    }
}","func countBeautifulPairs(nums []int) int {
    
}","object Solution {
    def countBeautifulPairs(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun countBeautifulPairs(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn count_beautiful_pairs(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function countBeautifulPairs($nums) {
        
    }
}","function countBeautifulPairs(nums: number[]): number {

};","(define/contract (count-beautiful-pairs nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec count_beautiful_pairs(Nums :: [integer()]) -> integer().
count_beautiful_pairs(Nums) ->
  .","defmodule Solution do
  @spec count_beautiful_pairs(nums :: [integer]) :: integer
  def count_beautiful_pairs(nums) do

  end
end","class Solution {
  int countBeautifulPairs(List<int> nums) {

  }
}",
lexicographically-smallest-string-after-substring-operation,Lexicographically Smallest String After Substring Operation,2734.0,2828.0,"<p>You are given a string <code>s</code> consisting of only lowercase English letters. In one operation, you can do the following:</p>

<ul>
	<li>Select any non-empty substring of <code>s</code>, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, &#39;b&#39; is converted to &#39;a&#39;, and &#39;a&#39; is converted to &#39;z&#39;.</li>
</ul>

<p>Return <em>the <strong>lexicographically smallest</strong> string you can obtain after performing the above operation <strong>exactly once</strong>.</em></p>

<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>
A string <code>x</code> is <strong>lexicographically smaller</strong> than a string <code>y</code> of the same length if <code>x[i]</code> comes before <code>y[i]</code> in alphabetic order for the first position <code>i</code> such that <code>x[i] != y[i]</code>.
<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cbabc&quot;
<strong>Output:</strong> &quot;baabc&quot;
<strong>Explanation:</strong> We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. 
It can be proven that the resulting string is the lexicographically smallest. 
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;acbbc&quot;
<strong>Output:</strong> &quot;abaab&quot;
<strong>Explanation:</strong> We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. 
It can be proven that the resulting string is the lexicographically smallest. 
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leetcode&quot;
<strong>Output:</strong> &quot;kddsbncd&quot;
<strong>Explanation:</strong> We apply the operation on the entire string. 
It can be proven that the resulting string is the lexicographically smallest. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters</li>
</ul>
",2.0,False,"class Solution {
public:
    string smallestString(string s) {
        
    }
};","class Solution {
    public String smallestString(String s) {
        
    }
}","class Solution(object):
    def smallestString(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        ","class Solution:
    def smallestString(self, s: str) -> str:
        ","char * smallestString(char * s){

}","public class Solution {
    public string SmallestString(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {string}
 */
var smallestString = function(s) {
    
};","# @param {String} s
# @return {String}
def smallest_string(s)
    
end","class Solution {
    func smallestString(_ s: String) -> String {
        
    }
}","func smallestString(s string) string {
    
}","object Solution {
    def smallestString(s: String): String = {
        
    }
}","class Solution {
    fun smallestString(s: String): String {
        
    }
}","impl Solution {
    pub fn smallest_string(s: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return String
     */
    function smallestString($s) {
        
    }
}","function smallestString(s: string): string {

};","(define/contract (smallest-string s)
  (-> string? string?)

  )","-spec smallest_string(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
smallest_string(S) ->
  .","defmodule Solution do
  @spec smallest_string(s :: String.t) :: String.t
  def smallest_string(s) do

  end
end","class Solution {
  String smallestString(String s) {

  }
}",
greatest-common-divisor-traversal,Greatest Common Divisor Traversal,2709.0,2827.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>, and you are allowed to <strong>traverse</strong> between its indices. You can traverse between index <code>i</code> and index <code>j</code>, <code>i != j</code>, if and only if <code>gcd(nums[i], nums[j]) &gt; 1</code>, where <code>gcd</code> is the <strong>greatest common divisor</strong>.</p>

<p>Your task is to determine if for <strong>every pair</strong> of indices <code>i</code> and <code>j</code> in nums, where <code>i &lt; j</code>, there exists a <strong>sequence of traversals</strong> that can take us from <code>i</code> to <code>j</code>.</p>

<p>Return <code>true</code><em> if it is possible to traverse between all such pairs of indices,</em><em> or </em><code>false</code><em> otherwise.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,6]
<strong>Output:</strong> true
<strong>Explanation:</strong> In this example, there are 3 possible pairs of indices: (0, 1), (0, 2), and (1, 2).
To go from index 0 to index 1, we can use the sequence of traversals 0 -&gt; 2 -&gt; 1, where we move from index 0 to index 2 because gcd(nums[0], nums[2]) = gcd(2, 6) = 2 &gt; 1, and then move from index 2 to index 1 because gcd(nums[2], nums[1]) = gcd(6, 3) = 3 &gt; 1.
To go from index 0 to index 2, we can just go directly because gcd(nums[0], nums[2]) = gcd(2, 6) = 2 &gt; 1. Likewise, to go from index 1 to index 2, we can just go directly because gcd(nums[1], nums[2]) = gcd(3, 6) = 3 &gt; 1.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,9,5]
<strong>Output:</strong> false
<strong>Explanation:</strong> No sequence of traversals can take us from index 0 to index 2 in this example. So, we return false.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,12,8]
<strong>Output:</strong> true
<strong>Explanation:</strong> There are 6 possible pairs of indices to traverse between: (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), and (2, 3). A valid sequence of traversals exists for each pair, so we return true.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    bool canTraverseAllPairs(vector<int>& nums) {
        
    }
};","class Solution {
    public boolean canTraverseAllPairs(int[] nums) {
        
    }
}","class Solution(object):
    def canTraverseAllPairs(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        ","class Solution:
    def canTraverseAllPairs(self, nums: List[int]) -> bool:
        ","bool canTraverseAllPairs(int* nums, int numsSize){

}","public class Solution {
    public bool CanTraverseAllPairs(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canTraverseAllPairs = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Boolean}
def can_traverse_all_pairs(nums)
    
end","class Solution {
    func canTraverseAllPairs(_ nums: [Int]) -> Bool {
        
    }
}","func canTraverseAllPairs(nums []int) bool {
    
}","object Solution {
    def canTraverseAllPairs(nums: Array[Int]): Boolean = {
        
    }
}","class Solution {
    fun canTraverseAllPairs(nums: IntArray): Boolean {
        
    }
}","impl Solution {
    pub fn can_traverse_all_pairs(nums: Vec<i32>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Boolean
     */
    function canTraverseAllPairs($nums) {
        
    }
}","function canTraverseAllPairs(nums: number[]): boolean {

};","(define/contract (can-traverse-all-pairs nums)
  (-> (listof exact-integer?) boolean?)

  )","-spec can_traverse_all_pairs(Nums :: [integer()]) -> boolean().
can_traverse_all_pairs(Nums) ->
  .","defmodule Solution do
  @spec can_traverse_all_pairs(nums :: [integer]) :: boolean
  def can_traverse_all_pairs(nums) do

  end
end","class Solution {
  bool canTraverseAllPairs(List<int> nums) {

  }
}",
find-a-good-subset-of-the-matrix,Find a Good Subset of the Matrix,2732.0,2826.0,"<p>You are given a <strong>0-indexed</strong> <code>m x n</code> binary matrix <code>grid</code>.</p>

<p>Let us call a <strong>non-empty</strong> subset of rows <strong>good</strong> if the sum of each column of the subset is at most half of the length of the subset.</p>

<p>More formally, if the length of the chosen subset of rows is <code>k</code>, then the sum of each column should be at most <code>floor(k / 2)</code>.</p>

<p>Return <em>an integer array that contains row indices of a good subset sorted in <strong>ascending</strong> order.</em></p>

<p>If there are multiple good subsets, you can return any of them. If there are no good subsets, return an empty array.</p>

<p>A <strong>subset</strong> of rows of the matrix <code>grid</code> is any matrix that can be obtained by deleting some (possibly none or all) rows from <code>grid</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong> We can choose the 0<sup>th</sup> and 1<sup>st</sup> rows to create a good subset of rows.
The length of the chosen subset is 2.
- The sum of the 0<sup>th</sup>&nbsp;column is 0 + 0 = 0, which is at most half of the length of the subset.
- The sum of the 1<sup>st</sup>&nbsp;column is 1 + 0 = 1, which is at most half of the length of the subset.
- The sum of the 2<sup>nd</sup>&nbsp;column is 1 + 0 = 1, which is at most half of the length of the subset.
- The sum of the 3<sup>rd</sup>&nbsp;column is 0 + 1 = 1, which is at most half of the length of the subset.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0]]
<strong>Output:</strong> [0]
<strong>Explanation:</strong> We can choose the 0<sup>th</sup> row to create a good subset of rows.
The length of the chosen subset is 1.
- The sum of the 0<sup>th</sup>&nbsp;column is 0, which is at most half of the length of the subset.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1],[1,1,1]]
<strong>Output:</strong> []
<strong>Explanation:</strong> It is impossible to choose any subset of rows to create a good subset.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= n &lt;= 5</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
",3.0,False,"class Solution {
public:
    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {
        
    }
}","class Solution(object):
    def goodSubsetofBinaryMatrix(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* goodSubsetofBinaryMatrix(int** grid, int gridSize, int* gridColSize, int* returnSize){

}","public class Solution {
    public IList<int> GoodSubsetofBinaryMatrix(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number[]}
 */
var goodSubsetofBinaryMatrix = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer[]}
def good_subsetof_binary_matrix(grid)
    
end","class Solution {
    func goodSubsetofBinaryMatrix(_ grid: [[Int]]) -> [Int] {
        
    }
}","func goodSubsetofBinaryMatrix(grid [][]int) []int {
    
}","object Solution {
    def goodSubsetofBinaryMatrix(grid: Array[Array[Int]]): List[Int] = {
        
    }
}","class Solution {
    fun goodSubsetofBinaryMatrix(grid: Array<IntArray>): List<Int> {
        
    }
}","impl Solution {
    pub fn good_subsetof_binary_matrix(grid: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer[]
     */
    function goodSubsetofBinaryMatrix($grid) {
        
    }
}","function goodSubsetofBinaryMatrix(grid: number[][]): number[] {

};","(define/contract (good-subsetof-binary-matrix grid)
  (-> (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec good_subsetof_binary_matrix(Grid :: [[integer()]]) -> [integer()].
good_subsetof_binary_matrix(Grid) ->
  .","defmodule Solution do
  @spec good_subsetof_binary_matrix(grid :: [[integer]]) :: [integer]
  def good_subsetof_binary_matrix(grid) do

  end
end","class Solution {
  List<int> goodSubsetofBinaryMatrix(List<List<int>> grid) {

  }
}",
minimize-string-length,Minimize String Length,2716.0,2825.0,"<p>Given a <strong>0-indexed</strong> string <code>s</code>, repeatedly perform the following operation <strong>any</strong> number of times:</p>

<ul>
	<li>Choose an index <code>i</code> in the string, and let <code>c</code> be the character in position <code>i</code>. <strong>Delete</strong> the <strong>closest occurrence</strong> of <code>c</code> to the <strong>left</strong> of <code>i</code> (if any) and the <strong>closest occurrence</strong> of <code>c</code> to the <strong>right</strong> of <code>i</code> (if any).</li>
</ul>

<p>Your task is to <strong>minimize</strong> the length of <code>s</code> by performing the above operation any number of times.</p>

<p>Return <em>an integer denoting the length of the <strong>minimized</strong> string.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaabc&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> In this example, s is &quot;aaabc&quot;. We can start by selecting the character &#39;a&#39; at index 1. We then remove the closest &#39;a&#39; to the left of index 1, which is at index 0, and the closest &#39;a&#39; to the right of index 1, which is at index 2. After this operation, the string becomes &quot;abc&quot;. Any further operation we perform on the string will leave it unchanged. Therefore, the length of the minimized string is 3.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cbbd&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> For this we can start with character &#39;b&#39; at index 1. There is no occurrence of &#39;b&#39; to the left of index 1, but there is one to the right at index 2, so we delete the &#39;b&#39; at index 2. The string becomes &quot;cbd&quot; and further operations will leave it unchanged. Hence, the minimized length is 3.&nbsp;
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;dddaaa&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> For this, we can start with the character &#39;d&#39; at index 1. The closest occurrence of a &#39;d&#39; to its left is at index 0, and the closest occurrence of a &#39;d&#39; to its right is at index 2. We delete both index 0 and 2, so the string becomes &quot;daaa&quot;. In the new string, we can select the character &#39;a&#39; at index 2. The closest occurrence of an &#39;a&#39; to its left is at index 1, and the closest occurrence of an &#39;a&#39; to its right is at index 3. We delete both of them, and the string becomes &quot;da&quot;. We cannot minimize this further, so the minimized length is 2.
</pre>

<div class=""notranslate"" style=""all: initial;"">&nbsp;</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> contains only lowercase English letters</li>
</ul>
",1.0,False,"class Solution {
public:
    int minimizedStringLength(string s) {
        
    }
};","class Solution {
    public int minimizedStringLength(String s) {
        
    }
}","class Solution(object):
    def minimizedStringLength(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def minimizedStringLength(self, s: str) -> int:
        ","int minimizedStringLength(char * s){

}","public class Solution {
    public int MinimizedStringLength(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var minimizedStringLength = function(s) {
    
};","# @param {String} s
# @return {Integer}
def minimized_string_length(s)
    
end","class Solution {
    func minimizedStringLength(_ s: String) -> Int {
        
    }
}","func minimizedStringLength(s string) int {
    
}","object Solution {
    def minimizedStringLength(s: String): Int = {
        
    }
}","class Solution {
    fun minimizedStringLength(s: String): Int {
        
    }
}","impl Solution {
    pub fn minimized_string_length(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function minimizedStringLength($s) {
        
    }
}","function minimizedStringLength(s: string): number {

};","(define/contract (minimized-string-length s)
  (-> string? exact-integer?)

  )","-spec minimized_string_length(S :: unicode:unicode_binary()) -> integer().
minimized_string_length(S) ->
  .","defmodule Solution do
  @spec minimized_string_length(s :: String.t) :: integer
  def minimized_string_length(s) do

  end
end","class Solution {
  int minimizedStringLength(String s) {

  }
}",
check-if-the-number-is-fascinating,Check if The Number is Fascinating,2729.0,2824.0,"<p>You are given an integer <code>n</code> that consists of exactly <code>3</code> digits.</p>

<p>We call the number <code>n</code> <strong>fascinating</strong> if, after the following modification, the resulting number contains all the digits from <code>1</code> to <code>9</code> <strong>exactly</strong> once and does not contain any <code>0</code>&#39;s:</p>

<ul>
	<li><strong>Concatenate</strong> <code>n</code> with the numbers <code>2 * n</code> and <code>3 * n</code>.</li>
</ul>

<p>Return <code>true</code><em> if </em><code>n</code><em> is fascinating, or </em><code>false</code><em> otherwise</em>.</p>

<p><strong>Concatenating</strong> two numbers means joining them together. For example, the concatenation of <code>121</code> and <code>371</code> is <code>121371</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 192
<strong>Output:</strong> true
<strong>Explanation:</strong> We concatenate the numbers n = 192 and 2 * n = 384 and 3 * n = 576. The resulting number is 192384576. This number contains all the digits from 1 to 9 exactly once.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 100
<strong>Output:</strong> false
<strong>Explanation:</strong> We concatenate the numbers n = 100 and 2 * n = 200 and 3 * n = 300. The resulting number is 100200300. This number does not satisfy any of the conditions.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>100 &lt;= n &lt;= 999</code></li>
</ul>
",1.0,False,"class Solution {
public:
    bool isFascinating(int n) {
        
    }
};","class Solution {
    public boolean isFascinating(int n) {
        
    }
}","class Solution(object):
    def isFascinating(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        ","class Solution:
    def isFascinating(self, n: int) -> bool:
        ","bool isFascinating(int n){

}","public class Solution {
    public bool IsFascinating(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {boolean}
 */
var isFascinating = function(n) {
    
};","# @param {Integer} n
# @return {Boolean}
def is_fascinating(n)
    
end","class Solution {
    func isFascinating(_ n: Int) -> Bool {
        
    }
}","func isFascinating(n int) bool {
    
}","object Solution {
    def isFascinating(n: Int): Boolean = {
        
    }
}","class Solution {
    fun isFascinating(n: Int): Boolean {
        
    }
}","impl Solution {
    pub fn is_fascinating(n: i32) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Boolean
     */
    function isFascinating($n) {
        
    }
}","function isFascinating(n: number): boolean {

};","(define/contract (is-fascinating n)
  (-> exact-integer? boolean?)

  )","-spec is_fascinating(N :: integer()) -> boolean().
is_fascinating(N) ->
  .","defmodule Solution do
  @spec is_fascinating(n :: integer) :: boolean
  def is_fascinating(n) do

  end
end","class Solution {
  bool isFascinating(int n) {

  }
}",
remove-trailing-zeros-from-a-string,Remove Trailing Zeros From a String,2710.0,2819.0,"<p>Given a <strong>positive</strong> integer <code>num</code> represented as a string, return <em>the integer </em><code>num</code><em> without trailing zeros as a string</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;51230100&quot;
<strong>Output:</strong> &quot;512301&quot;
<strong>Explanation:</strong> Integer &quot;51230100&quot; has 2 trailing zeros, we remove them and return integer &quot;512301&quot;.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;123&quot;
<strong>Output:</strong> &quot;123&quot;
<strong>Explanation:</strong> Integer &quot;123&quot; has no trailing zeros, we return integer &quot;123&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= num.length &lt;= 1000</code></li>
	<li><code>num</code> consists&nbsp;of only digits.</li>
	<li><code>num</code> doesn&#39;t&nbsp;have any leading zeros.</li>
</ul>
",1.0,False,"class Solution {
public:
    string removeTrailingZeros(string num) {
        
    }
};","class Solution {
    public String removeTrailingZeros(String num) {
        
    }
}","class Solution(object):
    def removeTrailingZeros(self, num):
        """"""
        :type num: str
        :rtype: str
        """"""
        ","class Solution:
    def removeTrailingZeros(self, num: str) -> str:
        ","char * removeTrailingZeros(char * num){

}","public class Solution {
    public string RemoveTrailingZeros(string num) {
        
    }
}","/**
 * @param {string} num
 * @return {string}
 */
var removeTrailingZeros = function(num) {
    
};","# @param {String} num
# @return {String}
def remove_trailing_zeros(num)
    
end","class Solution {
    func removeTrailingZeros(_ num: String) -> String {
        
    }
}","func removeTrailingZeros(num string) string {
    
}","object Solution {
    def removeTrailingZeros(num: String): String = {
        
    }
}","class Solution {
    fun removeTrailingZeros(num: String): String {
        
    }
}","impl Solution {
    pub fn remove_trailing_zeros(num: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $num
     * @return String
     */
    function removeTrailingZeros($num) {
        
    }
}","function removeTrailingZeros(num: string): string {

};","(define/contract (remove-trailing-zeros num)
  (-> string? string?)

  )","-spec remove_trailing_zeros(Num :: unicode:unicode_binary()) -> unicode:unicode_binary().
remove_trailing_zeros(Num) ->
  .","defmodule Solution do
  @spec remove_trailing_zeros(num :: String.t) :: String.t
  def remove_trailing_zeros(num) do

  end
end","class Solution {
  String removeTrailingZeros(String num) {

  }
}",
maximum-strictly-increasing-cells-in-a-matrix,Maximum Strictly Increasing Cells in a Matrix,2713.0,2818.0,"<p>Given a <strong>1-indexed</strong>&nbsp;<code>m x n</code> integer matrix <code>mat</code>, you can select any cell in the matrix as your <strong>starting cell</strong>.</p>

<p>From the starting cell, you can move to any other cell <strong>in the</strong> <strong>same row or column</strong>, but only if the value of the destination cell is <strong>strictly greater</strong> than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.</p>

<p>Your task is to find the <strong>maximum number of cells</strong> that you can visit in the matrix by starting from some cell.</p>

<p>Return <em>an integer denoting the maximum number of cells that can be visited.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<p><strong class=""example""><img alt="""" src=""https://assets.leetcode.com/uploads/2023/04/23/diag1drawio.png"" style=""width: 200px; height: 176px;"" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[3,1],[3,4]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2. 
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<p><strong class=""example""><img alt="""" src=""https://assets.leetcode.com/uploads/2023/04/23/diag3drawio.png"" style=""width: 200px; height: 176px;"" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[1,1],[1,1]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Since the cells must be strictly increasing, we can only visit one cell in this example. 
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<p><strong class=""example""><img alt="""" src=""https://assets.leetcode.com/uploads/2023/04/23/diag4drawio.png"" style=""width: 350px; height: 250px;"" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[3,1,6],[-9,5,7]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length&nbsp;</code></li>
	<li><code>n == mat[i].length&nbsp;</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup>&nbsp;&lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    int maxIncreasingCells(vector<vector<int>>& mat) {
        
    }
};","class Solution {
    public int maxIncreasingCells(int[][] mat) {
        
    }
}","class Solution(object):
    def maxIncreasingCells(self, mat):
        """"""
        :type mat: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def maxIncreasingCells(self, mat: List[List[int]]) -> int:
        ","int maxIncreasingCells(int** mat, int matSize, int* matColSize){

}","public class Solution {
    public int MaxIncreasingCells(int[][] mat) {
        
    }
}","/**
 * @param {number[][]} mat
 * @return {number}
 */
var maxIncreasingCells = function(mat) {
    
};","# @param {Integer[][]} mat
# @return {Integer}
def max_increasing_cells(mat)
    
end","class Solution {
    func maxIncreasingCells(_ mat: [[Int]]) -> Int {
        
    }
}","func maxIncreasingCells(mat [][]int) int {
    
}","object Solution {
    def maxIncreasingCells(mat: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun maxIncreasingCells(mat: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn max_increasing_cells(mat: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $mat
     * @return Integer
     */
    function maxIncreasingCells($mat) {
        
    }
}","function maxIncreasingCells(mat: number[][]): number {

};","(define/contract (max-increasing-cells mat)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec max_increasing_cells(Mat :: [[integer()]]) -> integer().
max_increasing_cells(Mat) ->
  .","defmodule Solution do
  @spec max_increasing_cells(mat :: [[integer]]) :: integer
  def max_increasing_cells(mat) do

  end
end","class Solution {
  int maxIncreasingCells(List<List<int>> mat) {

  }
}",
minimum-cost-to-make-all-characters-equal,Minimum Cost to Make All Characters Equal,2712.0,2817.0,"<p>You are given a <strong>0-indexed</strong> binary string <code>s</code> of length <code>n</code> on which you can apply two types of operations:</p>

<ul>
	<li>Choose an index <code>i</code> and invert all characters from&nbsp;index <code>0</code> to index <code>i</code>&nbsp;(both inclusive), with a cost of <code>i + 1</code></li>
	<li>Choose an index <code>i</code> and invert all characters&nbsp;from&nbsp;index <code>i</code> to index <code>n - 1</code>&nbsp;(both inclusive), with a cost of <code>n - i</code></li>
</ul>

<p>Return <em>the <strong>minimum cost </strong>to make all characters of the string <strong>equal</strong></em>.</p>

<p><strong>Invert</strong> a character means&nbsp;if its value is &#39;0&#39; it becomes &#39;1&#39; and vice-versa.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;0011&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> Apply the second operation with <code>i = 2</code> to obtain <code>s = &quot;0000&quot; for a cost of 2</code>. It can be shown that 2 is the minimum cost to make all characters equal.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;010101&quot;
<strong>Output:</strong> 9
<strong>Explanation:</strong> Apply the first operation with i = 2 to obtain s = &quot;101101&quot; for a cost of 3.
Apply the first operation with i = 1 to obtain s = &quot;011101&quot; for a cost of 2. 
Apply the first operation with i = 0 to obtain s = &quot;111101&quot; for a cost of 1. 
Apply the second operation with i = 4 to obtain s = &quot;111110&quot; for a cost of 2.
Apply the second operation with i = 5 to obtain s = &quot;111111&quot; for a cost of 1. 
The total cost to make all characters equal is 9. It can be shown that 9 is the minimum cost to make all characters equal.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length == n &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long minimumCost(string s) {
        
    }
};","class Solution {
    public long minimumCost(String s) {
        
    }
}","class Solution(object):
    def minimumCost(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def minimumCost(self, s: str) -> int:
        ","long long minimumCost(char * s){

}","public class Solution {
    public long MinimumCost(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var minimumCost = function(s) {
    
};","# @param {String} s
# @return {Integer}
def minimum_cost(s)
    
end","class Solution {
    func minimumCost(_ s: String) -> Int {
        
    }
}","func minimumCost(s string) int64 {
    
}","object Solution {
    def minimumCost(s: String): Long = {
        
    }
}","class Solution {
    fun minimumCost(s: String): Long {
        
    }
}","impl Solution {
    pub fn minimum_cost(s: String) -> i64 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function minimumCost($s) {
        
    }
}","function minimumCost(s: string): number {

};","(define/contract (minimum-cost s)
  (-> string? exact-integer?)

  )","-spec minimum_cost(S :: unicode:unicode_binary()) -> integer().
minimum_cost(S) ->
  .","defmodule Solution do
  @spec minimum_cost(s :: String.t) :: integer
  def minimum_cost(s) do

  end
end","class Solution {
  int minimumCost(String s) {

  }
}",
lexicographically-smallest-palindrome,Lexicographically Smallest Palindrome,2697.0,2816.0,"<p>You are given a string <code node=""[object Object]"">s</code> consisting of <strong>lowercase English letters</strong>, and you are allowed to perform operations on it. In one operation, you can <strong>replace</strong> a character in <code node=""[object Object]"">s</code> with another lowercase English letter.</p>

<p>Your task is to make <code node=""[object Object]"">s</code> a <strong>palindrome</strong> with the <strong>minimum</strong> <strong>number</strong> <strong>of operations</strong> possible. If there are <strong>multiple palindromes</strong> that can be <meta charset=""utf-8"" />made using the <strong>minimum</strong> number of operations, <meta charset=""utf-8"" />make the <strong>lexicographically smallest</strong> one.</p>

<p>A string <code>a</code> is lexicographically smaller than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears earlier in the alphabet than the corresponding letter in <code>b</code>.</p>

<p>Return <em>the resulting palindrome string.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;egcfe&quot;
<strong>Output:</strong> &quot;efcfe&quot;
<strong>Explanation:</strong> The minimum number of operations to make &quot;egcfe&quot; a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is &quot;efcfe&quot;, by changing &#39;g&#39;.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;
<strong>Output:</strong> &quot;abba&quot;
<strong>Explanation:</strong> The minimum number of operations to make &quot;abcd&quot; a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is &quot;abba&quot;.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;seven&quot;
<strong>Output:</strong> &quot;neven&quot;
<strong>Explanation:</strong> The minimum number of operations to make &quot;seven&quot; a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is &quot;neven&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s</code>&nbsp;consists of only lowercase English letters<b>.</b></li>
</ul>
",1.0,False,"class Solution {
public:
    string makeSmallestPalindrome(string s) {
        
    }
};","class Solution {
    public String makeSmallestPalindrome(String s) {
        
    }
}","class Solution(object):
    def makeSmallestPalindrome(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        ","class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        ","char * makeSmallestPalindrome(char * s){

}","public class Solution {
    public string MakeSmallestPalindrome(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {string}
 */
var makeSmallestPalindrome = function(s) {
    
};","# @param {String} s
# @return {String}
def make_smallest_palindrome(s)
    
end","class Solution {
    func makeSmallestPalindrome(_ s: String) -> String {
        
    }
}","func makeSmallestPalindrome(s string) string {
    
}","object Solution {
    def makeSmallestPalindrome(s: String): String = {
        
    }
}","class Solution {
    fun makeSmallestPalindrome(s: String): String {
        
    }
}","impl Solution {
    pub fn make_smallest_palindrome(s: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return String
     */
    function makeSmallestPalindrome($s) {
        
    }
}","function makeSmallestPalindrome(s: string): string {

};","(define/contract (make-smallest-palindrome s)
  (-> string? string?)

  )","-spec make_smallest_palindrome(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
make_smallest_palindrome(S) ->
  .","defmodule Solution do
  @spec make_smallest_palindrome(s :: String.t) :: String.t
  def make_smallest_palindrome(s) do

  end
end","class Solution {
  String makeSmallestPalindrome(String s) {

  }
}",
find-the-maximum-achievable-number,Find the Maximum Achievable Number,2769.0,2812.0,"<p>You are given two integers, <code>num</code> and <code>t</code>.</p>

<p>An integer <code>x</code> is called <b>achievable</b> if it can become equal to <code>num</code> after applying the following operation no more than <code>t</code> times:</p>

<ul>
	<li>Increase or decrease <code>x</code> by <code>1</code>, and simultaneously increase or decrease <code>num</code> by <code>1</code>.</li>
</ul>

<p>Return <em>the maximum possible achievable number</em>. It can be proven that there exists at least one achievable number.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num = 4, t = 1
<strong>Output:</strong> 6
<strong>Explanation:</strong> The maximum achievable number is x = 6; it can become equal to num after performing this operation:
1- Decrease x by 1, and increase num by 1. Now, x = 5 and num = 5. 
It can be proven that there is no achievable number larger than 6.

</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num = 3, t = 2
<strong>Output:</strong> 7
<strong>Explanation:</strong> The maximum achievable number is x = 7; after performing these operations, x will equal num: 
1- Decrease x by 1, and increase num by 1. Now, x = 6 and num = 4.
2- Decrease x by 1, and increase num by 1. Now, x = 5 and num = 5.
It can be proven that there is no achievable number larger than 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= num, t&nbsp;&lt;= 50</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int theMaximumAchievableX(int num, int t) {
        
    }
};","class Solution {
    public int theMaximumAchievableX(int num, int t) {
        
    }
}","class Solution(object):
    def theMaximumAchievableX(self, num, t):
        """"""
        :type num: int
        :type t: int
        :rtype: int
        """"""
        ","class Solution:
    def theMaximumAchievableX(self, num: int, t: int) -> int:
        ","int theMaximumAchievableX(int num, int t){

}","public class Solution {
    public int TheMaximumAchievableX(int num, int t) {
        
    }
}","/**
 * @param {number} num
 * @param {number} t
 * @return {number}
 */
var theMaximumAchievableX = function(num, t) {
    
};","# @param {Integer} num
# @param {Integer} t
# @return {Integer}
def the_maximum_achievable_x(num, t)
    
end","class Solution {
    func theMaximumAchievableX(_ num: Int, _ t: Int) -> Int {
        
    }
}","func theMaximumAchievableX(num int, t int) int {
    
}","object Solution {
    def theMaximumAchievableX(num: Int, t: Int): Int = {
        
    }
}","class Solution {
    fun theMaximumAchievableX(num: Int, t: Int): Int {
        
    }
}","impl Solution {
    pub fn the_maximum_achievable_x(num: i32, t: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $num
     * @param Integer $t
     * @return Integer
     */
    function theMaximumAchievableX($num, $t) {
        
    }
}","function theMaximumAchievableX(num: number, t: number): number {

};","(define/contract (the-maximum-achievable-x num t)
  (-> exact-integer? exact-integer? exact-integer?)

  )","-spec the_maximum_achievable_x(Num :: integer(), T :: integer()) -> integer().
the_maximum_achievable_x(Num, T) ->
  .","defmodule Solution do
  @spec the_maximum_achievable_x(num :: integer, t :: integer) :: integer
  def the_maximum_achievable_x(num, t) do

  end
end","class Solution {
  int theMaximumAchievableX(int num, int t) {

  }
}",
collecting-chocolates,Collecting Chocolates,2735.0,2810.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of size <code>n</code> representing the cost of collecting different chocolates. The cost of collecting the chocolate at the index <code>i</code>&nbsp;is <code>nums[i]</code>. Each chocolate is of a different type, and initially, the chocolate at the index&nbsp;<code>i</code>&nbsp;is of <code>i<sup>th</sup></code> type.</p>

<p>In one operation, you can do the following with an incurred <strong>cost</strong> of <code>x</code>:</p>

<ul>
	<li>Simultaneously change the chocolate of <code>i<sup>th</sup></code> type to <code>((i + 1) mod n)<sup>th</sup></code> type for all chocolates.</li>
</ul>

<p>Return <em>the minimum cost to collect chocolates of all types, given that you can perform as many operations as you would like.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [20,1,15], x = 5
<strong>Output:</strong> 13
<strong>Explanation:</strong> Initially, the chocolate types are [0,1,2]. We will buy the 1<sup>st</sup>&nbsp;type of chocolate at a cost of 1.
Now, we will perform the operation at a cost of 5, and the types of chocolates will become [1,2,0]. We will buy the 2<sup>nd</sup><sup> </sup>type of chocolate at a cost of 1.
Now, we will again perform the operation at a cost of 5, and the chocolate types will become [2,0,1]. We will buy the 0<sup>th </sup>type of chocolate at a cost of 1. 
Thus, the total cost will become (1 + 5 + 1 + 5 + 1) = 13. We can prove that this is optimal.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3], x = 4
<strong>Output:</strong> 6
<strong>Explanation:</strong> We will collect all three types of chocolates at their own price without performing any operations. Therefore, the total cost is 1 + 2 + 3 = 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= x &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long minCost(vector<int>& nums, int x) {
        
    }
};","class Solution {
    public long minCost(int[] nums, int x) {
        
    }
}","class Solution(object):
    def minCost(self, nums, x):
        """"""
        :type nums: List[int]
        :type x: int
        :rtype: int
        """"""
        ","class Solution:
    def minCost(self, nums: List[int], x: int) -> int:
        ","long long minCost(int* nums, int numsSize, int x){

}","public class Solution {
    public long MinCost(int[] nums, int x) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} x
 * @return {number}
 */
var minCost = function(nums, x) {
    
};","# @param {Integer[]} nums
# @param {Integer} x
# @return {Integer}
def min_cost(nums, x)
    
end","class Solution {
    func minCost(_ nums: [Int], _ x: Int) -> Int {
        
    }
}","func minCost(nums []int, x int) int64 {
    
}","object Solution {
    def minCost(nums: Array[Int], x: Int): Long = {
        
    }
}","class Solution {
    fun minCost(nums: IntArray, x: Int): Long {
        
    }
}","impl Solution {
    pub fn min_cost(nums: Vec<i32>, x: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $x
     * @return Integer
     */
    function minCost($nums, $x) {
        
    }
}","function minCost(nums: number[], x: number): number {

};","(define/contract (min-cost nums x)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec min_cost(Nums :: [integer()], X :: integer()) -> integer().
min_cost(Nums, X) ->
  .","defmodule Solution do
  @spec min_cost(nums :: [integer], x :: integer) :: integer
  def min_cost(nums, x) do

  end
end","class Solution {
  int minCost(List<int> nums, int x) {

  }
}",
painting-the-walls,Painting the Walls,2742.0,2808.0,"<p>You are given two <strong>0-indexed</strong> integer arrays,&nbsp;<code>cost</code> and <code>time</code>, of size <code>n</code> representing the costs and the time taken to paint <code>n</code> different walls respectively. There are two painters available:</p>

<ul>
	<li>A<strong>&nbsp;paid painter</strong>&nbsp;that paints the <code>i<sup>th</sup></code> wall in <code>time[i]</code> units of time and takes <code>cost[i]</code> units of money.</li>
	<li>A<strong>&nbsp;free painter</strong> that paints&nbsp;<strong>any</strong> wall in <code>1</code> unit of time at a cost of <code>0</code>. But the&nbsp;free painter can only be used if the paid painter is already <strong>occupied</strong>.</li>
</ul>

<p>Return <em>the minimum amount of money required to paint the </em><code>n</code><em>&nbsp;walls.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> cost = [1,2,3,2], time = [1,2,3,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The walls at index 0 and 1 will be painted by the paid painter, and it will take 3 units of time; meanwhile, the free painter will paint the walls at index 2 and 3, free of cost in 2 units of time. Thus, the total cost is 1 + 2 = 3.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> cost = [2,3,4,2], time = [1,1,1,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The walls at index 0 and 3 will be painted by the paid painter, and it will take 2 units of time; meanwhile, the free painter will paint the walls at index 1 and 2, free of cost in 2 units of time. Thus, the total cost is 2 + 2 = 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= cost.length &lt;= 500</code></li>
	<li><code>cost.length == time.length</code></li>
	<li><code>1 &lt;= cost[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= time[i] &lt;= 500</code></li>
</ul>
",3.0,False,"class Solution {
public:
    int paintWalls(vector<int>& cost, vector<int>& time) {
        
    }
};","class Solution {
    public int paintWalls(int[] cost, int[] time) {
        
    }
}","class Solution(object):
    def paintWalls(self, cost, time):
        """"""
        :type cost: List[int]
        :type time: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def paintWalls(self, cost: List[int], time: List[int]) -> int:
        ","int paintWalls(int* cost, int costSize, int* time, int timeSize){

}","public class Solution {
    public int PaintWalls(int[] cost, int[] time) {
        
    }
}","/**
 * @param {number[]} cost
 * @param {number[]} time
 * @return {number}
 */
var paintWalls = function(cost, time) {
    
};","# @param {Integer[]} cost
# @param {Integer[]} time
# @return {Integer}
def paint_walls(cost, time)
    
end","class Solution {
    func paintWalls(_ cost: [Int], _ time: [Int]) -> Int {
        
    }
}","func paintWalls(cost []int, time []int) int {
    
}","object Solution {
    def paintWalls(cost: Array[Int], time: Array[Int]): Int = {
        
    }
}","class Solution {
    fun paintWalls(cost: IntArray, time: IntArray): Int {
        
    }
}","impl Solution {
    pub fn paint_walls(cost: Vec<i32>, time: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $cost
     * @param Integer[] $time
     * @return Integer
     */
    function paintWalls($cost, $time) {
        
    }
}","function paintWalls(cost: number[], time: number[]): number {

};","(define/contract (paint-walls cost time)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)

  )","-spec paint_walls(Cost :: [integer()], Time :: [integer()]) -> integer().
paint_walls(Cost, Time) ->
  .","defmodule Solution do
  @spec paint_walls(cost :: [integer], time :: [integer]) :: integer
  def paint_walls(cost, time) do

  end
end","class Solution {
  int paintWalls(List<int> cost, List<int> time) {

  }
}",
modify-graph-edge-weights,Modify Graph Edge Weights,2699.0,2803.0,"<p>You are given an <strong>undirected weighted</strong> <strong>connected</strong> graph containing <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, and an integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, w<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> with weight <code>w<sub>i</sub></code>.</p>

<p>Some edges have a weight of <code>-1</code> (<code>w<sub>i</sub> = -1</code>), while others have a <strong>positive</strong> weight (<code>w<sub>i</sub> &gt; 0</code>).</p>

<p>Your task is to modify <strong>all edges</strong> with a weight of <code>-1</code> by assigning them <strong>positive integer values </strong>in the range <code>[1, 2 * 10<sup>9</sup>]</code> so that the <strong>shortest distance</strong> between the nodes <code>source</code> and <code>destination</code> becomes equal to an integer <code>target</code>. If there are <strong>multiple</strong> <strong>modifications</strong> that make the shortest distance between <code>source</code> and <code>destination</code> equal to <code>target</code>, any of them will be considered correct.</p>

<p>Return <em>an array containing all edges (even unmodified ones) in any order if it is possible to make the shortest distance from </em><code>source</code><em> to </em><code>destination</code><em> equal to </em><code>target</code><em>, or an <strong>empty array</strong> if it&#39;s impossible.</em></p>

<p><strong>Note:</strong> You are not allowed to modify the weights of edges with initial positive weights.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<p><strong class=""example""><img alt="""" src=""https://assets.leetcode.com/uploads/2023/04/18/graph.png"" style=""width: 300px; height: 300px;"" /></strong></p>

<pre>
<strong>Input:</strong> n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5
<strong>Output:</strong> [[4,1,1],[2,0,1],[0,3,3],[4,3,1]]
<strong>Explanation:</strong> The graph above shows a possible modification to the edges, making the distance from 0 to 1 equal to 5.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<p><strong class=""example""><img alt="""" src=""https://assets.leetcode.com/uploads/2023/04/18/graph-2.png"" style=""width: 300px; height: 300px;"" /></strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6
<strong>Output:</strong> []
<strong>Explanation:</strong> The graph above contains the initial edges. It is not possible to make the distance from 0 to 2 equal to 6 by modifying the edge with weight -1. So, an empty array is returned.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<p><strong class=""example""><img alt="""" src=""https://assets.leetcode.com/uploads/2023/04/19/graph-3.png"" style=""width: 300px; height: 300px;"" /></strong></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6
<strong>Output:</strong> [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]
<strong>Explanation:</strong> The graph above shows a modified graph having the shortest distance from 0 to 2 as 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code><font face=""monospace"">1 &lt;= edges.length &lt;= n * (n - 1) / 2</font></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i&nbsp;</sub>&lt;&nbsp;n</code></li>
	<li><code><font face=""monospace"">w<sub>i</sub>&nbsp;= -1&nbsp;</font></code>or <code><font face=""monospace"">1 &lt;= w<sub>i&nbsp;</sub>&lt;= 10<sup><span style=""font-size: 10.8333px;"">7</span></sup></font></code></li>
	<li><code>a<sub>i&nbsp;</sub>!=&nbsp;b<sub>i</sub></code></li>
	<li><code>0 &lt;= source, destination &lt; n</code></li>
	<li><code>source != destination</code></li>
	<li><code><font face=""monospace"">1 &lt;= target &lt;= 10<sup>9</sup></font></code></li>
	<li>The graph is connected, and there are no self-loops or repeated edges</li>
</ul>
",3.0,False,"class Solution {
public:
    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {
        
    }
};","class Solution {
    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {
        
    }
}","class Solution(object):
    def modifiedGraphEdges(self, n, edges, source, destination, target):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :type source: int
        :type destination: int
        :type target: int
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** modifiedGraphEdges(int n, int** edges, int edgesSize, int* edgesColSize, int source, int destination, int target, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public int[][] ModifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number} source
 * @param {number} destination
 * @param {number} target
 * @return {number[][]}
 */
var modifiedGraphEdges = function(n, edges, source, destination, target) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @param {Integer} source
# @param {Integer} destination
# @param {Integer} target
# @return {Integer[][]}
def modified_graph_edges(n, edges, source, destination, target)
    
end","class Solution {
    func modifiedGraphEdges(_ n: Int, _ edges: [[Int]], _ source: Int, _ destination: Int, _ target: Int) -> [[Int]] {
        
    }
}","func modifiedGraphEdges(n int, edges [][]int, source int, destination int, target int) [][]int {
    
}","object Solution {
    def modifiedGraphEdges(n: Int, edges: Array[Array[Int]], source: Int, destination: Int, target: Int): Array[Array[Int]] = {
        
    }
}","class Solution {
    fun modifiedGraphEdges(n: Int, edges: Array<IntArray>, source: Int, destination: Int, target: Int): Array<IntArray> {
        
    }
}","impl Solution {
    pub fn modified_graph_edges(n: i32, edges: Vec<Vec<i32>>, source: i32, destination: i32, target: i32) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @param Integer $source
     * @param Integer $destination
     * @param Integer $target
     * @return Integer[][]
     */
    function modifiedGraphEdges($n, $edges, $source, $destination, $target) {
        
    }
}","function modifiedGraphEdges(n: number, edges: number[][], source: number, destination: number, target: number): number[][] {

};","(define/contract (modified-graph-edges n edges source destination target)
  (-> exact-integer? (listof (listof exact-integer?)) exact-integer? exact-integer? exact-integer? (listof (listof exact-integer?)))

  )","-spec modified_graph_edges(N :: integer(), Edges :: [[integer()]], Source :: integer(), Destination :: integer(), Target :: integer()) -> [[integer()]].
modified_graph_edges(N, Edges, Source, Destination, Target) ->
  .","defmodule Solution do
  @spec modified_graph_edges(n :: integer, edges :: [[integer]], source :: integer, destination :: integer, target :: integer) :: [[integer]]
  def modified_graph_edges(n, edges, source, destination, target) do

  end
end","class Solution {
  List<List<int>> modifiedGraphEdges(int n, List<List<int>> edges, int source, int destination, int target) {

  }
}",
find-the-punishment-number-of-an-integer,Find the Punishment Number of an Integer,2698.0,2802.0,"<p>Given a positive integer <code>n</code>, return <em>the <strong>punishment number</strong></em> of <code>n</code>.</p>

<p>The <strong>punishment number</strong> of <code>n</code> is defined as the sum of the squares of all integers <code>i</code> such that:</p>

<ul>
	<li><code>1 &lt;= i &lt;= n</code></li>
	<li>The decimal representation of <code>i * i</code> can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals <code>i</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 10
<strong>Output:</strong> 182
<strong>Explanation:</strong> There are exactly 3 integers i that satisfy the conditions in the statement:
- 1 since 1 * 1 = 1
- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.
- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.
Hence, the punishment number of 10 is 1 + 81 + 100 = 182
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 37
<strong>Output:</strong> 1478
<strong>Explanation:</strong> There are exactly 4 integers i that satisfy the conditions in the statement:
- 1 since 1 * 1 = 1. 
- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. 
- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. 
- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.
Hence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int punishmentNumber(int n) {
        
    }
};","class Solution {
    public int punishmentNumber(int n) {
        
    }
}","class Solution(object):
    def punishmentNumber(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def punishmentNumber(self, n: int) -> int:
        ","int punishmentNumber(int n){

}","public class Solution {
    public int PunishmentNumber(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var punishmentNumber = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def punishment_number(n)
    
end","class Solution {
    func punishmentNumber(_ n: Int) -> Int {
        
    }
}","func punishmentNumber(n int) int {
    
}","object Solution {
    def punishmentNumber(n: Int): Int = {
        
    }
}","class Solution {
    fun punishmentNumber(n: Int): Int {
        
    }
}","impl Solution {
    pub fn punishment_number(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function punishmentNumber($n) {
        
    }
}","function punishmentNumber(n: number): number {

};","(define/contract (punishment-number n)
  (-> exact-integer? exact-integer?)

  )","-spec punishment_number(N :: integer()) -> integer().
punishment_number(N) ->
  .","defmodule Solution do
  @spec punishment_number(n :: integer) :: integer
  def punishment_number(n) do

  end
end","class Solution {
  int punishmentNumber(int n) {

  }
}",
difference-of-number-of-distinct-values-on-diagonals,Difference of Number of Distinct Values on Diagonals,2711.0,2801.0,"<p>Given a <strong>0-indexed</strong> 2D <code>grid</code> of size <code>m x n</code>, you should find the matrix <code>answer</code> of size <code>m x n</code>.</p>

<p>The value of each cell <code>(r, c)</code> of the matrix <code>answer</code> is calculated in the following way:</p>

<ul>
	<li>Let <code>topLeft[r][c]</code> be the number of <strong>distinct</strong> values in the top-left diagonal of the cell <code>(r, c)</code> in the matrix <code>grid</code>.</li>
	<li>Let <code>bottomRight[r][c]</code> be the number of <strong>distinct</strong> values in the bottom-right diagonal of the cell <code>(r, c)</code> in the matrix <code>grid</code>.</li>
</ul>

<p>Then <code>answer[r][c] = |topLeft[r][c] - bottomRight[r][c]|</code>.</p>

<p>Return <em>the matrix</em> <code>answer</code>.</p>

<p>A <strong>matrix diagonal</strong> is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix&#39;s end.</p>

<p>A cell <code>(r<sub>1</sub>, c<sub>1</sub>)</code> belongs to the top-left diagonal of the cell <code>(r, c)</code>, if both belong to the same diagonal and <code>r<sub>1</sub> &lt; r</code>. Similarly is defined bottom-right diagonal.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/04/19/ex2.png"" style=""width: 786px; height: 121px;"" />
<pre>
<strong>
Input:</strong> grid = [[1,2,3],[3,1,5],[3,2,1]]
<strong>Output:</strong> [[1,1,0],[1,0,1],[0,1,1]]
<strong>Explanation:</strong> The 1<sup>st</sup> diagram denotes the initial grid.&nbsp;
The 2<sup>nd</sup> diagram denotes a grid for cell (0,0), where blue-colored cells are cells on its bottom-right diagonal.
The 3<sup>rd</sup> diagram denotes a grid for cell (1,2), where red-colored cells are cells on its top-left diagonal.
The 4<sup>th</sup> diagram denotes a grid for cell (1,1), where blue-colored cells are cells on its bottom-right diagonal and red-colored cells are cells on its top-left diagonal.
- The cell (0,0) contains [1,1] on its bottom-right diagonal and [] on its top-left diagonal. The answer is |1 - 0| = 1.
- The cell (1,2) contains [] on its bottom-right diagonal and [2] on its top-left diagonal. The answer is |0 - 1| = 1.
- The cell (1,1) contains [1] on its bottom-right diagonal and [1] on its top-left diagonal. The answer is |1 - 1| = 0.
The answers of other cells are similarly calculated.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1]]
<strong>Output:</strong> [[0]]
<strong>Explanation:</strong> - The cell (0,0) contains [] on its bottom-right diagonal and [] on its top-left diagonal. The answer is |0 - 0| = 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n, grid[i][j] &lt;= 50</code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int[][] differenceOfDistinctValues(int[][] grid) {
        
    }
}","class Solution(object):
    def differenceOfDistinctValues(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** differenceOfDistinctValues(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public int[][] DifferenceOfDistinctValues(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number[][]}
 */
var differenceOfDistinctValues = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer[][]}
def difference_of_distinct_values(grid)
    
end","class Solution {
    func differenceOfDistinctValues(_ grid: [[Int]]) -> [[Int]] {
        
    }
}","func differenceOfDistinctValues(grid [][]int) [][]int {
    
}","object Solution {
    def differenceOfDistinctValues(grid: Array[Array[Int]]): Array[Array[Int]] = {
        
    }
}","class Solution {
    fun differenceOfDistinctValues(grid: Array<IntArray>): Array<IntArray> {
        
    }
}","impl Solution {
    pub fn difference_of_distinct_values(grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer[][]
     */
    function differenceOfDistinctValues($grid) {
        
    }
}","function differenceOfDistinctValues(grid: number[][]): number[][] {

};","(define/contract (difference-of-distinct-values grid)
  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)))

  )","-spec difference_of_distinct_values(Grid :: [[integer()]]) -> [[integer()]].
difference_of_distinct_values(Grid) ->
  .","defmodule Solution do
  @spec difference_of_distinct_values(grid :: [[integer]]) :: [[integer]]
  def difference_of_distinct_values(grid) do

  end
end","class Solution {
  List<List<int>> differenceOfDistinctValues(List<List<int>> grid) {

  }
}",
minimum-string-length-after-removing-substrings,Minimum String Length After Removing Substrings,2696.0,2800.0,"<p>You are given a string <code>s</code> consisting only of <strong>uppercase</strong> English letters.</p>

<p>You can apply some operations to this string where, in one operation, you can remove <strong>any</strong> occurrence of one of the substrings <code>&quot;AB&quot;</code> or <code>&quot;CD&quot;</code> from <code>s</code>.</p>

<p>Return <em>the <strong>minimum</strong> possible length of the resulting string that you can obtain</em>.</p>

<p><strong>Note</strong> that the string concatenates after removing the substring and could produce new <code>&quot;AB&quot;</code> or <code>&quot;CD&quot;</code> substrings.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ABFCACDB&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can do the following operations:
- Remove the substring &quot;<u>AB</u>FCACDB&quot;, so s = &quot;FCACDB&quot;.
- Remove the substring &quot;FCA<u>CD</u>B&quot;, so s = &quot;FCAB&quot;.
- Remove the substring &quot;FC<u>AB</u>&quot;, so s = &quot;FC&quot;.
So the resulting length of the string is 2.
It can be shown that it is the minimum length that we can obtain.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ACBBD&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> We cannot do any operations on the string so the length remains the same.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code>&nbsp;consists only of uppercase English letters.</li>
</ul>
",1.0,False,"class Solution {
public:
    int minLength(string s) {
        
    }
};","class Solution {
    public int minLength(String s) {
        
    }
}","class Solution(object):
    def minLength(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def minLength(self, s: str) -> int:
        ","int minLength(char * s){

}","public class Solution {
    public int MinLength(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var minLength = function(s) {
    
};","# @param {String} s
# @return {Integer}
def min_length(s)
    
end","class Solution {
    func minLength(_ s: String) -> Int {
        
    }
}","func minLength(s string) int {
    
}","object Solution {
    def minLength(s: String): Int = {
        
    }
}","class Solution {
    fun minLength(s: String): Int {
        
    }
}","impl Solution {
    pub fn min_length(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function minLength($s) {
        
    }
}","function minLength(s: string): number {

};","(define/contract (min-length s)
  (-> string? exact-integer?)

  )","-spec min_length(S :: unicode:unicode_binary()) -> integer().
min_length(S) ->
  .","defmodule Solution do
  @spec min_length(s :: String.t) :: integer
  def min_length(s) do

  end
end","class Solution {
  int minLength(String s) {

  }
}",
maximum-number-of-moves-in-a-grid,Maximum Number of Moves in a Grid,2684.0,2794.0,"<p>You are given a <strong>0-indexed</strong> <code>m x n</code> matrix <code>grid</code> consisting of <strong>positive</strong> integers.</p>

<p>You can start at <strong>any</strong> cell in the first column of the matrix, and traverse the grid in the following way:</p>

<ul>
	<li>From a cell <code>(row, col)</code>, you can move to any of the cells: <code>(row - 1, col + 1)</code>, <code>(row, col + 1)</code> and <code>(row + 1, col + 1)</code> such that the value of the cell you move to, should be <strong>strictly</strong> bigger than the value of the current cell.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of <strong>moves</strong> that you can perform.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/04/11/yetgriddrawio-10.png"" style=""width: 201px; height: 201px;"" />
<pre>
<strong>Input:</strong> grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can start at the cell (0, 0) and make the following moves:
- (0, 0) -&gt; (0, 1).
- (0, 1) -&gt; (1, 2).
- (1, 2) -&gt; (2, 3).
It can be shown that it is the maximum number of moves that can be made.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/04/12/yetgrid4drawio.png"" />
<strong>Input:</strong> grid = [[3,2,4],[2,1,9],[1,1,7]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Starting from any cell in the first column we cannot perform any moves.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int maxMoves(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int maxMoves(int[][] grid) {
        
    }
}","class Solution(object):
    def maxMoves(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        ","int maxMoves(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int MaxMoves(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var maxMoves = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def max_moves(grid)
    
end","class Solution {
    func maxMoves(_ grid: [[Int]]) -> Int {
        
    }
}","func maxMoves(grid [][]int) int {
    
}","object Solution {
    def maxMoves(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun maxMoves(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn max_moves(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function maxMoves($grid) {
        
    }
}","function maxMoves(grid: number[][]): number {

};","(define/contract (max-moves grid)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec max_moves(Grid :: [[integer()]]) -> integer().
max_moves(Grid) ->
  .","defmodule Solution do
  @spec max_moves(grid :: [[integer]]) :: integer
  def max_moves(grid) do

  end
end","class Solution {
  int maxMoves(List<List<int>> grid) {

  }
}",
count-the-number-of-complete-components,Count the Number of Complete Components,2685.0,2793.0,"<p>You are given an integer <code>n</code>. There is an <strong>undirected</strong> graph with <code>n</code> vertices, numbered from <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>Return <em>the number of <strong>complete connected components</strong> of the graph</em>.</p>

<p>A <strong>connected component</strong> is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.</p>

<p>A connected component is said to be <b>complete</b> if there exists an edge between every pair of its vertices.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<p><strong class=""example""><img alt="""" src=""https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-31-23.png"" style=""width: 671px; height: 270px;"" /></strong></p>

<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> From the picture above, one can see that all of the components of this graph are complete.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<p><strong class=""example""><img alt="""" src=""https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-32-00.png"" style=""width: 671px; height: 270px;"" /></strong></p>

<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The component containing vertices 0, 1, and 2 is complete since there is an edge between every pair of two vertices. On the other hand, the component containing vertices 3, 4, and 5 is not complete since there is no edge between vertices 4 and 5. Thus, the number of complete components in this graph is 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>0 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
</ul>
",2.0,False,"class Solution {
public:
    int countCompleteComponents(int n, vector<vector<int>>& edges) {
        
    }
};","class Solution {
    public int countCompleteComponents(int n, int[][] edges) {
        
    }
}","class Solution(object):
    def countCompleteComponents(self, n, edges):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        ","int countCompleteComponents(int n, int** edges, int edgesSize, int* edgesColSize){

}","public class Solution {
    public int CountCompleteComponents(int n, int[][] edges) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number}
 */
var countCompleteComponents = function(n, edges) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @return {Integer}
def count_complete_components(n, edges)
    
end","class Solution {
    func countCompleteComponents(_ n: Int, _ edges: [[Int]]) -> Int {
        
    }
}","func countCompleteComponents(n int, edges [][]int) int {
    
}","object Solution {
    def countCompleteComponents(n: Int, edges: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun countCompleteComponents(n: Int, edges: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn count_complete_components(n: i32, edges: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @return Integer
     */
    function countCompleteComponents($n, $edges) {
        
    }
}","function countCompleteComponents(n: number, edges: number[][]): number {

};","(define/contract (count-complete-components n edges)
  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)

  )","-spec count_complete_components(N :: integer(), Edges :: [[integer()]]) -> integer().
count_complete_components(N, Edges) ->
  .","defmodule Solution do
  @spec count_complete_components(n :: integer, edges :: [[integer]]) :: integer
  def count_complete_components(n, edges) do

  end
end","class Solution {
  int countCompleteComponents(int n, List<List<int>> edges) {

  }
}",
neighboring-bitwise-xor,Neighboring Bitwise XOR,2683.0,2792.0,"<p>A <strong>0-indexed</strong> array <code>derived</code> with length <code>n</code> is derived by computing the <strong>bitwise XOR</strong>&nbsp;(&oplus;) of adjacent values in a <strong>binary array</strong> <code>original</code> of length <code>n</code>.</p>

<p>Specifically, for each index <code>i</code> in the range <code>[0, n - 1]</code>:</p>

<ul>
	<li>If <code>i = n - 1</code>, then <code>derived[i] = original[i] &oplus; original[0]</code>.</li>
	<li>Otherwise, <code>derived[i] = original[i] &oplus; original[i + 1]</code>.</li>
</ul>

<p>Given an array <code>derived</code>, your task is to determine whether there exists a <strong>valid binary array</strong> <code>original</code> that could have formed <code>derived</code>.</p>

<p>Return <em><strong>true</strong> if such an array exists or <strong>false</strong> otherwise.</em></p>

<ul>
	<li>A binary array is an array containing only <strong>0&#39;s</strong> and <strong>1&#39;s</strong></li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> derived = [1,1,0]
<strong>Output:</strong> true
<strong>Explanation:</strong> A valid original array that gives derived is [0,1,0].
derived[0] = original[0] &oplus; original[1] = 0 &oplus; 1 = 1 
derived[1] = original[1] &oplus; original[2] = 1 &oplus; 0 = 1
derived[2] = original[2] &oplus; original[0] = 0 &oplus; 0 = 0
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> derived = [1,1]
<strong>Output:</strong> true
<strong>Explanation:</strong> A valid original array that gives derived is [0,1].
derived[0] = original[0] &oplus; original[1] = 1
derived[1] = original[1] &oplus; original[0] = 1
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> derived = [1,0]
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no valid original array that gives derived.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == derived.length</code></li>
	<li><code>1 &lt;= n&nbsp;&lt;= 10<sup>5</sup></code></li>
	<li>The values in <code>derived</code>&nbsp;are either <strong>0&#39;s</strong> or <strong>1&#39;s</strong></li>
</ul>
",2.0,False,"class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        
    }
};","class Solution {
    public boolean doesValidArrayExist(int[] derived) {
        
    }
}","class Solution(object):
    def doesValidArrayExist(self, derived):
        """"""
        :type derived: List[int]
        :rtype: bool
        """"""
        ","class Solution:
    def doesValidArrayExist(self, derived: List[int]) -> bool:
        ","bool doesValidArrayExist(int* derived, int derivedSize){

}","public class Solution {
    public bool DoesValidArrayExist(int[] derived) {
        
    }
}","/**
 * @param {number[]} derived
 * @return {boolean}
 */
var doesValidArrayExist = function(derived) {
    
};","# @param {Integer[]} derived
# @return {Boolean}
def does_valid_array_exist(derived)
    
end","class Solution {
    func doesValidArrayExist(_ derived: [Int]) -> Bool {
        
    }
}","func doesValidArrayExist(derived []int) bool {
    
}","object Solution {
    def doesValidArrayExist(derived: Array[Int]): Boolean = {
        
    }
}","class Solution {
    fun doesValidArrayExist(derived: IntArray): Boolean {
        
    }
}","impl Solution {
    pub fn does_valid_array_exist(derived: Vec<i32>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $derived
     * @return Boolean
     */
    function doesValidArrayExist($derived) {
        
    }
}","function doesValidArrayExist(derived: number[]): boolean {

};","(define/contract (does-valid-array-exist derived)
  (-> (listof exact-integer?) boolean?)

  )","-spec does_valid_array_exist(Derived :: [integer()]) -> boolean().
does_valid_array_exist(Derived) ->
  .","defmodule Solution do
  @spec does_valid_array_exist(derived :: [integer]) :: boolean
  def does_valid_array_exist(derived) do

  end
end","class Solution {
  bool doesValidArrayExist(List<int> derived) {

  }
}",
find-the-losers-of-the-circular-game,Find the Losers of the Circular Game,2682.0,2791.0,"<p>There are <code>n</code> friends that are playing a game. The friends are sitting in a circle and are numbered from <code>1</code> to <code>n</code> in <strong>clockwise order</strong>. More formally, moving clockwise from the <code>i<sup>th</sup></code> friend brings you to the <code>(i+1)<sup>th</sup></code> friend for <code>1 &lt;= i &lt; n</code>, and moving clockwise from the <code>n<sup>th</sup></code> friend brings you to the <code>1<sup>st</sup></code> friend.</p>

<p>The rules of the game are as follows:</p>

<p><code>1<sup>st</sup></code> friend receives the ball.</p>

<ul>
	<li>After that, <code>1<sup>st</sup></code> friend passes it to the friend who is <code>k</code> steps away from them in the <strong>clockwise</strong> direction.</li>
	<li>After that, the friend who receives the ball should pass it to the friend who is <code>2 * k</code> steps away from them in the <strong>clockwise</strong> direction.</li>
	<li>After that, the friend who receives the ball should pass it to the friend who is <code>3 * k</code> steps away from them in the <strong>clockwise</strong> direction, and so on and so forth.</li>
</ul>

<p>In other words, on the <code>i<sup>th</sup></code> turn, the friend holding the ball should pass it to the friend who is <code>i * k</code> steps away from them in the <strong>clockwise</strong> direction.</p>

<p>The game is finished when some friend receives the ball for the second time.</p>

<p>The <strong>losers</strong> of the game are friends who did not receive the ball in the entire game.</p>

<p>Given the number of friends, <code>n</code>, and an integer <code>k</code>, return <em>the array answer, which contains the losers of the game in the <strong>ascending</strong> order</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 5, k = 2
<strong>Output:</strong> [4,5]
<strong>Explanation:</strong> The game goes as follows:
1) Start at 1<sup>st</sup>&nbsp;friend and pass the ball to the friend who is 2 steps away from them - 3<sup>rd</sup>&nbsp;friend.
2) 3<sup>rd</sup>&nbsp;friend passes the ball to the friend who is 4 steps away from them - 2<sup>nd</sup>&nbsp;friend.
3) 2<sup>nd</sup>&nbsp;friend passes the ball to the friend who is 6 steps away from them  - 3<sup>rd</sup>&nbsp;friend.
4) The game ends as 3<sup>rd</sup>&nbsp;friend receives the ball for the second time.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 4, k = 4
<strong>Output:</strong> [2,3,4]
<strong>Explanation:</strong> The game goes as follows:
1) Start at the 1<sup>st</sup>&nbsp;friend and pass the ball to the friend who is 4 steps away from them - 1<sup>st</sup>&nbsp;friend.
2) The game ends as 1<sup>st</sup>&nbsp;friend receives the ball for the second time.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= n &lt;= 50</code></li>
</ul>
",1.0,False,"class Solution {
public:
    vector<int> circularGameLosers(int n, int k) {
        
    }
};","class Solution {
    public int[] circularGameLosers(int n, int k) {
        
    }
}","class Solution(object):
    def circularGameLosers(self, n, k):
        """"""
        :type n: int
        :type k: int
        :rtype: List[int]
        """"""
        ","class Solution:
    def circularGameLosers(self, n: int, k: int) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* circularGameLosers(int n, int k, int* returnSize){

}","public class Solution {
    public int[] CircularGameLosers(int n, int k) {
        
    }
}","/**
 * @param {number} n
 * @param {number} k
 * @return {number[]}
 */
var circularGameLosers = function(n, k) {
    
};","# @param {Integer} n
# @param {Integer} k
# @return {Integer[]}
def circular_game_losers(n, k)
    
end","class Solution {
    func circularGameLosers(_ n: Int, _ k: Int) -> [Int] {
        
    }
}","func circularGameLosers(n int, k int) []int {
    
}","object Solution {
    def circularGameLosers(n: Int, k: Int): Array[Int] = {
        
    }
}","class Solution {
    fun circularGameLosers(n: Int, k: Int): IntArray {
        
    }
}","impl Solution {
    pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $k
     * @return Integer[]
     */
    function circularGameLosers($n, $k) {
        
    }
}","function circularGameLosers(n: number, k: number): number[] {

};","(define/contract (circular-game-losers n k)
  (-> exact-integer? exact-integer? (listof exact-integer?))

  )","-spec circular_game_losers(N :: integer(), K :: integer()) -> [integer()].
circular_game_losers(N, K) ->
  .","defmodule Solution do
  @spec circular_game_losers(n :: integer, k :: integer) :: [integer]
  def circular_game_losers(n, k) do

  end
end","class Solution {
  List<int> circularGameLosers(int n, int k) {

  }
}",
movement-of-robots,Movement of Robots,2731.0,2787.0,"<p>Some robots are standing on an infinite number line with their initial coordinates given by a <strong>0-indexed</strong> integer array <code>nums</code> and will start moving once given the command to move. The robots will move a unit distance each second.</p>

<p>You are given a string <code>s</code> denoting the direction in which robots will move on command. <code>&#39;L&#39;</code> means the robot will move towards the left side or negative side of the number line, whereas <code>&#39;R&#39;</code> means the robot will move towards the right side or positive side of the number line.</p>

<p>If two robots collide, they will start moving in opposite directions.</p>

<p>Return <em>the sum of distances between all the&nbsp;pairs of robots </em><code>d</code> <em>seconds after&nbsp;the command. </em>Since the sum can be very large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>

<p><b>Note: </b></p>

<ul>
	<li>For two robots at the index <code>i</code> and <code>j</code>, pair <code>(i,j)</code> and pair <code>(j,i)</code> are considered the same pair.</li>
	<li>When robots collide, they <strong>instantly change</strong> their directions without wasting any time.</li>
	<li>Collision happens&nbsp;when two robots share the same place in a&nbsp;moment.
	<ul>
		<li>For example, if a robot is positioned in 0 going to the right and another is positioned in 2 going to the left, the next second they&#39;ll be both in 1 and they will change direction and the next second the first one will be in 0, heading left, and another will be in 2, heading right.</li>
		<li>For example,&nbsp;if a robot is positioned in 0 going to the right and another is positioned in 1&nbsp;going to the left, the next second the first one will be in 0, heading left, and another will be in 1, heading right.</li>
	</ul>
	</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-2,0,2], s = &quot;RLL&quot;, d = 3
<strong>Output:</strong> 8
<strong>Explanation:</strong> 
After 1 second, the positions are [-1,-1,1]. Now, the robot at index 0 will move left, and the robot at index 1 will move right.
After 2 seconds, the positions are [-2,0,0]. Now, the robot at index 1 will move left, and the robot at index 2 will move right.
After 3 seconds, the positions are [-3,-1,1].
The distance between the robot at index 0 and 1 is abs(-3 - (-1)) = 2.
The distance between the robot at index 0 and 2 is abs(-3 - 1) = 4.
The distance between the robot at index 1 and 2 is abs(-1 - 1) = 2.
The sum of the pairs of all distances = 2 + 4 + 2 = 8.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,0], s = &quot;RL&quot;, d = 2
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
After 1 second, the positions are [2,-1].
After 2 seconds, the positions are [3,-2].
The distance between the two robots is abs(-2 - 3) = 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-2 * 10<sup>9</sup>&nbsp;&lt;= nums[i] &lt;= 2 * 10<sup>9</sup></code></li>
	<li><code>0 &lt;= d &lt;= 10<sup>9</sup></code></li>
	<li><code>nums.length == s.length&nbsp;</code></li>
	<li><code>s</code> consists of &#39;L&#39; and &#39;R&#39; only</li>
	<li><code>nums[i]</code>&nbsp;will be unique.</li>
</ul>
",2.0,False,"class Solution {
public:
    int sumDistance(vector<int>& nums, string s, int d) {
        
    }
};","class Solution {
    public int sumDistance(int[] nums, String s, int d) {
        
    }
}","class Solution(object):
    def sumDistance(self, nums, s, d):
        """"""
        :type nums: List[int]
        :type s: str
        :type d: int
        :rtype: int
        """"""
        ","class Solution:
    def sumDistance(self, nums: List[int], s: str, d: int) -> int:
        ","int sumDistance(int* nums, int numsSize, char * s, int d){

}","public class Solution {
    public int SumDistance(int[] nums, string s, int d) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {string} s
 * @param {number} d
 * @return {number}
 */
var sumDistance = function(nums, s, d) {
    
};","# @param {Integer[]} nums
# @param {String} s
# @param {Integer} d
# @return {Integer}
def sum_distance(nums, s, d)
    
end","class Solution {
    func sumDistance(_ nums: [Int], _ s: String, _ d: Int) -> Int {
        
    }
}","func sumDistance(nums []int, s string, d int) int {
    
}","object Solution {
    def sumDistance(nums: Array[Int], s: String, d: Int): Int = {
        
    }
}","class Solution {
    fun sumDistance(nums: IntArray, s: String, d: Int): Int {
        
    }
}","impl Solution {
    pub fn sum_distance(nums: Vec<i32>, s: String, d: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param String $s
     * @param Integer $d
     * @return Integer
     */
    function sumDistance($nums, $s, $d) {
        
    }
}","function sumDistance(nums: number[], s: string, d: number): number {

};","(define/contract (sum-distance nums s d)
  (-> (listof exact-integer?) string? exact-integer? exact-integer?)

  )","-spec sum_distance(Nums :: [integer()], S :: unicode:unicode_binary(), D :: integer()) -> integer().
sum_distance(Nums, S, D) ->
  .","defmodule Solution do
  @spec sum_distance(nums :: [integer], s :: String.t, d :: integer) :: integer
  def sum_distance(nums, s, d) do

  end
end","class Solution {
  int sumDistance(List<int> nums, String s, int d) {

  }
}",
find-the-longest-semi-repetitive-substring,Find the Longest Semi-Repetitive Substring,2730.0,2786.0,"<p>You are given a <strong>0-indexed</strong> string <code>s</code> that consists of digits from <code>0</code> to <code>9</code>.</p>

<p>A string <code>t</code> is called a <strong>semi-repetitive</strong> if there is at most one consecutive pair of the same digits inside <code>t</code>. For example, <code>0010</code>, <code>002020</code>, <code>0123</code>, <code>2002</code>, and <code>54944</code> are semi-repetitive while&nbsp;<code>00101022</code>, and <code>1101234883</code> are not.</p>

<p>Return <em>the length of the longest semi-repetitive substring inside</em> <code>s</code>.</p>

<p>A <b>substring</b> is a contiguous <strong>non-empty</strong> sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;52233&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest semi-repetitive substring is &quot;5223&quot;, which starts at i = 0 and ends at j = 3. 
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;5494&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> s is a semi-reptitive string, so the answer is 4.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;1111111&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest semi-repetitive substring is &quot;11&quot;, which starts at i = 0 and ends at j = 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 50</code></li>
	<li><code>&#39;0&#39; &lt;= s[i] &lt;= &#39;9&#39;</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int longestSemiRepetitiveSubstring(string s) {
        
    }
};","class Solution {
    public int longestSemiRepetitiveSubstring(String s) {
        
    }
}","class Solution(object):
    def longestSemiRepetitiveSubstring(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def longestSemiRepetitiveSubstring(self, s: str) -> int:
        ","int longestSemiRepetitiveSubstring(char * s){

}","public class Solution {
    public int LongestSemiRepetitiveSubstring(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var longestSemiRepetitiveSubstring = function(s) {
    
};","# @param {String} s
# @return {Integer}
def longest_semi_repetitive_substring(s)
    
end","class Solution {
    func longestSemiRepetitiveSubstring(_ s: String) -> Int {
        
    }
}","func longestSemiRepetitiveSubstring(s string) int {
    
}","object Solution {
    def longestSemiRepetitiveSubstring(s: String): Int = {
        
    }
}","class Solution {
    fun longestSemiRepetitiveSubstring(s: String): Int {
        
    }
}","impl Solution {
    pub fn longest_semi_repetitive_substring(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function longestSemiRepetitiveSubstring($s) {
        
    }
}","function longestSemiRepetitiveSubstring(s: string): number {

};","(define/contract (longest-semi-repetitive-substring s)
  (-> string? exact-integer?)

  )","-spec longest_semi_repetitive_substring(S :: unicode:unicode_binary()) -> integer().
longest_semi_repetitive_substring(S) ->
  .","defmodule Solution do
  @spec longest_semi_repetitive_substring(s :: String.t) :: integer
  def longest_semi_repetitive_substring(s) do

  end
end","class Solution {
  int longestSemiRepetitiveSubstring(String s) {

  }
}",
semi-ordered-permutation,Semi-Ordered Permutation,2717.0,2785.0,"<p>You are given a <strong>0-indexed</strong> permutation of <code>n</code> integers <code>nums</code>.</p>

<p>A permutation is called <strong>semi-ordered</strong> if the first number equals <code>1</code> and the last number equals <code>n</code>. You can perform the below operation as many times as you want until you make <code>nums</code> a <strong>semi-ordered</strong> permutation:</p>

<ul>
	<li>Pick two adjacent elements in <code>nums</code>, then swap them.</li>
</ul>

<p>Return <em>the minimum number of operations to make </em><code>nums</code><em> a <strong>semi-ordered permutation</strong></em>.</p>

<p>A <strong>permutation</strong> is a sequence of integers from <code>1</code> to <code>n</code> of length <code>n</code> containing each number exactly once.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,4,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can make the permutation semi-ordered using these sequence of operations: 
1 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].
2 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].
It can be proved that there is no sequence of less than two operations that make nums a semi-ordered permutation. 
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,1,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can make the permutation semi-ordered using these sequence of operations:
1 - swap i = 1 and j = 2. The permutation becomes [2,1,4,3].
2 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].
3 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].
It can be proved that there is no sequence of less than three operations that make nums a semi-ordered permutation.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,4,2,5]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The permutation is already a semi-ordered permutation.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length == n &lt;= 50</code></li>
	<li><code>1 &lt;= nums[i]&nbsp;&lt;= 50</code></li>
	<li><code>nums is a permutation.</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int semiOrderedPermutation(vector<int>& nums) {
        
    }
};","class Solution {
    public int semiOrderedPermutation(int[] nums) {
        
    }
}","class Solution(object):
    def semiOrderedPermutation(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def semiOrderedPermutation(self, nums: List[int]) -> int:
        ","int semiOrderedPermutation(int* nums, int numsSize){

}","public class Solution {
    public int SemiOrderedPermutation(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var semiOrderedPermutation = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def semi_ordered_permutation(nums)
    
end","class Solution {
    func semiOrderedPermutation(_ nums: [Int]) -> Int {
        
    }
}","func semiOrderedPermutation(nums []int) int {
    
}","object Solution {
    def semiOrderedPermutation(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun semiOrderedPermutation(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn semi_ordered_permutation(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function semiOrderedPermutation($nums) {
        
    }
}","function semiOrderedPermutation(nums: number[]): number {

};","(define/contract (semi-ordered-permutation nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec semi_ordered_permutation(Nums :: [integer()]) -> integer().
semi_ordered_permutation(Nums) ->
  .","defmodule Solution do
  @spec semi_ordered_permutation(nums :: [integer]) :: integer
  def semi_ordered_permutation(nums) do

  end
end","class Solution {
  int semiOrderedPermutation(List<int> nums) {

  }
}",
power-of-heroes,Power of Heroes,2681.0,2784.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> representing the strength of some heroes. The<b> power</b> of a group of heroes is defined as follows:</p>

<ul>
	<li>Let <code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, ... ,<code>i<sub>k</sub></code> be the indices of the heroes in a group. Then, the power of this group is <code>max(nums[i<sub>0</sub>], nums[i<sub>1</sub>], ... ,nums[i<sub>k</sub>])<sup>2</sup> * min(nums[i<sub>0</sub>], nums[i<sub>1</sub>], ... ,nums[i<sub>k</sub>])</code>.</li>
</ul>

<p>Return <em>the sum of the <strong>power</strong> of all <strong>non-empty</strong> groups of heroes possible.</em> Since the sum could be very large, return it <strong>modulo</strong> <code>10<sup>9 </sup>+ 7</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,4]
<strong>Output:</strong> 141
<strong>Explanation:</strong> 
1<sup>st</sup>&nbsp;group: [2] has power = 2<sup>2</sup>&nbsp;* 2 = 8.
2<sup>nd</sup>&nbsp;group: [1] has power = 1<sup>2</sup> * 1 = 1. 
3<sup>rd</sup>&nbsp;group: [4] has power = 4<sup>2</sup> * 4 = 64. 
4<sup>th</sup>&nbsp;group: [2,1] has power = 2<sup>2</sup> * 1 = 4. 
5<sup>th</sup>&nbsp;group: [2,4] has power = 4<sup>2</sup> * 2 = 32. 
6<sup>th</sup>&nbsp;group: [1,4] has power = 4<sup>2</sup> * 1 = 16. 
​​​​​​​7<sup>th</sup>&nbsp;group: [2,1,4] has power = 4<sup>2</sup>​​​​​​​ * 1 = 16. 
The sum of powers of all groups is 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141.

</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1]
<strong>Output:</strong> 7
<strong>Explanation:</strong> A total of 7 groups are possible, and the power of each group will be 1. Therefore, the sum of the powers of all groups is 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    int sumOfPower(vector<int>& nums) {
        
    }
};","class Solution {
    public int sumOfPower(int[] nums) {
        
    }
}","class Solution(object):
    def sumOfPower(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def sumOfPower(self, nums: List[int]) -> int:
        ","int sumOfPower(int* nums, int numsSize){

}","public class Solution {
    public int SumOfPower(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var sumOfPower = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def sum_of_power(nums)
    
end","class Solution {
    func sumOfPower(_ nums: [Int]) -> Int {
        
    }
}","func sumOfPower(nums []int) int {
    
}","object Solution {
    def sumOfPower(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun sumOfPower(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn sum_of_power(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function sumOfPower($nums) {
        
    }
}","function sumOfPower(nums: number[]): number {

};","(define/contract (sum-of-power nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec sum_of_power(Nums :: [integer()]) -> integer().
sum_of_power(Nums) ->
  .","defmodule Solution do
  @spec sum_of_power(nums :: [integer]) :: integer
  def sum_of_power(nums) do

  end
end","class Solution {
  int sumOfPower(List<int> nums) {

  }
}",
make-costs-of-paths-equal-in-a-binary-tree,Make Costs of Paths Equal in a Binary Tree,2673.0,2780.0,"<p>You are given an integer <code>n</code> representing the number of nodes in a <strong>perfect binary tree</strong> consisting of nodes numbered from <code>1</code> to <code>n</code>. The root of the tree is node <code>1</code> and each node <code>i</code> in the tree has two children where the left child is the node <code>2 * i</code> and the right child is <code>2 * i + 1</code>.</p>

<p>Each node in the tree also has a <strong>cost</strong> represented by a given <strong>0-indexed</strong> integer array <code>cost</code> of size <code>n</code> where <code>cost[i]</code> is the cost of node <code>i + 1</code>. You are allowed to <strong>increment</strong> the cost of <strong>any</strong> node by <code>1</code> <strong>any</strong> number of times.</p>

<p>Return <em>the <strong>minimum</strong> number of increments you need to make the cost of paths from the root to each <strong>leaf</strong> node equal</em>.</p>

<p><strong>Note</strong>:</p>

<ul>
	<li>A <strong>perfect binary tree </strong>is a tree where each node, except the leaf nodes, has exactly 2 children.</li>
	<li>The <strong>cost of a path</strong> is the sum of costs of nodes in the path.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/04/04/binaryytreeedrawio-4.png"" />
<pre>
<strong>Input:</strong> n = 7, cost = [1,5,2,2,3,3,1]
<strong>Output:</strong> 6
<strong>Explanation:</strong> We can do the following increments:
- Increase the cost of node 4 one time.
- Increase the cost of node 3 three times.
- Increase the cost of node 7 two times.
Each path from the root to a leaf will have a total cost of 9.
The total increments we did is 1 + 3 + 2 = 6.
It can be shown that this is the minimum answer we can achieve.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/04/04/binaryytreee2drawio.png"" style=""width: 205px; height: 151px;"" />
<pre>
<strong>Input:</strong> n = 3, cost = [5,3,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The two paths already have equal total costs, so no increments are needed.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>n + 1</code> is a power of <code>2</code></li>
	<li><code>cost.length == n</code></li>
	<li><code>1 &lt;= cost[i] &lt;= 10<sup>4</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int minIncrements(int n, vector<int>& cost) {
        
    }
};","class Solution {
    public int minIncrements(int n, int[] cost) {
        
    }
}","class Solution(object):
    def minIncrements(self, n, cost):
        """"""
        :type n: int
        :type cost: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:
        ","int minIncrements(int n, int* cost, int costSize){

}","public class Solution {
    public int MinIncrements(int n, int[] cost) {
        
    }
}","/**
 * @param {number} n
 * @param {number[]} cost
 * @return {number}
 */
var minIncrements = function(n, cost) {
    
};","# @param {Integer} n
# @param {Integer[]} cost
# @return {Integer}
def min_increments(n, cost)
    
end","class Solution {
    func minIncrements(_ n: Int, _ cost: [Int]) -> Int {
        
    }
}","func minIncrements(n int, cost []int) int {
    
}","object Solution {
    def minIncrements(n: Int, cost: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minIncrements(n: Int, cost: IntArray): Int {
        
    }
}","impl Solution {
    pub fn min_increments(n: i32, cost: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[] $cost
     * @return Integer
     */
    function minIncrements($n, $cost) {
        
    }
}","function minIncrements(n: number, cost: number[]): number {

};","(define/contract (min-increments n cost)
  (-> exact-integer? (listof exact-integer?) exact-integer?)

  )","-spec min_increments(N :: integer(), Cost :: [integer()]) -> integer().
min_increments(N, Cost) ->
  .","defmodule Solution do
  @spec min_increments(n :: integer, cost :: [integer]) :: integer
  def min_increments(n, cost) do

  end
end","class Solution {
  int minIncrements(int n, List<int> cost) {

  }
}",
number-of-adjacent-elements-with-the-same-color,Number of Adjacent Elements With the Same Color,2672.0,2779.0,"<p>There is a <strong>0-indexed</strong> array <code>nums</code> of length <code>n</code>. Initially, all elements are <strong>uncolored </strong>(has a value of <code>0</code>).</p>

<p>You are given a 2D integer array <code>queries</code> where <code>queries[i] = [index<sub>i</sub>, color<sub>i</sub>]</code>.</p>

<p>For each query, you color the index <code>index<sub>i</sub></code> with the color <code>color<sub>i</sub></code> in the array <code>nums</code>.</p>

<p>Return <em>an array </em><code>answer</code><em> of the same length as </em><code>queries</code><em> where </em><code>answer[i]</code><em> is the number of adjacent elements with the same color <strong>after</strong> the </em><code>i<sup>th</sup></code><em> query</em>.</p>

<p>More formally, <code>answer[i]</code> is the number of indices <code>j</code>, such that <code>0 &lt;= j &lt; n - 1</code> and <code>nums[j] == nums[j + 1]</code> and <code>nums[j] != 0</code> after the <code>i<sup>th</sup></code> query.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]
<strong>Output:</strong> [0,1,1,0,2]
<strong>Explanation:</strong> Initially array nums = [0,0,0,0], where 0 denotes uncolored elements of the array.
- After the 1<sup>st</sup> query nums = [2,0,0,0]. The count of adjacent elements with the same color is 0.
- After the 2<sup>nd</sup> query nums = [2,2,0,0]. The count of adjacent elements with the same color is 1.
- After the 3<sup>rd</sup>&nbsp;query nums = [2,2,0,1]. The count of adjacent elements with the same color is 1.
- After the 4<sup>th</sup>&nbsp;query nums = [2,1,0,1]. The count of adjacent elements with the same color is 0.
- After the 5<sup>th</sup>&nbsp;query nums = [2,1,1,1]. The count of adjacent elements with the same color is 2.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1, queries = [[0,100000]]
<strong>Output:</strong> [0]
<strong>Explanation:</strong> Initially array nums = [0], where 0 denotes uncolored elements of the array.
- After the 1<sup>st</sup> query nums = [100000]. The count of adjacent elements with the same color is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length&nbsp;== 2</code></li>
	<li><code>0 &lt;= index<sub>i</sub>&nbsp;&lt;= n - 1</code></li>
	<li><code>1 &lt;=&nbsp; color<sub>i</sub>&nbsp;&lt;= 10<sup>5</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {
        
    }
};","class Solution {
    public int[] colorTheArray(int n, int[][] queries) {
        
    }
}","class Solution(object):
    def colorTheArray(self, n, queries):
        """"""
        :type n: int
        :type queries: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* colorTheArray(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize){

}","public class Solution {
    public int[] ColorTheArray(int n, int[][] queries) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} queries
 * @return {number[]}
 */
var colorTheArray = function(n, queries) {
    
};","# @param {Integer} n
# @param {Integer[][]} queries
# @return {Integer[]}
def color_the_array(n, queries)
    
end","class Solution {
    func colorTheArray(_ n: Int, _ queries: [[Int]]) -> [Int] {
        
    }
}","func colorTheArray(n int, queries [][]int) []int {
    
}","object Solution {
    def colorTheArray(n: Int, queries: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun colorTheArray(n: Int, queries: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $queries
     * @return Integer[]
     */
    function colorTheArray($n, $queries) {
        
    }
}","function colorTheArray(n: number, queries: number[][]): number[] {

};","(define/contract (color-the-array n queries)
  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec color_the_array(N :: integer(), Queries :: [[integer()]]) -> [integer()].
color_the_array(N, Queries) ->
  .","defmodule Solution do
  @spec color_the_array(n :: integer, queries :: [[integer]]) :: [integer]
  def color_the_array(n, queries) do

  end
end","class Solution {
  List<int> colorTheArray(int n, List<List<int>> queries) {

  }
}",
frequency-tracker,Frequency Tracker,2671.0,2778.0,"<p>Design a data structure that keeps track of the values in it and answers some queries regarding their frequencies.</p>

<p>Implement the <code>FrequencyTracker</code> class.</p>

<ul>
	<li><code>FrequencyTracker()</code>: Initializes the <code>FrequencyTracker</code> object with an empty array initially.</li>
	<li><code>void add(int number)</code>: Adds <code>number</code> to the data structure.</li>
	<li><code>void deleteOne(int number)</code>: Deletes <strong>one</strong> occurrence of <code>number</code> from the data structure. The data structure <strong>may not contain</strong> <code>number</code>, and in this case nothing is deleted.</li>
	<li><code>bool hasFrequency(int frequency)</code>: Returns <code>true</code> if there is a number in the data structure that occurs <code>frequency</code> number of times, otherwise, it returns <code>false</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;FrequencyTracker&quot;, &quot;add&quot;, &quot;add&quot;, &quot;hasFrequency&quot;]
[[], [3], [3], [2]]
<strong>Output</strong>
[null, null, null, true]

<strong>Explanation</strong>
FrequencyTracker frequencyTracker = new FrequencyTracker();
frequencyTracker.add(3); // The data structure now contains [3]
frequencyTracker.add(3); // The data structure now contains [3, 3]
frequencyTracker.hasFrequency(2); // Returns true, because 3 occurs twice

</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input</strong>
[&quot;FrequencyTracker&quot;, &quot;add&quot;, &quot;deleteOne&quot;, &quot;hasFrequency&quot;]
[[], [1], [1], [1]]
<strong>Output</strong>
[null, null, null, false]

<strong>Explanation</strong>
FrequencyTracker frequencyTracker = new FrequencyTracker();
frequencyTracker.add(1); // The data structure now contains [1]
frequencyTracker.deleteOne(1); // The data structure becomes empty []
frequencyTracker.hasFrequency(1); // Returns false, because the data structure is empty

</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input</strong>
[&quot;FrequencyTracker&quot;, &quot;hasFrequency&quot;, &quot;add&quot;, &quot;hasFrequency&quot;]
[[], [2], [3], [1]]
<strong>Output</strong>
[null, false, null, true]

<strong>Explanation</strong>
FrequencyTracker frequencyTracker = new FrequencyTracker();
frequencyTracker.hasFrequency(2); // Returns false, because the data structure is empty
frequencyTracker.add(3); // The data structure now contains [3]
frequencyTracker.hasFrequency(1); // Returns true, because 3 occurs once

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= number &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= frequency &lt;= 10<sup>5</sup></code></li>
	<li>At most, <code>2 *&nbsp;10<sup>5</sup></code>&nbsp;calls will be made to <code>add</code>, <code>deleteOne</code>, and <code>hasFrequency</code>&nbsp;in <strong>total</strong>.</li>
</ul>
",2.0,False,"class FrequencyTracker {
public:
    FrequencyTracker() {
        
    }
    
    void add(int number) {
        
    }
    
    void deleteOne(int number) {
        
    }
    
    bool hasFrequency(int frequency) {
        
    }
};

/**
 * Your FrequencyTracker object will be instantiated and called as such:
 * FrequencyTracker* obj = new FrequencyTracker();
 * obj->add(number);
 * obj->deleteOne(number);
 * bool param_3 = obj->hasFrequency(frequency);
 */","class FrequencyTracker {

    public FrequencyTracker() {
        
    }
    
    public void add(int number) {
        
    }
    
    public void deleteOne(int number) {
        
    }
    
    public boolean hasFrequency(int frequency) {
        
    }
}

/**
 * Your FrequencyTracker object will be instantiated and called as such:
 * FrequencyTracker obj = new FrequencyTracker();
 * obj.add(number);
 * obj.deleteOne(number);
 * boolean param_3 = obj.hasFrequency(frequency);
 */","class FrequencyTracker(object):

    def __init__(self):
        

    def add(self, number):
        """"""
        :type number: int
        :rtype: None
        """"""
        

    def deleteOne(self, number):
        """"""
        :type number: int
        :rtype: None
        """"""
        

    def hasFrequency(self, frequency):
        """"""
        :type frequency: int
        :rtype: bool
        """"""
        


# Your FrequencyTracker object will be instantiated and called as such:
# obj = FrequencyTracker()
# obj.add(number)
# obj.deleteOne(number)
# param_3 = obj.hasFrequency(frequency)","class FrequencyTracker:

    def __init__(self):
        

    def add(self, number: int) -> None:
        

    def deleteOne(self, number: int) -> None:
        

    def hasFrequency(self, frequency: int) -> bool:
        


# Your FrequencyTracker object will be instantiated and called as such:
# obj = FrequencyTracker()
# obj.add(number)
# obj.deleteOne(number)
# param_3 = obj.hasFrequency(frequency)","


typedef struct {
    
} FrequencyTracker;


FrequencyTracker* frequencyTrackerCreate() {
    
}

void frequencyTrackerAdd(FrequencyTracker* obj, int number) {
  
}

void frequencyTrackerDeleteOne(FrequencyTracker* obj, int number) {
  
}

bool frequencyTrackerHasFrequency(FrequencyTracker* obj, int frequency) {
  
}

void frequencyTrackerFree(FrequencyTracker* obj) {
    
}

/**
 * Your FrequencyTracker struct will be instantiated and called as such:
 * FrequencyTracker* obj = frequencyTrackerCreate();
 * frequencyTrackerAdd(obj, number);
 
 * frequencyTrackerDeleteOne(obj, number);
 
 * bool param_3 = frequencyTrackerHasFrequency(obj, frequency);
 
 * frequencyTrackerFree(obj);
*/","public class FrequencyTracker {

    public FrequencyTracker() {
        
    }
    
    public void Add(int number) {
        
    }
    
    public void DeleteOne(int number) {
        
    }
    
    public bool HasFrequency(int frequency) {
        
    }
}

/**
 * Your FrequencyTracker object will be instantiated and called as such:
 * FrequencyTracker obj = new FrequencyTracker();
 * obj.Add(number);
 * obj.DeleteOne(number);
 * bool param_3 = obj.HasFrequency(frequency);
 */","
var FrequencyTracker = function() {
    
};

/** 
 * @param {number} number
 * @return {void}
 */
FrequencyTracker.prototype.add = function(number) {
    
};

/** 
 * @param {number} number
 * @return {void}
 */
FrequencyTracker.prototype.deleteOne = function(number) {
    
};

/** 
 * @param {number} frequency
 * @return {boolean}
 */
FrequencyTracker.prototype.hasFrequency = function(frequency) {
    
};

/** 
 * Your FrequencyTracker object will be instantiated and called as such:
 * var obj = new FrequencyTracker()
 * obj.add(number)
 * obj.deleteOne(number)
 * var param_3 = obj.hasFrequency(frequency)
 */","class FrequencyTracker
    def initialize()
        
    end


=begin
    :type number: Integer
    :rtype: Void
=end
    def add(number)
        
    end


=begin
    :type number: Integer
    :rtype: Void
=end
    def delete_one(number)
        
    end


=begin
    :type frequency: Integer
    :rtype: Boolean
=end
    def has_frequency(frequency)
        
    end


end

# Your FrequencyTracker object will be instantiated and called as such:
# obj = FrequencyTracker.new()
# obj.add(number)
# obj.delete_one(number)
# param_3 = obj.has_frequency(frequency)","
class FrequencyTracker {

    init() {
        
    }
    
    func add(_ number: Int) {
        
    }
    
    func deleteOne(_ number: Int) {
        
    }
    
    func hasFrequency(_ frequency: Int) -> Bool {
        
    }
}

/**
 * Your FrequencyTracker object will be instantiated and called as such:
 * let obj = FrequencyTracker()
 * obj.add(number)
 * obj.deleteOne(number)
 * let ret_3: Bool = obj.hasFrequency(frequency)
 */","type FrequencyTracker struct {
    
}


func Constructor() FrequencyTracker {
    
}


func (this *FrequencyTracker) Add(number int)  {
    
}


func (this *FrequencyTracker) DeleteOne(number int)  {
    
}


func (this *FrequencyTracker) HasFrequency(frequency int) bool {
    
}


/**
 * Your FrequencyTracker object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Add(number);
 * obj.DeleteOne(number);
 * param_3 := obj.HasFrequency(frequency);
 */","class FrequencyTracker() {

    def add(number: Int) {
        
    }

    def deleteOne(number: Int) {
        
    }

    def hasFrequency(frequency: Int): Boolean = {
        
    }

}

/**
 * Your FrequencyTracker object will be instantiated and called as such:
 * var obj = new FrequencyTracker()
 * obj.add(number)
 * obj.deleteOne(number)
 * var param_3 = obj.hasFrequency(frequency)
 */","class FrequencyTracker() {

    fun add(number: Int) {
        
    }

    fun deleteOne(number: Int) {
        
    }

    fun hasFrequency(frequency: Int): Boolean {
        
    }

}

/**
 * Your FrequencyTracker object will be instantiated and called as such:
 * var obj = FrequencyTracker()
 * obj.add(number)
 * obj.deleteOne(number)
 * var param_3 = obj.hasFrequency(frequency)
 */","struct FrequencyTracker {

}


/** 
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl FrequencyTracker {

    fn new() -> Self {
        
    }
    
    fn add(&self, number: i32) {
        
    }
    
    fn delete_one(&self, number: i32) {
        
    }
    
    fn has_frequency(&self, frequency: i32) -> bool {
        
    }
}

/**
 * Your FrequencyTracker object will be instantiated and called as such:
 * let obj = FrequencyTracker::new();
 * obj.add(number);
 * obj.delete_one(number);
 * let ret_3: bool = obj.has_frequency(frequency);
 */","class FrequencyTracker {
    /**
     */
    function __construct() {
        
    }
  
    /**
     * @param Integer $number
     * @return NULL
     */
    function add($number) {
        
    }
  
    /**
     * @param Integer $number
     * @return NULL
     */
    function deleteOne($number) {
        
    }
  
    /**
     * @param Integer $frequency
     * @return Boolean
     */
    function hasFrequency($frequency) {
        
    }
}

/**
 * Your FrequencyTracker object will be instantiated and called as such:
 * $obj = FrequencyTracker();
 * $obj->add($number);
 * $obj->deleteOne($number);
 * $ret_3 = $obj->hasFrequency($frequency);
 */","class FrequencyTracker {
    constructor() {

    }

    add(number: number): void {

    }

    deleteOne(number: number): void {

    }

    hasFrequency(frequency: number): boolean {

    }
}

/**
 * Your FrequencyTracker object will be instantiated and called as such:
 * var obj = new FrequencyTracker()
 * obj.add(number)
 * obj.deleteOne(number)
 * var param_3 = obj.hasFrequency(frequency)
 */","(define frequency-tracker%
  (class object%
    (super-new)
    
    (init-field)
    
    ; add : exact-integer? -> void?
    (define/public (add number)

      )
    ; delete-one : exact-integer? -> void?
    (define/public (delete-one number)

      )
    ; has-frequency : exact-integer? -> boolean?
    (define/public (has-frequency frequency)

      )))

;; Your frequency-tracker% object will be instantiated and called as such:
;; (define obj (new frequency-tracker%))
;; (send obj add number)
;; (send obj delete-one number)
;; (define param_3 (send obj has-frequency frequency))","-spec frequency_tracker_init_() -> any().
frequency_tracker_init_() ->
  .

-spec frequency_tracker_add(Number :: integer()) -> any().
frequency_tracker_add(Number) ->
  .

-spec frequency_tracker_delete_one(Number :: integer()) -> any().
frequency_tracker_delete_one(Number) ->
  .

-spec frequency_tracker_has_frequency(Frequency :: integer()) -> boolean().
frequency_tracker_has_frequency(Frequency) ->
  .


%% Your functions will be called as such:
%% frequency_tracker_init_(),
%% frequency_tracker_add(Number),
%% frequency_tracker_delete_one(Number),
%% Param_3 = frequency_tracker_has_frequency(Frequency),

%% frequency_tracker_init_ will be called before every test case, in which you can do some necessary initializations.","defmodule FrequencyTracker do
  @spec init_() :: any
  def init_() do

  end

  @spec add(number :: integer) :: any
  def add(number) do

  end

  @spec delete_one(number :: integer) :: any
  def delete_one(number) do

  end

  @spec has_frequency(frequency :: integer) :: boolean
  def has_frequency(frequency) do

  end
end

# Your functions will be called as such:
# FrequencyTracker.init_()
# FrequencyTracker.add(number)
# FrequencyTracker.delete_one(number)
# param_3 = FrequencyTracker.has_frequency(frequency)

# FrequencyTracker.init_ will be called before every test case, in which you can do some necessary initializations.","class FrequencyTracker {

  FrequencyTracker() {

  }
  
  void add(int number) {

  }
  
  void deleteOne(int number) {

  }
  
  bool hasFrequency(int frequency) {

  }
}

/**
 * Your FrequencyTracker object will be instantiated and called as such:
 * FrequencyTracker obj = FrequencyTracker();
 * obj.add(number);
 * obj.deleteOne(number);
 * bool param3 = obj.hasFrequency(frequency);
 */",
find-the-distinct-difference-array,Find the Distinct Difference Array,2670.0,2777.0,"<p>You are given a <strong>0-indexed</strong> array <code>nums</code> of length <code>n</code>.</p>

<p>The <strong>distinct difference</strong> array of <code>nums</code> is an array <code>diff</code> of length <code>n</code> such that <code>diff[i]</code> is equal to the number of distinct elements in the suffix <code>nums[i + 1, ..., n - 1]</code> <strong>subtracted from</strong> the number of distinct elements in the prefix <code>nums[0, ..., i]</code>.</p>

<p>Return <em>the <strong>distinct difference</strong> array of </em><code>nums</code>.</p>

<p>Note that <code>nums[i, ..., j]</code> denotes the subarray of <code>nums</code> starting at index <code>i</code> and ending at index <code>j</code> inclusive. Particularly, if <code>i &gt; j</code> then <code>nums[i, ..., j]</code> denotes an empty subarray.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5]
<strong>Output:</strong> [-3,-1,1,3,5]
<strong>Explanation:</strong> For index i = 0, there is 1 element in the prefix and 4 distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.
For index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.
For index i = 2, there are 3 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 3 - 2 = 1.
For index i = 3, there are 4 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 4 - 1 = 3.
For index i = 4, there are 5 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,3,4,2]
<strong>Output:</strong> [-2,-1,0,2,3]
<strong>Explanation:</strong> For index i = 0, there is 1 element in the prefix and 3 distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.
For index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.
For index i = 2, there are 2 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 2 - 2 = 0.
For index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.
For index i = 4, there are 3 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length&nbsp;&lt;= 50</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 50</code></li>
</ul>
",1.0,False,"class Solution {
public:
    vector<int> distinctDifferenceArray(vector<int>& nums) {
        
    }
};","class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        
    }
}","class Solution(object):
    def distinctDifferenceArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* distinctDifferenceArray(int* nums, int numsSize, int* returnSize){

}","public class Solution {
    public int[] DistinctDifferenceArray(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number[]}
 */
var distinctDifferenceArray = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer[]}
def distinct_difference_array(nums)
    
end","class Solution {
    func distinctDifferenceArray(_ nums: [Int]) -> [Int] {
        
    }
}","func distinctDifferenceArray(nums []int) []int {
    
}","object Solution {
    def distinctDifferenceArray(nums: Array[Int]): Array[Int] = {
        
    }
}","class Solution {
    fun distinctDifferenceArray(nums: IntArray): IntArray {
        
    }
}","impl Solution {
    pub fn distinct_difference_array(nums: Vec<i32>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function distinctDifferenceArray($nums) {
        
    }
}","function distinctDifferenceArray(nums: number[]): number[] {

};","(define/contract (distinct-difference-array nums)
  (-> (listof exact-integer?) (listof exact-integer?))

  )","-spec distinct_difference_array(Nums :: [integer()]) -> [integer()].
distinct_difference_array(Nums) ->
  .","defmodule Solution do
  @spec distinct_difference_array(nums :: [integer]) :: [integer]
  def distinct_difference_array(nums) do

  end
end","class Solution {
  List<int> distinctDifferenceArray(List<int> nums) {

  }
}",
maximum-sum-with-exactly-k-elements,Maximum Sum With Exactly K Elements ,2656.0,2767.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>k</code>. Your task is to perform the following operation <strong>exactly</strong> <code>k</code> times in order to maximize your score:</p>

<ol>
	<li>Select an element <code>m</code> from <code>nums</code>.</li>
	<li>Remove the selected element <code>m</code> from the array.</li>
	<li>Add a new element with a value of <code>m + 1</code> to the array.</li>
	<li>Increase your score by <code>m</code>.</li>
</ol>

<p>Return <em>the maximum score you can achieve after performing the operation exactly</em> <code>k</code> <em>times.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5], k = 3
<strong>Output:</strong> 18
<strong>Explanation:</strong> We need to choose exactly 3 elements from nums to maximize the sum.
For the first iteration, we choose 5. Then sum is 5 and nums = [1,2,3,4,6]
For the second iteration, we choose 6. Then sum is 5 + 6 and nums = [1,2,3,4,7]
For the third iteration, we choose 7. Then sum is 5 + 6 + 7 = 18 and nums = [1,2,3,4,8]
So, we will return 18.
It can be proven, that 18 is the maximum answer that we can achieve.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,5,5], k = 2
<strong>Output:</strong> 11
<strong>Explanation:</strong> We need to choose exactly 2 elements from nums to maximize the sum.
For the first iteration, we choose 5. Then sum is 5 and nums = [5,5,6]
For the second iteration, we choose 6. Then sum is 5 + 6 = 11 and nums = [5,5,7]
So, we will return 11.
It can be proven, that 11 is the maximum answer that we can achieve.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
	<li><code>1 &lt;= k &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<style type=""text/css"">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value=""Show Message""] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value=""Hide Message""] + .spoiler {padding:5px;}
</style>
",1.0,False,"class Solution {
public:
    int maximizeSum(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int maximizeSum(int[] nums, int k) {
        
    }
}","class Solution(object):
    def maximizeSum(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maximizeSum(self, nums: List[int], k: int) -> int:
        ","int maximizeSum(int* nums, int numsSize, int k){

}","public class Solution {
    public int MaximizeSum(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximizeSum = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def maximize_sum(nums, k)
    
end","class Solution {
    func maximizeSum(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func maximizeSum(nums []int, k int) int {
    
}","object Solution {
    def maximizeSum(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun maximizeSum(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn maximize_sum(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function maximizeSum($nums, $k) {
        
    }
}","function maximizeSum(nums: number[], k: number): number {

};","(define/contract (maximize-sum nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec maximize_sum(Nums :: [integer()], K :: integer()) -> integer().
maximize_sum(Nums, K) ->
  .","defmodule Solution do
  @spec maximize_sum(nums :: [integer], k :: integer) :: integer
  def maximize_sum(nums, k) do

  end
end","class Solution {
  int maximizeSum(List<int> nums, int k) {

  }
}",
find-the-prefix-common-array-of-two-arrays,Find the Prefix Common Array of Two Arrays,2657.0,2766.0,"<p>You are given two <strong>0-indexed </strong>integer<strong> </strong>permutations <code>A</code> and <code>B</code> of length <code>n</code>.</p>

<p>A <strong>prefix common array</strong> of <code>A</code> and <code>B</code> is an array <code>C</code> such that <code>C[i]</code> is equal to the count of numbers that are present at or before the index <code>i</code> in both <code>A</code> and <code>B</code>.</p>

<p>Return <em>the <strong>prefix common array</strong> of </em><code>A</code><em> and </em><code>B</code>.</p>

<p>A sequence of <code>n</code> integers is called a&nbsp;<strong>permutation</strong> if it contains all integers from <code>1</code> to <code>n</code> exactly once.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> A = [1,3,2,4], B = [3,1,2,4]
<strong>Output:</strong> [0,2,3,4]
<strong>Explanation:</strong> At i = 0: no number is common, so C[0] = 0.
At i = 1: 1 and 3 are common in A and B, so C[1] = 2.
At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
At i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> A = [2,3,1], B = [3,1,2]
<strong>Output:</strong> [0,1,3]
<strong>Explanation:</strong> At i = 0: no number is common, so C[0] = 0.
At i = 1: only 3 is common in A and B, so C[1] = 1.
At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= A.length == B.length == n &lt;= 50</code></li>
	<li><code>1 &lt;= A[i], B[i] &lt;= n</code></li>
	<li><code>It is guaranteed that A and B are both a permutation of n integers.</code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {
        
    }
};","class Solution {
    public int[] findThePrefixCommonArray(int[] A, int[] B) {
        
    }
}","class Solution(object):
    def findThePrefixCommonArray(self, A, B):
        """"""
        :type A: List[int]
        :type B: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize){

}","public class Solution {
    public int[] FindThePrefixCommonArray(int[] A, int[] B) {
        
    }
}","/**
 * @param {number[]} A
 * @param {number[]} B
 * @return {number[]}
 */
var findThePrefixCommonArray = function(A, B) {
    
};","# @param {Integer[]} a
# @param {Integer[]} b
# @return {Integer[]}
def find_the_prefix_common_array(a, b)
    
end","class Solution {
    func findThePrefixCommonArray(_ A: [Int], _ B: [Int]) -> [Int] {
        
    }
}","func findThePrefixCommonArray(A []int, B []int) []int {
    
}","object Solution {
    def findThePrefixCommonArray(A: Array[Int], B: Array[Int]): Array[Int] = {
        
    }
}","class Solution {
    fun findThePrefixCommonArray(A: IntArray, B: IntArray): IntArray {
        
    }
}","impl Solution {
    pub fn find_the_prefix_common_array(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $A
     * @param Integer[] $B
     * @return Integer[]
     */
    function findThePrefixCommonArray($A, $B) {
        
    }
}","function findThePrefixCommonArray(A: number[], B: number[]): number[] {

};","(define/contract (find-the-prefix-common-array A B)
  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?))

  )","-spec find_the_prefix_common_array(A :: [integer()], B :: [integer()]) -> [integer()].
find_the_prefix_common_array(A, B) ->
  .","defmodule Solution do
  @spec find_the_prefix_common_array(a :: [integer], b :: [integer]) :: [integer]
  def find_the_prefix_common_array(a, b) do

  end
end","class Solution {
  List<int> findThePrefixCommonArray(List<int> A, List<int> B) {

  }
}",
make-array-empty,Make Array Empty,2659.0,2765.0,"<p>You are given an integer array <code>nums</code> containing <strong>distinct</strong> numbers, and you can perform the following operations <strong>until the array is empty</strong>:</p>

<ul>
	<li>If the first element has the <strong>smallest</strong> value, remove it</li>
	<li>Otherwise, put the first element at the <strong>end</strong> of the array.</li>
</ul>

<p>Return <em>an integer denoting the number of operations it takes to make </em><code>nums</code><em> empty.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,4,-1]
<strong>Output:</strong> 5
</pre>

<table style=""border: 2px solid black; border-collapse: collapse;"">
	<thead>
		<tr>
			<th style=""border: 2px solid black; padding: 5px;"">Operation</th>
			<th style=""border: 2px solid black; padding: 5px;"">Array</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style=""border: 2px solid black; padding: 5px;"">1</td>
			<td style=""border: 2px solid black; padding: 5px;"">[4, -1, 3]</td>
		</tr>
		<tr>
			<td style=""border: 2px solid black; padding: 5px;"">2</td>
			<td style=""border: 2px solid black; padding: 5px;"">[-1, 3, 4]</td>
		</tr>
		<tr>
			<td style=""border: 2px solid black; padding: 5px;"">3</td>
			<td style=""border: 2px solid black; padding: 5px;"">[3, 4]</td>
		</tr>
		<tr>
			<td style=""border: 2px solid black; padding: 5px;"">4</td>
			<td style=""border: 2px solid black; padding: 5px;"">[4]</td>
		</tr>
		<tr>
			<td style=""border: 2px solid black; padding: 5px;"">5</td>
			<td style=""border: 2px solid black; padding: 5px;"">[]</td>
		</tr>
	</tbody>
</table>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,4,3]
<strong>Output:</strong> 5
</pre>

<table style=""border: 2px solid black; border-collapse: collapse;"">
	<thead>
		<tr>
			<th style=""border: 2px solid black; padding: 5px;"">Operation</th>
			<th style=""border: 2px solid black; padding: 5px;"">Array</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style=""border: 2px solid black; padding: 5px;"">1</td>
			<td style=""border: 2px solid black; padding: 5px;"">[2, 4, 3]</td>
		</tr>
		<tr>
			<td style=""border: 2px solid black; padding: 5px;"">2</td>
			<td style=""border: 2px solid black; padding: 5px;"">[4, 3]</td>
		</tr>
		<tr>
			<td style=""border: 2px solid black; padding: 5px;"">3</td>
			<td style=""border: 2px solid black; padding: 5px;"">[3, 4]</td>
		</tr>
		<tr>
			<td style=""border: 2px solid black; padding: 5px;"">4</td>
			<td style=""border: 2px solid black; padding: 5px;"">[4]</td>
		</tr>
		<tr>
			<td style=""border: 2px solid black; padding: 5px;"">5</td>
			<td style=""border: 2px solid black; padding: 5px;"">[]</td>
		</tr>
	</tbody>
</table>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 3
</pre>

<table style=""border: 2px solid black; border-collapse: collapse;"">
	<thead>
		<tr>
			<th style=""border: 2px solid black; padding: 5px;"">Operation</th>
			<th style=""border: 2px solid black; padding: 5px;"">Array</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style=""border: 2px solid black; padding: 5px;"">1</td>
			<td style=""border: 2px solid black; padding: 5px;"">[2, 3]</td>
		</tr>
		<tr>
			<td style=""border: 2px solid black; padding: 5px;"">2</td>
			<td style=""border: 2px solid black; padding: 5px;"">[3]</td>
		</tr>
		<tr>
			<td style=""border: 2px solid black; padding: 5px;"">3</td>
			<td style=""border: 2px solid black; padding: 5px;"">[]</td>
		</tr>
	</tbody>
</table>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>9&nbsp;</sup>&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li>All values in <code>nums</code> are <strong>distinct</strong>.</li>
</ul>
",3.0,False,"class Solution {
public:
    long long countOperationsToEmptyArray(vector<int>& nums) {
        
    }
};","class Solution {
    public long countOperationsToEmptyArray(int[] nums) {
        
    }
}","class Solution(object):
    def countOperationsToEmptyArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def countOperationsToEmptyArray(self, nums: List[int]) -> int:
        ","long long countOperationsToEmptyArray(int* nums, int numsSize){

}","public class Solution {
    public long CountOperationsToEmptyArray(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var countOperationsToEmptyArray = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def count_operations_to_empty_array(nums)
    
end","class Solution {
    func countOperationsToEmptyArray(_ nums: [Int]) -> Int {
        
    }
}","func countOperationsToEmptyArray(nums []int) int64 {
    
}","object Solution {
    def countOperationsToEmptyArray(nums: Array[Int]): Long = {
        
    }
}","class Solution {
    fun countOperationsToEmptyArray(nums: IntArray): Long {
        
    }
}","impl Solution {
    pub fn count_operations_to_empty_array(nums: Vec<i32>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function countOperationsToEmptyArray($nums) {
        
    }
}","function countOperationsToEmptyArray(nums: number[]): number {

};","(define/contract (count-operations-to-empty-array nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec count_operations_to_empty_array(Nums :: [integer()]) -> integer().
count_operations_to_empty_array(Nums) ->
  .","defmodule Solution do
  @spec count_operations_to_empty_array(nums :: [integer]) :: integer
  def count_operations_to_empty_array(nums) do

  end
end","class Solution {
  int countOperationsToEmptyArray(List<int> nums) {

  }
}",
maximum-number-of-fish-in-a-grid,Maximum Number of Fish in a Grid,2658.0,2764.0,"<p>You are given a <strong>0-indexed</strong> 2D matrix <code>grid</code> of size <code>m x n</code>, where <code>(r, c)</code> represents:</p>

<ul>
	<li>A <strong>land</strong> cell if <code>grid[r][c] = 0</code>, or</li>
	<li>A <strong>water</strong> cell containing <code>grid[r][c]</code> fish, if <code>grid[r][c] &gt; 0</code>.</li>
</ul>

<p>A fisher can start at any <strong>water</strong> cell <code>(r, c)</code> and can do the following operations any number of times:</p>

<ul>
	<li>Catch all the fish at cell <code>(r, c)</code>, or</li>
	<li>Move to any adjacent <strong>water</strong> cell.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of fish the fisher can catch if he chooses his starting cell optimally, or </em><code>0</code> if no water cell exists.</p>

<p>An <strong>adjacent</strong> cell of the cell <code>(r, c)</code>, is one of the cells <code>(r, c + 1)</code>, <code>(r, c - 1)</code>, <code>(r + 1, c)</code> or <code>(r - 1, c)</code> if it exists.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/03/29/example.png"" style=""width: 241px; height: 161px;"" />
<pre>
<strong>Input:</strong> grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The fisher can start at cell <code>(1,3)</code> and collect 3 fish, then move to cell <code>(2,3)</code>&nbsp;and collect 4 fish.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/03/29/example2.png"" />
<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The fisher can start at cells (0,0) or (3,3) and collect a single fish. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int findMaxFish(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int findMaxFish(int[][] grid) {
        
    }
}","class Solution(object):
    def findMaxFish(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def findMaxFish(self, grid: List[List[int]]) -> int:
        ","int findMaxFish(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int FindMaxFish(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var findMaxFish = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def find_max_fish(grid)
    
end","class Solution {
    func findMaxFish(_ grid: [[Int]]) -> Int {
        
    }
}","func findMaxFish(grid [][]int) int {
    
}","object Solution {
    def findMaxFish(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun findMaxFish(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn find_max_fish(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function findMaxFish($grid) {
        
    }
}","function findMaxFish(grid: number[][]): number {

};","(define/contract (find-max-fish grid)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec find_max_fish(Grid :: [[integer()]]) -> integer().
find_max_fish(Grid) ->
  .","defmodule Solution do
  @spec find_max_fish(grid :: [[integer]]) :: integer
  def find_max_fish(grid) do

  end
end","class Solution {
  int findMaxFish(List<List<int>> grid) {

  }
}",
count-of-integers,Count of Integers,2719.0,2757.0,"<p>You are given two numeric strings <code>num1</code> and <code>num2</code> and two integers <code>max_sum</code> and <code>min_sum</code>. We denote an integer <code>x</code> to be <em>good</em> if:</p>

<ul>
	<li><code>num1 &lt;= x &lt;= num2</code></li>
	<li><code>min_sum &lt;= digit_sum(x) &lt;= max_sum</code>.</li>
</ul>

<p>Return <em>the number of good integers</em>. Since the answer may be large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>

<p>Note that <code>digit_sum(x)</code> denotes the sum of the digits of <code>x</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num1 = &quot;1&quot;, num2 = &quot;12&quot;, <code>min_sum</code> = 1, max_sum = 8
<strong>Output:</strong> 11
<strong>Explanation:</strong> There are 11 integers whose sum of digits lies between 1 and 8 are 1,2,3,4,5,6,7,8,10,11, and 12. Thus, we return 11.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num1 = &quot;1&quot;, num2 = &quot;5&quot;, <code>min_sum</code> = 1, max_sum = 5
<strong>Output:</strong> 5
<strong>Explanation:</strong> The 5 integers whose sum of digits lies between 1 and 5 are 1,2,3,4, and 5. Thus, we return 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= num1 &lt;= num2 &lt;= 10<sup>22</sup></code></li>
	<li><code>1 &lt;= min_sum &lt;= max_sum &lt;= 400</code></li>
</ul>
",3.0,False,"class Solution {
public:
    int count(string num1, string num2, int min_sum, int max_sum) {
        
    }
};","class Solution {
    public int count(String num1, String num2, int min_sum, int max_sum) {
        
    }
}","class Solution(object):
    def count(self, num1, num2, min_sum, max_sum):
        """"""
        :type num1: str
        :type num2: str
        :type min_sum: int
        :type max_sum: int
        :rtype: int
        """"""
        ","class Solution:
    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:
        ","int count(char * num1, char * num2, int min_sum, int max_sum){

}","public class Solution {
    public int Count(string num1, string num2, int min_sum, int max_sum) {
        
    }
}","/**
 * @param {string} num1
 * @param {string} num2
 * @param {number} min_sum
 * @param {number} max_sum
 * @return {number}
 */
var count = function(num1, num2, min_sum, max_sum) {
    
};","# @param {String} num1
# @param {String} num2
# @param {Integer} min_sum
# @param {Integer} max_sum
# @return {Integer}
def count(num1, num2, min_sum, max_sum)
    
end","class Solution {
    func count(_ num1: String, _ num2: String, _ min_sum: Int, _ max_sum: Int) -> Int {
        
    }
}","func count(num1 string, num2 string, min_sum int, max_sum int) int {
    
}","object Solution {
    def count(num1: String, num2: String, min_sum: Int, max_sum: Int): Int = {
        
    }
}","class Solution {
    fun count(num1: String, num2: String, min_sum: Int, max_sum: Int): Int {
        
    }
}","impl Solution {
    pub fn count(num1: String, num2: String, min_sum: i32, max_sum: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $num1
     * @param String $num2
     * @param Integer $min_sum
     * @param Integer $max_sum
     * @return Integer
     */
    function count($num1, $num2, $min_sum, $max_sum) {
        
    }
}","function count(num1: string, num2: string, min_sum: number, max_sum: number): number {

};","(define/contract (count num1 num2 min_sum max_sum)
  (-> string? string? exact-integer? exact-integer? exact-integer?)

  )","-spec count(Num1 :: unicode:unicode_binary(), Num2 :: unicode:unicode_binary(), Min_sum :: integer(), Max_sum :: integer()) -> integer().
count(Num1, Num2, Min_sum, Max_sum) ->
  .","defmodule Solution do
  @spec count(num1 :: String.t, num2 :: String.t, min_sum :: integer, max_sum :: integer) :: integer
  def count(num1, num2, min_sum, max_sum) do

  end
end","class Solution {
  int count(String num1, String num2, int min_sum, int max_sum) {

  }
}",
buy-two-chocolates,Buy Two Chocolates,2706.0,2756.0,"<p>You are given an integer array <code>prices</code> representing the prices of various chocolates in a store. You are also given a single integer <code>money</code>, which represents your initial amount of money.</p>

<p>You must buy <strong>exactly</strong> two chocolates in such a way that you still have some <strong>non-negative</strong> leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.</p>

<p>Return <em>the amount of money you will have leftover after buying the two chocolates</em>. If there is no way for you to buy two chocolates without ending up in debt, return <code>money</code>. Note that the leftover must be non-negative.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> prices = [1,2,2], money = 3
<strong>Output:</strong> 0
<strong>Explanation:</strong> Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> prices = [3,2,3], money = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> You cannot buy 2 chocolates without going in debt, so we return 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= prices.length &lt;= 50</code></li>
	<li><code>1 &lt;= prices[i] &lt;= 100</code></li>
	<li><code>1 &lt;= money &lt;= 100</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int buyChoco(vector<int>& prices, int money) {
        
    }
};","class Solution {
    public int buyChoco(int[] prices, int money) {
        
    }
}","class Solution(object):
    def buyChoco(self, prices, money):
        """"""
        :type prices: List[int]
        :type money: int
        :rtype: int
        """"""
        ","class Solution:
    def buyChoco(self, prices: List[int], money: int) -> int:
        ","int buyChoco(int* prices, int pricesSize, int money){

}","public class Solution {
    public int BuyChoco(int[] prices, int money) {
        
    }
}","/**
 * @param {number[]} prices
 * @param {number} money
 * @return {number}
 */
var buyChoco = function(prices, money) {
    
};","# @param {Integer[]} prices
# @param {Integer} money
# @return {Integer}
def buy_choco(prices, money)
    
end","class Solution {
    func buyChoco(_ prices: [Int], _ money: Int) -> Int {
        
    }
}","func buyChoco(prices []int, money int) int {
    
}","object Solution {
    def buyChoco(prices: Array[Int], money: Int): Int = {
        
    }
}","class Solution {
    fun buyChoco(prices: IntArray, money: Int): Int {
        
    }
}","impl Solution {
    pub fn buy_choco(prices: Vec<i32>, money: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $prices
     * @param Integer $money
     * @return Integer
     */
    function buyChoco($prices, $money) {
        
    }
}","function buyChoco(prices: number[], money: number): number {

};","(define/contract (buy-choco prices money)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec buy_choco(Prices :: [integer()], Money :: integer()) -> integer().
buy_choco(Prices, Money) ->
  .","defmodule Solution do
  @spec buy_choco(prices :: [integer], money :: integer) :: integer
  def buy_choco(prices, money) do

  end
end","class Solution {
  int buyChoco(List<int> prices, int money) {

  }
}",
extra-characters-in-a-string,Extra Characters in a String,2707.0,2755.0,"<p>You are given a <strong>0-indexed</strong> string <code>s</code> and a dictionary of words <code>dictionary</code>. You have to break <code>s</code> into one or more <strong>non-overlapping</strong> substrings such that each substring is present in <code>dictionary</code>. There may be some <strong>extra characters</strong> in <code>s</code> which are not present in any of the substrings.</p>

<p>Return <em>the <strong>minimum</strong> number of extra characters left over if you break up </em><code>s</code><em> optimally.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leetscode&quot;, dictionary = [&quot;leet&quot;,&quot;code&quot;,&quot;leetcode&quot;]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can break s in two substrings: &quot;leet&quot; from index 0 to 3 and &quot;code&quot; from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.

</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;sayhelloworld&quot;, dictionary = [&quot;hello&quot;,&quot;world&quot;]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can break s in two substrings: &quot;hello&quot; from index 3 to 7 and &quot;world&quot; from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 50</code></li>
	<li><code>1 &lt;= dictionary.length &lt;= 50</code></li>
	<li><code>1 &lt;= dictionary[i].length &lt;= 50</code></li>
	<li><code>dictionary[i]</code>&nbsp;and <code>s</code> consists of only lowercase English letters</li>
	<li><code>dictionary</code> contains distinct words</li>
</ul>
",2.0,False,"class Solution {
public:
    int minExtraChar(string s, vector<string>& dictionary) {
        
    }
};","class Solution {
    public int minExtraChar(String s, String[] dictionary) {
        
    }
}","class Solution(object):
    def minExtraChar(self, s, dictionary):
        """"""
        :type s: str
        :type dictionary: List[str]
        :rtype: int
        """"""
        ","class Solution:
    def minExtraChar(self, s: str, dictionary: List[str]) -> int:
        ","int minExtraChar(char * s, char ** dictionary, int dictionarySize){

}","public class Solution {
    public int MinExtraChar(string s, string[] dictionary) {
        
    }
}","/**
 * @param {string} s
 * @param {string[]} dictionary
 * @return {number}
 */
var minExtraChar = function(s, dictionary) {
    
};","# @param {String} s
# @param {String[]} dictionary
# @return {Integer}
def min_extra_char(s, dictionary)
    
end","class Solution {
    func minExtraChar(_ s: String, _ dictionary: [String]) -> Int {
        
    }
}","func minExtraChar(s string, dictionary []string) int {
    
}","object Solution {
    def minExtraChar(s: String, dictionary: Array[String]): Int = {
        
    }
}","class Solution {
    fun minExtraChar(s: String, dictionary: Array<String>): Int {
        
    }
}","impl Solution {
    pub fn min_extra_char(s: String, dictionary: Vec<String>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param String[] $dictionary
     * @return Integer
     */
    function minExtraChar($s, $dictionary) {
        
    }
}","function minExtraChar(s: string, dictionary: string[]): number {

};","(define/contract (min-extra-char s dictionary)
  (-> string? (listof string?) exact-integer?)

  )","-spec min_extra_char(S :: unicode:unicode_binary(), Dictionary :: [unicode:unicode_binary()]) -> integer().
min_extra_char(S, Dictionary) ->
  .","defmodule Solution do
  @spec min_extra_char(s :: String.t, dictionary :: [String.t]) :: integer
  def min_extra_char(s, dictionary) do

  end
end","class Solution {
  int minExtraChar(String s, List<String> dictionary) {

  }
}",
maximum-strength-of-a-group,Maximum Strength of a Group,2708.0,2754.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> representing the score of students in an exam. The teacher would like to form one <strong>non-empty</strong> group of students with maximal <strong>strength</strong>, where the strength of a group of students of indices <code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, <code>i<sub>2</sub></code>, ... , <code>i<sub>k</sub></code> is defined as <code>nums[i<sub>0</sub>] * nums[i<sub>1</sub>] * nums[i<sub>2</sub>] * ... * nums[i<sub>k</sub>​]</code>.</p>

<p>Return <em>the maximum strength of a group the teacher can create</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,-1,-5,2,5,-9]
<strong>Output:</strong> 1350
<strong>Explanation:</strong> One way to form a group of maximal strength is to group the students at indices [0,2,3,4,5]. Their strength is 3 * (-5) * 2 * 5 * (-9) = 1350, which we can show is optimal.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-4,-5,-4]
<strong>Output:</strong> 20
<strong>Explanation:</strong> Group the students at indices [0, 1] . Then, we&rsquo;ll have a resulting strength of 20. We cannot achieve greater strength.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 13</code></li>
	<li><code>-9 &lt;= nums[i] &lt;= 9</code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long maxStrength(vector<int>& nums) {
        
    }
};","class Solution {
    public long maxStrength(int[] nums) {
        
    }
}","class Solution(object):
    def maxStrength(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        ","long long maxStrength(int* nums, int numsSize){

}","public class Solution {
    public long MaxStrength(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var maxStrength = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def max_strength(nums)
    
end","class Solution {
    func maxStrength(_ nums: [Int]) -> Int {
        
    }
}","func maxStrength(nums []int) int64 {
    
}","object Solution {
    def maxStrength(nums: Array[Int]): Long = {
        
    }
}","class Solution {
    fun maxStrength(nums: IntArray): Long {
        
    }
}","impl Solution {
    pub fn max_strength(nums: Vec<i32>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maxStrength($nums) {
        
    }
}","function maxStrength(nums: number[]): number {

};","(define/contract (max-strength nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec max_strength(Nums :: [integer()]) -> integer().
max_strength(Nums) ->
  .","defmodule Solution do
  @spec max_strength(nums :: [integer]) :: integer
  def max_strength(nums) do

  end
end","class Solution {
  int maxStrength(List<int> nums) {

  }
}",
minimum-number-of-operations-to-make-all-array-elements-equal-to-1,Minimum Number of Operations to Make All Array Elements Equal to 1,2654.0,2753.0,"<p>You are given a <strong>0-indexed</strong>&nbsp;array <code>nums</code> consisiting of <strong>positive</strong> integers. You can do the following operation on the array <strong>any</strong> number of times:</p>

<ul>
	<li>Select an index <code>i</code> such that <code>0 &lt;= i &lt; n - 1</code> and replace either of&nbsp;<code>nums[i]</code> or <code>nums[i+1]</code> with their gcd value.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> number of operations to make all elements of </em><code>nums</code><em> equal to </em><code>1</code>. If it is impossible, return <code>-1</code>.</p>

<p>The gcd of two integers is the greatest common divisor of the two integers.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,6,3,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong> We can do the following operations:
- Choose index i = 2 and replace nums[2] with gcd(3,4) = 1. Now we have nums = [2,6,1,4].
- Choose index i = 1 and replace nums[1] with gcd(6,1) = 1. Now we have nums = [2,1,1,4].
- Choose index i = 0 and replace nums[0] with gcd(2,1) = 1. Now we have nums = [1,1,1,4].
- Choose index i = 2 and replace nums[3] with gcd(1,4) = 1. Now we have nums = [1,1,1,1].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,10,6,14]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be shown that it is impossible to make all the elements equal to 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 50</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><b>Follow-up:</b></p>

<p>The <code>O(n)</code> time complexity&nbsp;solution works, but could you find an <code>O(1)</code> constant time complexity solution?</p>
",2.0,False,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        
    }
};","class Solution {
    public int minOperations(int[] nums) {
        
    }
}","class Solution(object):
    def minOperations(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ","int minOperations(int* nums, int numsSize){

}","public class Solution {
    public int MinOperations(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var minOperations = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def min_operations(nums)
    
end","class Solution {
    func minOperations(_ nums: [Int]) -> Int {
        
    }
}","func minOperations(nums []int) int {
    
}","object Solution {
    def minOperations(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minOperations(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn min_operations(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function minOperations($nums) {
        
    }
}","function minOperations(nums: number[]): number {

};","(define/contract (min-operations nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec min_operations(Nums :: [integer()]) -> integer().
min_operations(Nums) ->
  .","defmodule Solution do
  @spec min_operations(nums :: [integer]) :: integer
  def min_operations(nums) do

  end
end","class Solution {
  int minOperations(List<int> nums) {

  }
}",
sum-multiples,Sum Multiples,2652.0,2752.0,"<p>Given a positive integer <code>n</code>, find the sum of all integers in the range <code>[1, n]</code> <strong>inclusive</strong> that are divisible by <code>3</code>, <code>5</code>, or <code>7</code>.</p>

<p>Return <em>an integer denoting the sum of all numbers in the given range satisfying&nbsp;the constraint.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 7
<strong>Output:</strong> 21
<strong>Explanation:</strong> Numbers in the range <code>[1, 7]</code> that are divisible by <code>3</code>, <code>5,</code> or <code>7 </code>are <code>3, 5, 6, 7</code>. The sum of these numbers is <code>21</code>.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 10
<strong>Output:</strong> 40
<strong>Explanation:</strong> Numbers in the range <code>[1, 10] that are</code> divisible by <code>3</code>, <code>5,</code> or <code>7</code> are <code>3, 5, 6, 7, 9, 10</code>. The sum of these numbers is 40.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 9
<strong>Output:</strong> 30
<strong>Explanation:</strong> Numbers in the range <code>[1, 9]</code> that are divisible by <code>3</code>, <code>5</code>, or <code>7</code> are <code>3, 5, 6, 7, 9</code>. The sum of these numbers is <code>30</code>.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>3</sup></code></li>
</ul>
",1.0,False,"class Solution {
public:
    int sumOfMultiples(int n) {
        
    }
};","class Solution {
    public int sumOfMultiples(int n) {
        
    }
}","class Solution(object):
    def sumOfMultiples(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def sumOfMultiples(self, n: int) -> int:
        ","int sumOfMultiples(int n){

}","public class Solution {
    public int SumOfMultiples(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var sumOfMultiples = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def sum_of_multiples(n)
    
end","class Solution {
    func sumOfMultiples(_ n: Int) -> Int {
        
    }
}","func sumOfMultiples(n int) int {
    
}","object Solution {
    def sumOfMultiples(n: Int): Int = {
        
    }
}","class Solution {
    fun sumOfMultiples(n: Int): Int {
        
    }
}","impl Solution {
    pub fn sum_of_multiples(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function sumOfMultiples($n) {
        
    }
}","function sumOfMultiples(n: number): number {

};","(define/contract (sum-of-multiples n)
  (-> exact-integer? exact-integer?)

  )","-spec sum_of_multiples(N :: integer()) -> integer().
sum_of_multiples(N) ->
  .","defmodule Solution do
  @spec sum_of_multiples(n :: integer) :: integer
  def sum_of_multiples(n) do

  end
end","class Solution {
  int sumOfMultiples(int n) {

  }
}",
sliding-subarray-beauty,Sliding Subarray Beauty,2653.0,2751.0,"<p>Given an integer array <code>nums</code> containing <code>n</code> integers, find the <strong>beauty</strong> of each subarray of size <code>k</code>.</p>

<p>The <strong>beauty</strong> of a subarray is the <code>x<sup>th</sup></code><strong> smallest integer </strong>in the subarray if it is <strong>negative</strong>, or <code>0</code> if there are fewer than <code>x</code> negative integers.</p>

<p>Return <em>an integer array containing </em><code>n - k + 1</code> <em>integers, which denote the </em><strong>beauty</strong><em> of the subarrays <strong>in order</strong> from the first index in the array.</em></p>

<ul>
	<li>
	<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>
	</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,-1,-3,-2,3], k = 3, x = 2
<strong>Output:</strong> [-1,-2,-2]
<strong>Explanation:</strong> There are 3 subarrays with size k = 3. 
The first subarray is <code>[1, -1, -3]</code> and the 2<sup>nd</sup> smallest negative integer is -1.&nbsp;
The second subarray is <code>[-1, -3, -2]</code> and the 2<sup>nd</sup> smallest negative integer is -2.&nbsp;
The third subarray is <code>[-3, -2, 3]&nbsp;</code>and the 2<sup>nd</sup> smallest negative integer is -2.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,-2,-3,-4,-5], k = 2, x = 2
<strong>Output:</strong> [-1,-2,-3,-4]
<strong>Explanation:</strong> There are 4 subarrays with size k = 2.
For <code>[-1, -2]</code>, the 2<sup>nd</sup> smallest negative integer is -1.
For <code>[-2, -3]</code>, the 2<sup>nd</sup> smallest negative integer is -2.
For <code>[-3, -4]</code>, the 2<sup>nd</sup> smallest negative integer is -3.
For <code>[-4, -5]</code>, the 2<sup>nd</sup> smallest negative integer is -4.&nbsp;</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [-3,1,2,-3,0,-3], k = 2, x = 1
<strong>Output:</strong> [-3,0,-3,-3,-3]
<strong>Explanation:</strong> There are 5 subarrays with size k = 2<strong>.</strong>
For <code>[-3, 1]</code>, the 1<sup>st</sup> smallest negative integer is -3.
For <code>[1, 2]</code>, there is no negative integer so the beauty is 0.
For <code>[2, -3]</code>, the 1<sup>st</sup> smallest negative integer is -3.
For <code>[-3, 0]</code>, the 1<sup>st</sup> smallest negative integer is -3.
For <code>[0, -3]</code>, the 1<sup>st</sup> smallest negative integer is -3.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length&nbsp;</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
	<li><code>1 &lt;= x &lt;= k&nbsp;</code></li>
	<li><code>-50&nbsp;&lt;= nums[i] &lt;= 50&nbsp;</code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {
        
    }
};","class Solution {
    public int[] getSubarrayBeauty(int[] nums, int k, int x) {
        
    }
}","class Solution(object):
    def getSubarrayBeauty(self, nums, k, x):
        """"""
        :type nums: List[int]
        :type k: int
        :type x: int
        :rtype: List[int]
        """"""
        ","class Solution:
    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* getSubarrayBeauty(int* nums, int numsSize, int k, int x, int* returnSize){

}","public class Solution {
    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @param {number} x
 * @return {number[]}
 */
var getSubarrayBeauty = function(nums, k, x) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @param {Integer} x
# @return {Integer[]}
def get_subarray_beauty(nums, k, x)
    
end","class Solution {
    func getSubarrayBeauty(_ nums: [Int], _ k: Int, _ x: Int) -> [Int] {
        
    }
}","func getSubarrayBeauty(nums []int, k int, x int) []int {
    
}","object Solution {
    def getSubarrayBeauty(nums: Array[Int], k: Int, x: Int): Array[Int] = {
        
    }
}","class Solution {
    fun getSubarrayBeauty(nums: IntArray, k: Int, x: Int): IntArray {
        
    }
}","impl Solution {
    pub fn get_subarray_beauty(nums: Vec<i32>, k: i32, x: i32) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @param Integer $x
     * @return Integer[]
     */
    function getSubarrayBeauty($nums, $k, $x) {
        
    }
}","function getSubarrayBeauty(nums: number[], k: number, x: number): number[] {

};","(define/contract (get-subarray-beauty nums k x)
  (-> (listof exact-integer?) exact-integer? exact-integer? (listof exact-integer?))

  )","-spec get_subarray_beauty(Nums :: [integer()], K :: integer(), X :: integer()) -> [integer()].
get_subarray_beauty(Nums, K, X) ->
  .","defmodule Solution do
  @spec get_subarray_beauty(nums :: [integer], k :: integer, x :: integer) :: [integer]
  def get_subarray_beauty(nums, k, x) do

  end
end","class Solution {
  List<int> getSubarrayBeauty(List<int> nums, int k, int x) {

  }
}",
calculate-delayed-arrival-time,Calculate Delayed Arrival Time,2651.0,2748.0,"<p>You are given a positive integer <code>arrivalTime</code> denoting the arrival time of a train in hours, and another positive integer <code>delayedTime</code> denoting the amount of delay in hours.</p>

<p>Return <em>the time when the train will arrive at the station.</em></p>

<p>Note that the time in this problem is in 24-hours format.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arrivalTime = 15, delayedTime = 5 
<strong>Output:</strong> 20 
<strong>Explanation:</strong> Arrival time of the train was 15:00 hours. It is delayed by 5 hours. Now it will reach at 15+5 = 20 (20:00 hours).
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arrivalTime = 13, delayedTime = 11
<strong>Output:</strong> 0
<strong>Explanation:</strong> Arrival time of the train was 13:00 hours. It is delayed by 11 hours. Now it will reach at 13+11=24 (Which is denoted by 00:00 in 24 hours format so return 0).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arrivaltime &lt;&nbsp;24</code></li>
	<li><code>1 &lt;= delayedTime &lt;= 24</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {
        
    }
};","class Solution {
    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {
        
    }
}","class Solution(object):
    def findDelayedArrivalTime(self, arrivalTime, delayedTime):
        """"""
        :type arrivalTime: int
        :type delayedTime: int
        :rtype: int
        """"""
        ","class Solution:
    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:
        ","int findDelayedArrivalTime(int arrivalTime, int delayedTime){

}","public class Solution {
    public int FindDelayedArrivalTime(int arrivalTime, int delayedTime) {
        
    }
}","/**
 * @param {number} arrivalTime
 * @param {number} delayedTime
 * @return {number}
 */
var findDelayedArrivalTime = function(arrivalTime, delayedTime) {
    
};","# @param {Integer} arrival_time
# @param {Integer} delayed_time
# @return {Integer}
def find_delayed_arrival_time(arrival_time, delayed_time)
    
end","class Solution {
    func findDelayedArrivalTime(_ arrivalTime: Int, _ delayedTime: Int) -> Int {
        
    }
}","func findDelayedArrivalTime(arrivalTime int, delayedTime int) int {
    
}","object Solution {
    def findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int = {
        
    }
}","class Solution {
    fun findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int {
        
    }
}","impl Solution {
    pub fn find_delayed_arrival_time(arrival_time: i32, delayed_time: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $arrivalTime
     * @param Integer $delayedTime
     * @return Integer
     */
    function findDelayedArrivalTime($arrivalTime, $delayedTime) {
        
    }
}","function findDelayedArrivalTime(arrivalTime: number, delayedTime: number): number {

};","(define/contract (find-delayed-arrival-time arrivalTime delayedTime)
  (-> exact-integer? exact-integer? exact-integer?)

  )","-spec find_delayed_arrival_time(ArrivalTime :: integer(), DelayedTime :: integer()) -> integer().
find_delayed_arrival_time(ArrivalTime, DelayedTime) ->
  .","defmodule Solution do
  @spec find_delayed_arrival_time(arrival_time :: integer, delayed_time :: integer) :: integer
  def find_delayed_arrival_time(arrival_time, delayed_time) do

  end
end","class Solution {
  int findDelayedArrivalTime(int arrivalTime, int delayedTime) {

  }
}",
minimize-the-total-price-of-the-trips,Minimize the Total Price of the Trips,2646.0,2739.0,"<p>There exists an undirected and unrooted tree with <code>n</code> nodes indexed from <code>0</code> to <code>n - 1</code>. You are given the integer <code>n</code> and a 2D integer array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>

<p>Each node has an associated price. You are given an integer array <code>price</code>, where <code>price[i]</code> is the price of the <code>i<sup>th</sup></code> node.</p>

<p>The <strong>price sum</strong> of a given path is the sum of the prices of all nodes lying on that path.</p>

<p>Additionally, you are given a 2D integer array <code>trips</code>, where <code>trips[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> indicates that you start the <code>i<sup>th</sup></code> trip from the node <code>start<sub>i</sub></code> and travel to the node <code>end<sub>i</sub></code> by any path you like.</p>

<p>Before performing your first trip, you can choose some <strong>non-adjacent</strong> nodes and halve the prices.</p>

<p>Return <em>the minimum total price sum to perform all the given trips</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/03/16/diagram2.png"" style=""width: 541px; height: 181px;"" />
<pre>
<strong>Input:</strong> n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]
<strong>Output:</strong> 23
<strong>Explanation:</strong> The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.
For the 1<sup>st</sup> trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.
For the 2<sup>nd</sup> trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.
For the 3<sup>rd</sup> trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.
The total price sum of all trips is 6 + 7 + 10 = 23.
It can be proven, that 23 is the minimum answer that we can achieve.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/03/16/diagram3.png"" style=""width: 456px; height: 111px;"" />
<pre>
<strong>Input:</strong> n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.
For the 1<sup>st</sup> trip, we choose path [0]. The price sum of that path is 1.
The total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>edges</code> represents a valid tree.</li>
	<li><code>price.length == n</code></li>
	<li><code>price[i]</code> is an even integer.</li>
	<li><code>1 &lt;= price[i] &lt;= 1000</code></li>
	<li><code>1 &lt;= trips.length &lt;= 100</code></li>
	<li><code>0 &lt;= start<sub>i</sub>, end<sub>i</sub>&nbsp;&lt;= n - 1</code></li>
</ul>
",3.0,False,"class Solution {
public:
    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {
        
    }
};","class Solution {
    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {
        
    }
}","class Solution(object):
    def minimumTotalPrice(self, n, edges, price, trips):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :type price: List[int]
        :type trips: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        ","int minimumTotalPrice(int n, int** edges, int edgesSize, int* edgesColSize, int* price, int priceSize, int** trips, int tripsSize, int* tripsColSize){

}","public class Solution {
    public int MinimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number[]} price
 * @param {number[][]} trips
 * @return {number}
 */
var minimumTotalPrice = function(n, edges, price, trips) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @param {Integer[]} price
# @param {Integer[][]} trips
# @return {Integer}
def minimum_total_price(n, edges, price, trips)
    
end","class Solution {
    func minimumTotalPrice(_ n: Int, _ edges: [[Int]], _ price: [Int], _ trips: [[Int]]) -> Int {
        
    }
}","func minimumTotalPrice(n int, edges [][]int, price []int, trips [][]int) int {
    
}","object Solution {
    def minimumTotalPrice(n: Int, edges: Array[Array[Int]], price: Array[Int], trips: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun minimumTotalPrice(n: Int, edges: Array<IntArray>, price: IntArray, trips: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn minimum_total_price(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>, trips: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @param Integer[] $price
     * @param Integer[][] $trips
     * @return Integer
     */
    function minimumTotalPrice($n, $edges, $price, $trips) {
        
    }
}","function minimumTotalPrice(n: number, edges: number[][], price: number[], trips: number[][]): number {

};","(define/contract (minimum-total-price n edges price trips)
  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)

  )","-spec minimum_total_price(N :: integer(), Edges :: [[integer()]], Price :: [integer()], Trips :: [[integer()]]) -> integer().
minimum_total_price(N, Edges, Price, Trips) ->
  .","defmodule Solution do
  @spec minimum_total_price(n :: integer, edges :: [[integer]], price :: [integer], trips :: [[integer]]) :: integer
  def minimum_total_price(n, edges, price, trips) do

  end
end","class Solution {
  int minimumTotalPrice(int n, List<List<int>> edges, List<int> price, List<List<int>> trips) {

  }
}",
row-with-maximum-ones,Row With Maximum Ones,2643.0,2737.0,"<p>Given a <code>m x n</code> binary matrix <code>mat</code>, find the <strong>0-indexed</strong> position of the row that contains the <strong>maximum</strong> count of <strong>ones,</strong> and the number of ones in that row.</p>

<p>In case there are multiple rows that have the maximum count of ones, the row with the <strong>smallest row number</strong> should be selected.</p>

<p>Return<em> an array containing the index of the row, and the number of ones in it.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> mat = [[0,1],[1,0]]
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong> Both rows have the same number of 1&#39;s. So we return the index of the smaller row, 0, and the maximum count of ones (1<code>)</code>. So, the answer is [0,1]. 
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[0,0,0],[0,1,1]]
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> The row indexed 1 has the maximum count of ones <code>(2)</code>. So we return its index, <code>1</code>, and the count. So, the answer is [1,2].
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> mat = [[0,0],[1,1],[0,0]]
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> The row indexed 1 has the maximum count of ones (2). So the answer is [1,2].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code>&nbsp;</li>
	<li><code>n == mat[i].length</code>&nbsp;</li>
	<li><code>1 &lt;= m, n &lt;= 100</code>&nbsp;</li>
	<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
",1.0,False,"class Solution {
public:
    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {
        
    }
};","class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        
    }
}","class Solution(object):
    def rowAndMaximumOnes(self, mat):
        """"""
        :type mat: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* rowAndMaximumOnes(int** mat, int matSize, int* matColSize, int* returnSize){

}","public class Solution {
    public int[] RowAndMaximumOnes(int[][] mat) {
        
    }
}","/**
 * @param {number[][]} mat
 * @return {number[]}
 */
var rowAndMaximumOnes = function(mat) {
    
};","# @param {Integer[][]} mat
# @return {Integer[]}
def row_and_maximum_ones(mat)
    
end","class Solution {
    func rowAndMaximumOnes(_ mat: [[Int]]) -> [Int] {
        
    }
}","func rowAndMaximumOnes(mat [][]int) []int {
    
}","object Solution {
    def rowAndMaximumOnes(mat: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun rowAndMaximumOnes(mat: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $mat
     * @return Integer[]
     */
    function rowAndMaximumOnes($mat) {
        
    }
}","function rowAndMaximumOnes(mat: number[][]): number[] {

};","(define/contract (row-and-maximum-ones mat)
  (-> (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec row_and_maximum_ones(Mat :: [[integer()]]) -> [integer()].
row_and_maximum_ones(Mat) ->
  .","defmodule Solution do
  @spec row_and_maximum_ones(mat :: [[integer]]) :: [integer]
  def row_and_maximum_ones(mat) do

  end
end","class Solution {
  List<int> rowAndMaximumOnes(List<List<int>> mat) {

  }
}",
minimum-additions-to-make-valid-string,Minimum Additions to Make Valid String,2645.0,2736.0,"<p>Given a string <code>word</code> to which you can insert letters &quot;a&quot;, &quot;b&quot; or &quot;c&quot; anywhere and any number of times, return <em>the minimum number of letters that must be inserted so that <code>word</code> becomes <strong>valid</strong>.</em></p>

<p>A string is called <strong>valid </strong>if it can be formed by concatenating the string &quot;abc&quot; several times.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;b&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> Insert the letter &quot;a&quot; right before &quot;b&quot;, and the letter &quot;c&quot; right next to &quot;a&quot; to obtain the valid string &quot;<strong>a</strong>b<strong>c</strong>&quot;.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;aaa&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> Insert letters &quot;b&quot; and &quot;c&quot; next to each &quot;a&quot; to obtain the valid string &quot;a<strong>bc</strong>a<strong>bc</strong>a<strong>bc</strong>&quot;.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abc&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> word is already valid. No modifications are needed. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 50</code></li>
	<li><code>word</code> consists of letters &quot;a&quot;, &quot;b&quot;&nbsp;and &quot;c&quot; only.&nbsp;</li>
</ul>
",2.0,False,"class Solution {
public:
    int addMinimum(string word) {
        
    }
};","class Solution {
    public int addMinimum(String word) {
        
    }
}","class Solution(object):
    def addMinimum(self, word):
        """"""
        :type word: str
        :rtype: int
        """"""
        ","class Solution:
    def addMinimum(self, word: str) -> int:
        ","int addMinimum(char * word){

}","public class Solution {
    public int AddMinimum(string word) {
        
    }
}","/**
 * @param {string} word
 * @return {number}
 */
var addMinimum = function(word) {
    
};","# @param {String} word
# @return {Integer}
def add_minimum(word)
    
end","class Solution {
    func addMinimum(_ word: String) -> Int {
        
    }
}","func addMinimum(word string) int {
    
}","object Solution {
    def addMinimum(word: String): Int = {
        
    }
}","class Solution {
    fun addMinimum(word: String): Int {
        
    }
}","impl Solution {
    pub fn add_minimum(word: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $word
     * @return Integer
     */
    function addMinimum($word) {
        
    }
}","function addMinimum(word: string): number {

};","(define/contract (add-minimum word)
  (-> string? exact-integer?)

  )","-spec add_minimum(Word :: unicode:unicode_binary()) -> integer().
add_minimum(Word) ->
  .","defmodule Solution do
  @spec add_minimum(word :: String.t) :: integer
  def add_minimum(word) do

  end
end","class Solution {
  int addMinimum(String word) {

  }
}",
maximum-or,Maximum OR,2680.0,2730.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code> and an integer <code>k</code>. In an operation, you can choose an element and multiply it by <code>2</code>.</p>

<p>Return <em>the maximum possible value of </em><code>nums[0] | nums[1] | ... | nums[n - 1]</code> <em>that can be obtained after applying the operation on nums at most </em><code>k</code><em> times</em>.</p>

<p>Note that <code>a | b</code> denotes the <strong>bitwise or</strong> between two integers <code>a</code> and <code>b</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [12,9], k = 1
<strong>Output:</strong> 30
<strong>Explanation:</strong> If we apply the operation to index 1, our new array nums will be equal to [12,18]. Thus, we return the bitwise or of 12 and 18, which is 30.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [8,1,2], k = 2
<strong>Output:</strong> 35
<strong>Explanation:</strong> If we apply the operation twice on index 0, we yield a new array of [32,1,2]. Thus, we return 32|1|2 = 35.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= 15</code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long maximumOr(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public long maximumOr(int[] nums, int k) {
        
    }
}","class Solution(object):
    def maximumOr(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        ","long long maximumOr(int* nums, int numsSize, int k){

}","public class Solution {
    public long MaximumOr(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumOr = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def maximum_or(nums, k)
    
end","class Solution {
    func maximumOr(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func maximumOr(nums []int, k int) int64 {
    
}","object Solution {
    def maximumOr(nums: Array[Int], k: Int): Long = {
        
    }
}","class Solution {
    fun maximumOr(nums: IntArray, k: Int): Long {
        
    }
}","impl Solution {
    pub fn maximum_or(nums: Vec<i32>, k: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function maximumOr($nums, $k) {
        
    }
}","function maximumOr(nums: number[], k: number): number {

};","(define/contract (maximum-or nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec maximum_or(Nums :: [integer()], K :: integer()) -> integer().
maximum_or(Nums, K) ->
  .","defmodule Solution do
  @spec maximum_or(nums :: [integer], k :: integer) :: integer
  def maximum_or(nums, k) do

  end
end","class Solution {
  int maximumOr(List<int> nums, int k) {

  }
}",
sum-in-a-matrix,Sum in a Matrix,2679.0,2728.0,"<p>You are given a <strong>0-indexed</strong> 2D integer array <code>nums</code>. Initially, your score is <code>0</code>. Perform the following operations until the matrix becomes empty:</p>

<ol>
	<li>From each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.</li>
	<li>Identify the highest number amongst all those removed in step 1. Add that number to your <strong>score</strong>.</li>
</ol>

<p>Return <em>the final <strong>score</strong>.</em></p>
<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]
<strong>Output:</strong> 15
<strong>Explanation:</strong> In the first operation, we remove 7, 6, 6, and 3. We then add 7 to our score. Next, we remove 2, 4, 5, and 2. We add 5 to our score. Lastly, we remove 1, 2, 3, and 1. We add 3 to our score. Thus, our final score is 7 + 5 + 3 = 15.
</pre>

<p><strong>Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [[1]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We remove 1 and add it to the answer. We return 1.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 300</code></li>
	<li><code>1 &lt;= nums[i].length &lt;= 500</code></li>
	<li><code>0 &lt;= nums[i][j] &lt;= 10<sup>3</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int matrixSum(vector<vector<int>>& nums) {
        
    }
};","class Solution {
    public int matrixSum(int[][] nums) {
        
    }
}","class Solution(object):
    def matrixSum(self, nums):
        """"""
        :type nums: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def matrixSum(self, nums: List[List[int]]) -> int:
        ","int matrixSum(int** nums, int numsSize, int* numsColSize){

}","public class Solution {
    public int MatrixSum(int[][] nums) {
        
    }
}","/**
 * @param {number[][]} nums
 * @return {number}
 */
var matrixSum = function(nums) {
    
};","# @param {Integer[][]} nums
# @return {Integer}
def matrix_sum(nums)
    
end","class Solution {
    func matrixSum(_ nums: [[Int]]) -> Int {
        
    }
}","func matrixSum(nums [][]int) int {
    
}","object Solution {
    def matrixSum(nums: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun matrixSum(nums: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn matrix_sum(nums: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $nums
     * @return Integer
     */
    function matrixSum($nums) {
        
    }
}","function matrixSum(nums: number[][]): number {

};","(define/contract (matrix-sum nums)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec matrix_sum(Nums :: [[integer()]]) -> integer().
matrix_sum(Nums) ->
  .","defmodule Solution do
  @spec matrix_sum(nums :: [[integer]]) :: integer
  def matrix_sum(nums) do

  end
end","class Solution {
  int matrixSum(List<List<int>> nums) {

  }
}",
number-of-senior-citizens,Number of Senior Citizens,2678.0,2727.0,"<p>You are given a <strong>0-indexed</strong> array of strings <code>details</code>. Each element of <code>details</code> provides information about a given passenger compressed into a string of length <code>15</code>. The system is such that:</p>

<ul>
	<li>The first ten characters consist of the phone number of passengers.</li>
	<li>The next character denotes the gender of the person.</li>
	<li>The following two characters are used to indicate the age of the person.</li>
	<li>The last two characters determine the seat allotted to that person.</li>
</ul>

<p>Return <em>the number of passengers who are <strong>strictly </strong><strong>more than 60 years old</strong>.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> details = [&quot;7868190130M7522&quot;,&quot;5303914400F9211&quot;,&quot;9273338290F4010&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The passengers at indices 0, 1, and 2 have ages 75, 92, and 40. Thus, there are 2 people who are over 60 years old.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> details = [&quot;1313579440F2036&quot;,&quot;2921522980M5644&quot;]
<strong>Output:</strong> 0
<strong>Explanation:</strong> None of the passengers are older than 60.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= details.length &lt;= 100</code></li>
	<li><code>details[i].length == 15</code></li>
	<li><code>details[i] consists of digits from &#39;0&#39; to &#39;9&#39;.</code></li>
	<li><code>details[i][10] is either &#39;M&#39; or &#39;F&#39; or &#39;O&#39;.</code></li>
	<li>The phone numbers and seat numbers of the passengers are distinct.</li>
</ul>
",1.0,False,"class Solution {
public:
    int countSeniors(vector<string>& details) {
        
    }
};","class Solution {
    public int countSeniors(String[] details) {
        
    }
}","class Solution(object):
    def countSeniors(self, details):
        """"""
        :type details: List[str]
        :rtype: int
        """"""
        ","class Solution:
    def countSeniors(self, details: List[str]) -> int:
        ","int countSeniors(char ** details, int detailsSize){

}","public class Solution {
    public int CountSeniors(string[] details) {
        
    }
}","/**
 * @param {string[]} details
 * @return {number}
 */
var countSeniors = function(details) {
    
};","# @param {String[]} details
# @return {Integer}
def count_seniors(details)
    
end","class Solution {
    func countSeniors(_ details: [String]) -> Int {
        
    }
}","func countSeniors(details []string) int {
    
}","object Solution {
    def countSeniors(details: Array[String]): Int = {
        
    }
}","class Solution {
    fun countSeniors(details: Array<String>): Int {
        
    }
}","impl Solution {
    pub fn count_seniors(details: Vec<String>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $details
     * @return Integer
     */
    function countSeniors($details) {
        
    }
}","function countSeniors(details: string[]): number {

};","(define/contract (count-seniors details)
  (-> (listof string?) exact-integer?)

  )","-spec count_seniors(Details :: [unicode:unicode_binary()]) -> integer().
count_seniors(Details) ->
  .","defmodule Solution do
  @spec count_seniors(details :: [String.t]) :: integer
  def count_seniors(details) do

  end
end","class Solution {
  int countSeniors(List<String> details) {

  }
}",
minimum-reverse-operations,Minimum Reverse Operations,2612.0,2726.0,"<p>You are given an integer <code>n</code> and an integer <code>p</code> in the range <code>[<font face=""monospace"">0</font>, n - 1]</code>. Representing a <strong>0-indexed</strong> array <code>arr</code>&nbsp;of length <code>n</code> where all positions are set to <code>0</code>&#39;s, except position <code>p</code> which is set to <code>1</code>.</p>

<p>You are also given an integer array <code>banned</code> containing some positions from the array. For the <strong>i</strong><sup><strong>th</strong></sup> position in <code>banned</code>, <code>arr[banned[i]] = 0</code>, and <code>banned[i] != p</code>.</p>

<p>You can perform <strong>multiple</strong> operations on <code>arr</code>. In an operation, you can choose a <strong>subarray</strong> with size <code>k</code> and <strong>reverse</strong> the subarray. However, the <code>1</code> in <code>arr</code> should never go to any of the positions in <code>banned</code>. In other words, after each operation <code>arr[banned[i]]</code> <strong>remains</strong> <code>0</code>.</p>

<p><em>Return an array</em> <code>ans</code> <em>where</em><em> for each </em><code>i</code><em> from </em><code>[0, n - 1]</code>, <code>ans[i]</code> <em>is the <strong>minimum</strong> number of reverse operations needed to bring the</em> <code>1</code> <em>to position</em> <code>i</code><em> in arr</em>, <em>or</em> <code>-1</code> <em>if it is impossible</em>.</p>

<ul>
	<li>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</li>
	<li>The values of <code>ans[i]</code> are independent for all <code>i</code>&#39;s.</li>
	<li>The <strong>reverse </strong>of an array is an array containing the values in <strong>reverse order</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 4, p = 0, banned = [1,2], k = 4
<strong>Output:</strong> [0,-1,-1,1]
<strong>Explanation:</strong> In this case <code>k = 4</code> so there is only one possible reverse operation we can perform, which is reversing the whole array. Initially, 1<strong> </strong>is placed at position 0 so the amount of operations we need for position 0 is <code>0</code>. We can never place a 1 on the banned positions, so the answer for positions 1 and 2 is <code>-1</code>. Finally, with one reverse operation we can bring the 1 to index 3, so the answer for position 3 is <code>1</code>. 
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 5, p = 0, banned = [2,4], k = 3
<strong>Output:</strong> [0,-1,-1,-1,-1]
<strong>Explanation:</strong> In this case the 1 is initially at position 0, so the answer for that position is <code>0</code>. We can perform reverse operations of size 3. The 1 is currently located at position 0, so we need to reverse the subarray <code>[0, 2]</code> for it to leave that position, but reversing that subarray makes position 2 have a 1, which shouldn&#39;t happen. So, we can&#39;t move the 1 from position 0, making the result for all the other positions <code>-1</code>. 
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 4, p = 2, banned = [0,1,3], k = 1
<strong>Output:</strong> [-1,-1,0,-1]
<strong>Explanation:</strong> In this case we can only perform reverse operations of size 1.<strong>&nbsp;</strong>So the 1 never changes its position.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= p &lt;= n - 1</code></li>
	<li><code>0 &lt;= banned.length &lt;= n - 1</code></li>
	<li><code>0 &lt;= banned[i] &lt;= n - 1</code></li>
	<li><code>1 &lt;= k &lt;= n&nbsp;</code></li>
	<li><code>banned[i] != p</code></li>
	<li>all values in <code>banned</code>&nbsp;are <strong>unique</strong>&nbsp;</li>
</ul>
",3.0,False,"class Solution {
public:
    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {
        
    }
};","class Solution {
    public int[] minReverseOperations(int n, int p, int[] banned, int k) {
        
    }
}","class Solution(object):
    def minReverseOperations(self, n, p, banned, k):
        """"""
        :type n: int
        :type p: int
        :type banned: List[int]
        :type k: int
        :rtype: List[int]
        """"""
        ","class Solution:
    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* minReverseOperations(int n, int p, int* banned, int bannedSize, int k, int* returnSize){

}","public class Solution {
    public int[] MinReverseOperations(int n, int p, int[] banned, int k) {
        
    }
}","/**
 * @param {number} n
 * @param {number} p
 * @param {number[]} banned
 * @param {number} k
 * @return {number[]}
 */
var minReverseOperations = function(n, p, banned, k) {
    
};","# @param {Integer} n
# @param {Integer} p
# @param {Integer[]} banned
# @param {Integer} k
# @return {Integer[]}
def min_reverse_operations(n, p, banned, k)
    
end","class Solution {
    func minReverseOperations(_ n: Int, _ p: Int, _ banned: [Int], _ k: Int) -> [Int] {
        
    }
}","func minReverseOperations(n int, p int, banned []int, k int) []int {
    
}","object Solution {
    def minReverseOperations(n: Int, p: Int, banned: Array[Int], k: Int): Array[Int] = {
        
    }
}","class Solution {
    fun minReverseOperations(n: Int, p: Int, banned: IntArray, k: Int): IntArray {
        
    }
}","impl Solution {
    pub fn min_reverse_operations(n: i32, p: i32, banned: Vec<i32>, k: i32) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $p
     * @param Integer[] $banned
     * @param Integer $k
     * @return Integer[]
     */
    function minReverseOperations($n, $p, $banned, $k) {
        
    }
}","function minReverseOperations(n: number, p: number, banned: number[], k: number): number[] {

};","(define/contract (min-reverse-operations n p banned k)
  (-> exact-integer? exact-integer? (listof exact-integer?) exact-integer? (listof exact-integer?))

  )","-spec min_reverse_operations(N :: integer(), P :: integer(), Banned :: [integer()], K :: integer()) -> [integer()].
min_reverse_operations(N, P, Banned, K) ->
  .","defmodule Solution do
  @spec min_reverse_operations(n :: integer, p :: integer, banned :: [integer], k :: integer) :: [integer]
  def min_reverse_operations(n, p, banned, k) do

  end
end","class Solution {
  List<int> minReverseOperations(int n, int p, List<int> banned, int k) {

  }
}",
mice-and-cheese,Mice and Cheese,2611.0,2725.0,"<p>There are two mice and <code>n</code> different types of cheese, each type of cheese should be eaten by exactly one mouse.</p>

<p>A point of the cheese with index <code>i</code> (<strong>0-indexed</strong>) is:</p>

<ul>
	<li><code>reward1[i]</code> if the first mouse eats it.</li>
	<li><code>reward2[i]</code> if the second mouse eats it.</li>
</ul>

<p>You are given a positive integer array <code>reward1</code>, a positive integer array <code>reward2</code>, and a non-negative integer <code>k</code>.</p>

<p>Return <em><strong>the maximum</strong> points the mice can achieve if the first mouse eats exactly </em><code>k</code><em> types of cheese.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2
<strong>Output:</strong> 15
<strong>Explanation:</strong> In this example, the first mouse eats the 2<sup>nd</sup>&nbsp;(0-indexed) and the 3<sup>rd</sup>&nbsp;types of cheese, and the second mouse eats the 0<sup>th</sup>&nbsp;and the 1<sup>st</sup> types of cheese.
The total points are 4 + 4 + 3 + 4 = 15.
It can be proven that 15 is the maximum total points that the mice can achieve.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> reward1 = [1,1], reward2 = [1,1], k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example, the first mouse eats the 0<sup>th</sup>&nbsp;(0-indexed) and 1<sup>st</sup>&nbsp;types of cheese, and the second mouse does not eat any cheese.
The total points are 1 + 1 = 2.
It can be proven that 2 is the maximum total points that the mice can achieve.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == reward1.length == reward2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= reward1[i],&nbsp;reward2[i] &lt;= 1000</code></li>
	<li><code>0 &lt;= k &lt;= n</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {
        
    }
};","class Solution {
    public int miceAndCheese(int[] reward1, int[] reward2, int k) {
        
    }
}","class Solution(object):
    def miceAndCheese(self, reward1, reward2, k):
        """"""
        :type reward1: List[int]
        :type reward2: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:
        ","int miceAndCheese(int* reward1, int reward1Size, int* reward2, int reward2Size, int k){

}","public class Solution {
    public int MiceAndCheese(int[] reward1, int[] reward2, int k) {
        
    }
}","/**
 * @param {number[]} reward1
 * @param {number[]} reward2
 * @param {number} k
 * @return {number}
 */
var miceAndCheese = function(reward1, reward2, k) {
    
};","# @param {Integer[]} reward1
# @param {Integer[]} reward2
# @param {Integer} k
# @return {Integer}
def mice_and_cheese(reward1, reward2, k)
    
end","class Solution {
    func miceAndCheese(_ reward1: [Int], _ reward2: [Int], _ k: Int) -> Int {
        
    }
}","func miceAndCheese(reward1 []int, reward2 []int, k int) int {
    
}","object Solution {
    def miceAndCheese(reward1: Array[Int], reward2: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun miceAndCheese(reward1: IntArray, reward2: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn mice_and_cheese(reward1: Vec<i32>, reward2: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $reward1
     * @param Integer[] $reward2
     * @param Integer $k
     * @return Integer
     */
    function miceAndCheese($reward1, $reward2, $k) {
        
    }
}","function miceAndCheese(reward1: number[], reward2: number[], k: number): number {

};","(define/contract (mice-and-cheese reward1 reward2 k)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec mice_and_cheese(Reward1 :: [integer()], Reward2 :: [integer()], K :: integer()) -> integer().
mice_and_cheese(Reward1, Reward2, K) ->
  .","defmodule Solution do
  @spec mice_and_cheese(reward1 :: [integer], reward2 :: [integer], k :: integer) :: integer
  def mice_and_cheese(reward1, reward2, k) do

  end
end","class Solution {
  int miceAndCheese(List<int> reward1, List<int> reward2, int k) {

  }
}",
convert-an-array-into-a-2d-array-with-conditions,Convert an Array Into a 2D Array With Conditions,2610.0,2724.0,"<p>You are given an integer array <code>nums</code>. You need to create a 2D array from <code>nums</code> satisfying the following conditions:</p>

<ul>
	<li>The 2D array should contain <strong>only</strong> the elements of the array <code>nums</code>.</li>
	<li>Each row in the 2D array contains <strong>distinct</strong> integers.</li>
	<li>The number of rows in the 2D array should be <strong>minimal</strong>.</li>
</ul>

<p>Return <em>the resulting array</em>. If there are multiple answers, return any of them.</p>

<p><strong>Note</strong> that the 2D array can have a different number of elements on each row.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,4,1,2,3,1]
<strong>Output:</strong> [[1,3,4,2],[1,3],[1]]
<strong>Explanation:</strong> We can create a 2D array that contains the following rows:
- 1,3,4,2
- 1,3
- 1
All elements of nums were used, and each row of the 2D array contains distinct integers, so it is a valid answer.
It can be shown that we cannot have less than 3 rows in a valid array.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> [[4,3,2,1]]
<strong>Explanation:</strong> All elements of the array are distinct, so we can keep all of them in the first row of the 2D array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 200</code></li>
	<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<vector<int>> findMatrix(vector<int>& nums) {
        
    }
};","class Solution {
    public List<List<Integer>> findMatrix(int[] nums) {
        
    }
}","class Solution(object):
    def findMatrix(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** findMatrix(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public IList<IList<int>> FindMatrix(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var findMatrix = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer[][]}
def find_matrix(nums)
    
end","class Solution {
    func findMatrix(_ nums: [Int]) -> [[Int]] {
        
    }
}","func findMatrix(nums []int) [][]int {
    
}","object Solution {
    def findMatrix(nums: Array[Int]): List[List[Int]] = {
        
    }
}","class Solution {
    fun findMatrix(nums: IntArray): List<List<Int>> {
        
    }
}","impl Solution {
    pub fn find_matrix(nums: Vec<i32>) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer[][]
     */
    function findMatrix($nums) {
        
    }
}","function findMatrix(nums: number[]): number[][] {

};","(define/contract (find-matrix nums)
  (-> (listof exact-integer?) (listof (listof exact-integer?)))

  )","-spec find_matrix(Nums :: [integer()]) -> [[integer()]].
find_matrix(Nums) ->
  .","defmodule Solution do
  @spec find_matrix(nums :: [integer]) :: [[integer]]
  def find_matrix(nums) do

  end
end","class Solution {
  List<List<int>> findMatrix(List<int> nums) {

  }
}",
find-the-longest-balanced-substring-of-a-binary-string,Find the Longest Balanced Substring of a Binary String,2609.0,2723.0,"<p>You are given a binary string <code>s</code> consisting only of zeroes and ones.</p>

<p>A substring of <code>s</code> is considered balanced if<strong> all zeroes are before ones</strong> and the number of zeroes is equal to the number of ones inside the substring. Notice that the empty substring is considered a balanced substring.</p>

<p>Return <em>the length of the longest balanced substring of </em><code>s</code>.</p>

<p>A <b>substring</b> is a contiguous sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;01000111&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> The longest balanced substring is &quot;000111&quot;, which has length 6.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;00111&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest balanced substring is &quot;0011&quot;, which has length 4.&nbsp;
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;111&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no balanced substring except the empty substring, so the answer is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 50</code></li>
	<li><code>&#39;0&#39; &lt;= s[i] &lt;= &#39;1&#39;</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int findTheLongestBalancedSubstring(string s) {
        
    }
};","class Solution {
    public int findTheLongestBalancedSubstring(String s) {
        
    }
}","class Solution(object):
    def findTheLongestBalancedSubstring(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def findTheLongestBalancedSubstring(self, s: str) -> int:
        ","int findTheLongestBalancedSubstring(char * s){

}","public class Solution {
    public int FindTheLongestBalancedSubstring(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var findTheLongestBalancedSubstring = function(s) {
    
};","# @param {String} s
# @return {Integer}
def find_the_longest_balanced_substring(s)
    
end","class Solution {
    func findTheLongestBalancedSubstring(_ s: String) -> Int {
        
    }
}","func findTheLongestBalancedSubstring(s string) int {
    
}","object Solution {
    def findTheLongestBalancedSubstring(s: String): Int = {
        
    }
}","class Solution {
    fun findTheLongestBalancedSubstring(s: String): Int {
        
    }
}","impl Solution {
    pub fn find_the_longest_balanced_substring(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function findTheLongestBalancedSubstring($s) {
        
    }
}","function findTheLongestBalancedSubstring(s: string): number {

};","(define/contract (find-the-longest-balanced-substring s)
  (-> string? exact-integer?)

  )","-spec find_the_longest_balanced_substring(S :: unicode:unicode_binary()) -> integer().
find_the_longest_balanced_substring(S) ->
  .","defmodule Solution do
  @spec find_the_longest_balanced_substring(s :: String.t) :: integer
  def find_the_longest_balanced_substring(s) do

  end
end","class Solution {
  int findTheLongestBalancedSubstring(String s) {

  }
}",
prime-in-diagonal,Prime In Diagonal,2614.0,2722.0,"<p>You are given a 0-indexed two-dimensional integer array <code>nums</code>.</p>

<p>Return <em>the largest <strong>prime</strong> number that lies on at least one of the <b>diagonals</b> of </em><code>nums</code>. In case, no prime is present on any of the diagonals, return<em> 0.</em></p>

<p>Note that:</p>

<ul>
	<li>An integer is <strong>prime</strong> if it is greater than <code>1</code> and has no positive integer divisors other than <code>1</code> and itself.</li>
	<li>An integer <code>val</code> is on one of the <strong>diagonals</strong> of <code>nums</code> if there exists an integer <code>i</code> for which <code>nums[i][i] = val</code> or an <code>i</code> for which <code>nums[i][nums.length - i - 1] = val</code>.</li>
</ul>

<p><img alt="""" src=""https://assets.leetcode.com/uploads/2023/03/06/screenshot-2023-03-06-at-45648-pm.png"" style=""width: 181px; height: 121px;"" /></p>

<p>In the above diagram, one diagonal is <strong>[1,5,9]</strong> and another diagonal is<strong> [3,5,7]</strong>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [[1,2,3],[5,6,7],[9,10,11]]
<strong>Output:</strong> 11
<strong>Explanation:</strong> The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [[1,2,3],[5,17,7],[9,11,10]]
<strong>Output:</strong> 17
<strong>Explanation:</strong> The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 300</code></li>
	<li><code>nums.length == nums<sub>i</sub>.length</code></li>
	<li><code>1 &lt;= nums<span style=""font-size: 10.8333px;"">[i][j]</span>&nbsp;&lt;= 4*10<sup>6</sup></code></li>
</ul>
",1.0,False,"class Solution {
public:
    int diagonalPrime(vector<vector<int>>& nums) {
        
    }
};","class Solution {
    public int diagonalPrime(int[][] nums) {
        
    }
}","class Solution(object):
    def diagonalPrime(self, nums):
        """"""
        :type nums: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def diagonalPrime(self, nums: List[List[int]]) -> int:
        ","int diagonalPrime(int** nums, int numsSize, int* numsColSize){

}","public class Solution {
    public int DiagonalPrime(int[][] nums) {
        
    }
}","/**
 * @param {number[][]} nums
 * @return {number}
 */
var diagonalPrime = function(nums) {
    
};","# @param {Integer[][]} nums
# @return {Integer}
def diagonal_prime(nums)
    
end","class Solution {
    func diagonalPrime(_ nums: [[Int]]) -> Int {
        
    }
}","func diagonalPrime(nums [][]int) int {
    
}","object Solution {
    def diagonalPrime(nums: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun diagonalPrime(nums: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn diagonal_prime(nums: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $nums
     * @return Integer
     */
    function diagonalPrime($nums) {
        
    }
}","function diagonalPrime(nums: number[][]): number {

};","(define/contract (diagonal-prime nums)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec diagonal_prime(Nums :: [[integer()]]) -> integer().
diagonal_prime(Nums) ->
  .","defmodule Solution do
  @spec diagonal_prime(nums :: [[integer]]) :: integer
  def diagonal_prime(nums) do

  end
end","class Solution {
  int diagonalPrime(List<List<int>> nums) {

  }
}",
sum-of-distances,Sum of Distances,2615.0,2721.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. There exists an array <code>arr</code> of length <code>nums.length</code>, where <code>arr[i]</code> is the sum of <code>|i - j|</code> over all <code>j</code> such that <code>nums[j] == nums[i]</code> and <code>j != i</code>. If there is no such <code>j</code>, set <code>arr[i]</code> to be <code>0</code>.</p>

<p>Return <em>the array </em><code>arr</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,1,1,2]
<strong>Output:</strong> [5,0,3,4,0]
<strong>Explanation:</strong> 
When i = 0, nums[0] == nums[2] and nums[0] == nums[3]. Therefore, arr[0] = |0 - 2| + |0 - 3| = 5. 
When i = 1, arr[1] = 0 because there is no other index with value 3.
When i = 2, nums[2] == nums[0] and nums[2] == nums[3]. Therefore, arr[2] = |2 - 0| + |2 - 3| = 3. 
When i = 3, nums[3] == nums[0] and nums[3] == nums[2]. Therefore, arr[3] = |3 - 0| + |3 - 2| = 4. 
When i = 4, arr[4] = 0 because there is no other index with value 2. 

</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,5,3]
<strong>Output:</strong> [0,0,0]
<strong>Explanation:</strong> Since each element in nums is distinct, arr[i] = 0 for all i.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<long long> distance(vector<int>& nums) {
        
    }
};","class Solution {
    public long[] distance(int[] nums) {
        
    }
}","class Solution(object):
    def distance(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def distance(self, nums: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
long long* distance(int* nums, int numsSize, int* returnSize){

}","public class Solution {
    public long[] Distance(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number[]}
 */
var distance = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer[]}
def distance(nums)
    
end","class Solution {
    func distance(_ nums: [Int]) -> [Int] {
        
    }
}","func distance(nums []int) []int64 {
    
}","object Solution {
    def distance(nums: Array[Int]): Array[Long] = {
        
    }
}","class Solution {
    fun distance(nums: IntArray): LongArray {
        
    }
}","impl Solution {
    pub fn distance(nums: Vec<i32>) -> Vec<i64> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function distance($nums) {
        
    }
}","function distance(nums: number[]): number[] {

};","(define/contract (distance nums)
  (-> (listof exact-integer?) (listof exact-integer?))

  )","-spec distance(Nums :: [integer()]) -> [integer()].
distance(Nums) ->
  .","defmodule Solution do
  @spec distance(nums :: [integer]) :: [integer]
  def distance(nums) do

  end
end","class Solution {
  List<int> distance(List<int> nums) {

  }
}",
minimize-the-maximum-difference-of-pairs,Minimize the Maximum Difference of Pairs,2616.0,2720.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>p</code>. Find <code>p</code> pairs of indices of <code>nums</code> such that the <strong>maximum</strong> difference amongst all the pairs is <strong>minimized</strong>. Also, ensure no index appears more than once amongst the <code>p</code> pairs.</p>

<p>Note that for a pair of elements at the index <code>i</code> and <code>j</code>, the difference of this pair is <code>|nums[i] - nums[j]|</code>, where <code>|x|</code> represents the <strong>absolute</strong> <strong>value</strong> of <code>x</code>.</p>

<p>Return <em>the <strong>minimum</strong> <strong>maximum</strong> difference among all </em><code>p</code> <em>pairs.</em> We define the maximum of an empty set to be zero.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,1,2,7,1,3], p = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. 
The maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,2,1,2], p = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= p &lt;= (nums.length)/2</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int minimizeMax(vector<int>& nums, int p) {
        
    }
};","class Solution {
    public int minimizeMax(int[] nums, int p) {
        
    }
}","class Solution(object):
    def minimizeMax(self, nums, p):
        """"""
        :type nums: List[int]
        :type p: int
        :rtype: int
        """"""
        ","class Solution:
    def minimizeMax(self, nums: List[int], p: int) -> int:
        ","int minimizeMax(int* nums, int numsSize, int p){

}","public class Solution {
    public int MinimizeMax(int[] nums, int p) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} p
 * @return {number}
 */
var minimizeMax = function(nums, p) {
    
};","# @param {Integer[]} nums
# @param {Integer} p
# @return {Integer}
def minimize_max(nums, p)
    
end","class Solution {
    func minimizeMax(_ nums: [Int], _ p: Int) -> Int {
        
    }
}","func minimizeMax(nums []int, p int) int {
    
}","object Solution {
    def minimizeMax(nums: Array[Int], p: Int): Int = {
        
    }
}","class Solution {
    fun minimizeMax(nums: IntArray, p: Int): Int {
        
    }
}","impl Solution {
    pub fn minimize_max(nums: Vec<i32>, p: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $p
     * @return Integer
     */
    function minimizeMax($nums, $p) {
        
    }
}","function minimizeMax(nums: number[], p: number): number {

};","(define/contract (minimize-max nums p)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec minimize_max(Nums :: [integer()], P :: integer()) -> integer().
minimize_max(Nums, P) ->
  .","defmodule Solution do
  @spec minimize_max(nums :: [integer], p :: integer) :: integer
  def minimize_max(nums, p) do

  end
end","class Solution {
  int minimizeMax(List<int> nums, int p) {

  }
}",
minimum-operations-to-make-all-array-elements-equal,Minimum Operations to Make All Array Elements Equal,2602.0,2718.0,"<p>You are given an array <code>nums</code> consisting of positive integers.</p>

<p>You are also given an integer array <code>queries</code> of size <code>m</code>. For the <code>i<sup>th</sup></code> query, you want to make all of the elements of <code>nums</code> equal to<code> queries[i]</code>. You can perform the following operation on the array <strong>any</strong> number of times:</p>

<ul>
	<li><strong>Increase</strong> or <strong>decrease</strong> an element of the array by <code>1</code>.</li>
</ul>

<p>Return <em>an array </em><code>answer</code><em> of size </em><code>m</code><em> where </em><code>answer[i]</code><em> is the <strong>minimum</strong> number of operations to make all elements of </em><code>nums</code><em> equal to </em><code>queries[i]</code>.</p>

<p><strong>Note</strong> that after each query the array is reset to its original state.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,6,8], queries = [1,5]
<strong>Output:</strong> [14,10]
<strong>Explanation:</strong> For the first query we can do the following operations:
- Decrease nums[0] 2 times, so that nums = [1,1,6,8].
- Decrease nums[2] 5 times, so that nums = [1,1,1,8].
- Decrease nums[3] 7 times, so that nums = [1,1,1,1].
So the total number of operations for the first query is 2 + 5 + 7 = 14.
For the second query we can do the following operations:
- Increase nums[0] 2 times, so that nums = [5,1,6,8].
- Increase nums[1] 4 times, so that nums = [5,5,6,8].
- Decrease nums[2] 1 time, so that nums = [5,5,5,8].
- Decrease nums[3] 3 times, so that nums = [5,5,5,5].
So the total number of operations for the second query is 2 + 4 + 1 + 3 = 10.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,9,6,3], queries = [10]
<strong>Output:</strong> [20]
<strong>Explanation:</strong> We can increase each value in the array to 10. The total number of operations will be 8 + 1 + 4 + 7 = 20.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>m == queries.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], queries[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {
        
    }
};","class Solution {
    public List<Long> minOperations(int[] nums, int[] queries) {
        
    }
}","class Solution(object):
    def minOperations(self, nums, queries):
        """"""
        :type nums: List[int]
        :type queries: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
long long* minOperations(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize){

}","public class Solution {
    public IList<long> MinOperations(int[] nums, int[] queries) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number[]} queries
 * @return {number[]}
 */
var minOperations = function(nums, queries) {
    
};","# @param {Integer[]} nums
# @param {Integer[]} queries
# @return {Integer[]}
def min_operations(nums, queries)
    
end","class Solution {
    func minOperations(_ nums: [Int], _ queries: [Int]) -> [Int] {
        
    }
}","func minOperations(nums []int, queries []int) []int64 {
    
}","object Solution {
    def minOperations(nums: Array[Int], queries: Array[Int]): List[Long] = {
        
    }
}","class Solution {
    fun minOperations(nums: IntArray, queries: IntArray): List<Long> {
        
    }
}","impl Solution {
    pub fn min_operations(nums: Vec<i32>, queries: Vec<i32>) -> Vec<i64> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer[] $queries
     * @return Integer[]
     */
    function minOperations($nums, $queries) {
        
    }
}","function minOperations(nums: number[], queries: number[]): number[] {

};","(define/contract (min-operations nums queries)
  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?))

  )","-spec min_operations(Nums :: [integer()], Queries :: [integer()]) -> [integer()].
min_operations(Nums, Queries) ->
  .","defmodule Solution do
  @spec min_operations(nums :: [integer], queries :: [integer]) :: [integer]
  def min_operations(nums, queries) do

  end
end","class Solution {
  List<int> minOperations(List<int> nums, List<int> queries) {

  }
}",
collect-coins-in-a-tree,Collect Coins in a Tree,2603.0,2717.0,"<p>There exists an undirected and unrooted tree with <code>n</code> nodes indexed from <code>0</code> to <code>n - 1</code>. You are given an integer <code>n</code> and a 2D integer array edges of length <code>n - 1</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree. You are also given&nbsp;an array <code>coins</code> of size <code>n</code> where <code>coins[i]</code> can be either <code>0</code> or <code>1</code>, where <code>1</code> indicates the presence of a coin in the vertex <code>i</code>.</p>

<p>Initially, you choose to start at any vertex in&nbsp;the tree.&nbsp;Then, you can perform&nbsp;the following operations any number of times:&nbsp;</p>

<ul>
	<li>Collect all the coins that are at a distance of at most <code>2</code> from the current vertex, or</li>
	<li>Move to any adjacent vertex in the tree.</li>
</ul>

<p>Find <em>the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex</em>.</p>

<p>Note that if you pass an edge several times, you need to count it into the answer several times.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/03/01/graph-2.png"" style=""width: 522px; height: 522px;"" />
<pre>
<strong>Input:</strong> coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/03/02/graph-4.png"" style=""width: 522px; height: 522px;"" />
<pre>
<strong>Input:</strong> coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == coins.length</code></li>
	<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= coins[i] &lt;= 1</code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
</ul>
",3.0,False,"class Solution {
public:
    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {
        
    }
};","class Solution {
    public int collectTheCoins(int[] coins, int[][] edges) {
        
    }
}","class Solution(object):
    def collectTheCoins(self, coins, edges):
        """"""
        :type coins: List[int]
        :type edges: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:
        ","int collectTheCoins(int* coins, int coinsSize, int** edges, int edgesSize, int* edgesColSize){

}","public class Solution {
    public int CollectTheCoins(int[] coins, int[][] edges) {
        
    }
}","/**
 * @param {number[]} coins
 * @param {number[][]} edges
 * @return {number}
 */
var collectTheCoins = function(coins, edges) {
    
};","# @param {Integer[]} coins
# @param {Integer[][]} edges
# @return {Integer}
def collect_the_coins(coins, edges)
    
end","class Solution {
    func collectTheCoins(_ coins: [Int], _ edges: [[Int]]) -> Int {
        
    }
}","func collectTheCoins(coins []int, edges [][]int) int {
    
}","object Solution {
    def collectTheCoins(coins: Array[Int], edges: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun collectTheCoins(coins: IntArray, edges: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn collect_the_coins(coins: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $coins
     * @param Integer[][] $edges
     * @return Integer
     */
    function collectTheCoins($coins, $edges) {
        
    }
}","function collectTheCoins(coins: number[], edges: number[][]): number {

};","(define/contract (collect-the-coins coins edges)
  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)

  )","-spec collect_the_coins(Coins :: [integer()], Edges :: [[integer()]]) -> integer().
collect_the_coins(Coins, Edges) ->
  .","defmodule Solution do
  @spec collect_the_coins(coins :: [integer], edges :: [[integer]]) :: integer
  def collect_the_coins(coins, edges) do

  end
end","class Solution {
  int collectTheCoins(List<int> coins, List<List<int>> edges) {

  }
}",
prime-subtraction-operation,Prime Subtraction Operation,2601.0,2716.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code>.</p>

<p>You can perform the following operation as many times as you want:</p>

<ul>
	<li>Pick an index <code>i</code> that you haven&rsquo;t picked before, and pick a prime <code>p</code> <strong>strictly less than</strong> <code>nums[i]</code>, then subtract <code>p</code> from <code>nums[i]</code>.</li>
</ul>

<p>Return <em>true if you can make <code>nums</code> a strictly increasing array using the above operation and false otherwise.</em></p>

<p>A <strong>strictly increasing array</strong> is an array whose each element is strictly greater than its preceding element.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,9,6,10]
<strong>Output:</strong> true
<strong>Explanation:</strong> In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10].
In the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10].
After the second operation, nums is sorted in strictly increasing order, so the answer is true.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,8,11,12]
<strong>Output:</strong> true
<strong>Explanation: </strong>Initially nums is sorted in strictly increasing order, so we don&#39;t need to make any operations.</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,8,3]
<strong>Output:</strong> false
<strong>Explanation:</strong> It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
	<li><code><font face=""monospace"">nums.length == n</font></code></li>
</ul>
",2.0,False,"class Solution {
public:
    bool primeSubOperation(vector<int>& nums) {
        
    }
};","class Solution {
    public boolean primeSubOperation(int[] nums) {
        
    }
}","class Solution(object):
    def primeSubOperation(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        ","class Solution:
    def primeSubOperation(self, nums: List[int]) -> bool:
        ","bool primeSubOperation(int* nums, int numsSize){

}","public class Solution {
    public bool PrimeSubOperation(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {boolean}
 */
var primeSubOperation = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Boolean}
def prime_sub_operation(nums)
    
end","class Solution {
    func primeSubOperation(_ nums: [Int]) -> Bool {
        
    }
}","func primeSubOperation(nums []int) bool {
    
}","object Solution {
    def primeSubOperation(nums: Array[Int]): Boolean = {
        
    }
}","class Solution {
    fun primeSubOperation(nums: IntArray): Boolean {
        
    }
}","impl Solution {
    pub fn prime_sub_operation(nums: Vec<i32>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Boolean
     */
    function primeSubOperation($nums) {
        
    }
}","function primeSubOperation(nums: number[]): boolean {

};","(define/contract (prime-sub-operation nums)
  (-> (listof exact-integer?) boolean?)

  )","-spec prime_sub_operation(Nums :: [integer()]) -> boolean().
prime_sub_operation(Nums) ->
  .","defmodule Solution do
  @spec prime_sub_operation(nums :: [integer]) :: boolean
  def prime_sub_operation(nums) do

  end
end","class Solution {
  bool primeSubOperation(List<int> nums) {

  }
}",
k-items-with-the-maximum-sum,K Items With the Maximum Sum,2600.0,2715.0,"<p>There is a bag that consists of items, each item&nbsp;has a number <code>1</code>, <code>0</code>, or <code>-1</code> written on it.</p>

<p>You are given four <strong>non-negative </strong>integers <code>numOnes</code>, <code>numZeros</code>, <code>numNegOnes</code>, and <code>k</code>.</p>

<p>The bag initially contains:</p>

<ul>
	<li><code>numOnes</code> items with <code>1</code>s written on them.</li>
	<li><code>numZeroes</code> items with <code>0</code>s written on them.</li>
	<li><code>numNegOnes</code> items with <code>-1</code>s written on them.</li>
</ul>

<p>We want to pick exactly <code>k</code> items among the available items. Return <em>the <strong>maximum</strong> possible sum of numbers written on the items</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 2 items with 1 written on them and get a sum in a total of 2.
It can be proven that 2 is the maximum possible sum.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4
<strong>Output:</strong> 3
<strong>Explanation:</strong> We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 3 items with 1 written on them, and 1 item with 0 written on it, and get a sum in a total of 3.
It can be proven that 3 is the maximum possible sum.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= numOnes, numZeros, numNegOnes &lt;= 50</code></li>
	<li><code>0 &lt;= k &lt;= numOnes + numZeros + numNegOnes</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {
        
    }
};","class Solution {
    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {
        
    }
}","class Solution(object):
    def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k):
        """"""
        :type numOnes: int
        :type numZeros: int
        :type numNegOnes: int
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:
        ","int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){

}","public class Solution {
    public int KItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {
        
    }
}","/**
 * @param {number} numOnes
 * @param {number} numZeros
 * @param {number} numNegOnes
 * @param {number} k
 * @return {number}
 */
var kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {
    
};","# @param {Integer} num_ones
# @param {Integer} num_zeros
# @param {Integer} num_neg_ones
# @param {Integer} k
# @return {Integer}
def k_items_with_maximum_sum(num_ones, num_zeros, num_neg_ones, k)
    
end","class Solution {
    func kItemsWithMaximumSum(_ numOnes: Int, _ numZeros: Int, _ numNegOnes: Int, _ k: Int) -> Int {
        
    }
}","func kItemsWithMaximumSum(numOnes int, numZeros int, numNegOnes int, k int) int {
    
}","object Solution {
    def kItemsWithMaximumSum(numOnes: Int, numZeros: Int, numNegOnes: Int, k: Int): Int = {
        
    }
}","class Solution {
    fun kItemsWithMaximumSum(numOnes: Int, numZeros: Int, numNegOnes: Int, k: Int): Int {
        
    }
}","impl Solution {
    pub fn k_items_with_maximum_sum(num_ones: i32, num_zeros: i32, num_neg_ones: i32, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $numOnes
     * @param Integer $numZeros
     * @param Integer $numNegOnes
     * @param Integer $k
     * @return Integer
     */
    function kItemsWithMaximumSum($numOnes, $numZeros, $numNegOnes, $k) {
        
    }
}","function kItemsWithMaximumSum(numOnes: number, numZeros: number, numNegOnes: number, k: number): number {

};","(define/contract (k-items-with-maximum-sum numOnes numZeros numNegOnes k)
  (-> exact-integer? exact-integer? exact-integer? exact-integer? exact-integer?)

  )","-spec k_items_with_maximum_sum(NumOnes :: integer(), NumZeros :: integer(), NumNegOnes :: integer(), K :: integer()) -> integer().
k_items_with_maximum_sum(NumOnes, NumZeros, NumNegOnes, K) ->
  .","defmodule Solution do
  @spec k_items_with_maximum_sum(num_ones :: integer, num_zeros :: integer, num_neg_ones :: integer, k :: integer) :: integer
  def k_items_with_maximum_sum(num_ones, num_zeros, num_neg_ones, k) do

  end
end","class Solution {
  int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {

  }
}",
left-and-right-sum-differences,Left and Right Sum Differences,2574.0,2714.0,"<p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, find a <strong>0-indexed </strong>integer array <code>answer</code> where:</p>

<ul>
    <li><code>answer.length == nums.length</code>.</li>
    <li><code>answer[i] = |leftSum[i] - rightSum[i]|</code>.</li>
</ul>

<p>Where:</p>

<ul>
    <li><code>leftSum[i]</code> is the sum of elements to the left of the index <code>i</code> in the array <code>nums</code>. If there is no such element, <code>leftSum[i] = 0</code>.</li>
    <li><code>rightSum[i]</code> is the sum of elements to the right of the index <code>i</code> in the array <code>nums</code>. If there is no such element, <code>rightSum[i] = 0</code>.</li>
</ul>

<p>Return <em>the array</em> <code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,4,8,3]
<strong>Output:</strong> [15,1,11,22]
<strong>Explanation:</strong> The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0].
The array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1]
<strong>Output:</strong> [0]
<strong>Explanation:</strong> The array leftSum is [0] and the array rightSum is [0].
The array answer is [|0 - 0|] = [0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
",1.0,False,"class Solution {
public:
    vector<int> leftRightDifference(vector<int>& nums) {
        
    }
};","class Solution {
    public int[] leftRightDifference(int[] nums) {
        
    }
}","class Solution(object):
    def leftRightDifference(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def leftRightDifference(self, nums: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* leftRightDifference(int* nums, int numsSize, int* returnSize){

}","public class Solution {
    public int[] LeftRightDifference(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number[]}
 */
var leftRightDifference = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer[]}
def left_right_difference(nums)
    
end","class Solution {
    func leftRightDifference(_ nums: [Int]) -> [Int] {
        
    }
}","func leftRightDifference(nums []int) []int {
    
}","object Solution {
    def leftRightDifference(nums: Array[Int]): Array[Int] = {
        
    }
}","class Solution {
    fun leftRightDifference(nums: IntArray): IntArray {
        
    }
}","impl Solution {
    pub fn left_right_difference(nums: Vec<i32>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function leftRightDifference($nums) {
        
    }
}","function leftRightDifference(nums: number[]): number[] {

};","(define/contract (left-right-difference nums)
  (-> (listof exact-integer?) (listof exact-integer?))

  )","-spec left_right_difference(Nums :: [integer()]) -> [integer()].
left_right_difference(Nums) ->
  .","defmodule Solution do
  @spec left_right_difference(nums :: [integer]) :: [integer]
  def left_right_difference(nums) do

  end
end","class Solution {
  List<int> leftRightDifference(List<int> nums) {

  }
}",
find-the-divisibility-array-of-a-string,Find the Divisibility Array of a String,2575.0,2713.0,"<p>You are given a <strong>0-indexed</strong> string <code>word</code> of length <code>n</code>&nbsp;consisting of digits, and a positive integer&nbsp;<code>m</code>.</p>

<p>The <strong>divisibility array</strong> <code>div</code> of <code>word</code> is an integer array of length <code>n</code> such that:</p>

<ul>
	<li><code>div[i] = 1</code> if the&nbsp;<strong>numeric value</strong>&nbsp;of&nbsp;<code>word[0,...,i]</code> is divisible by <code>m</code>, or</li>
	<li><code>div[i] = 0</code> otherwise.</li>
</ul>

<p>Return<em> the divisibility array of</em><em> </em><code>word</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;998244353&quot;, m = 3
<strong>Output:</strong> [1,1,0,0,0,1,1,0,0]
<strong>Explanation:</strong> There are only 4 prefixes that are divisible by 3: &quot;9&quot;, &quot;99&quot;, &quot;998244&quot;, and &quot;9982443&quot;.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;1010&quot;, m = 10
<strong>Output:</strong> [0,1,0,1]
<strong>Explanation:</strong> There are only 2 prefixes that are divisible by 10: &quot;10&quot;, and &quot;1010&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code><font face=""monospace"">word.length == n</font></code></li>
	<li><code><font face=""monospace"">word</font></code><font face=""monospace""> consists of digits from <code>0</code>&nbsp;to <code>9</code></font></li>
	<li><code><font face=""monospace"">1 &lt;= m &lt;= 10<sup>9</sup></font></code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<int> divisibilityArray(string word, int m) {
        
    }
};","class Solution {
    public int[] divisibilityArray(String word, int m) {
        
    }
}","class Solution(object):
    def divisibilityArray(self, word, m):
        """"""
        :type word: str
        :type m: int
        :rtype: List[int]
        """"""
        ","class Solution:
    def divisibilityArray(self, word: str, m: int) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* divisibilityArray(char * word, int m, int* returnSize){

}","public class Solution {
    public int[] DivisibilityArray(string word, int m) {
        
    }
}","/**
 * @param {string} word
 * @param {number} m
 * @return {number[]}
 */
var divisibilityArray = function(word, m) {
    
};","# @param {String} word
# @param {Integer} m
# @return {Integer[]}
def divisibility_array(word, m)
    
end","class Solution {
    func divisibilityArray(_ word: String, _ m: Int) -> [Int] {
        
    }
}","func divisibilityArray(word string, m int) []int {
    
}","object Solution {
    def divisibilityArray(word: String, m: Int): Array[Int] = {
        
    }
}","class Solution {
    fun divisibilityArray(word: String, m: Int): IntArray {
        
    }
}","impl Solution {
    pub fn divisibility_array(word: String, m: i32) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param String $word
     * @param Integer $m
     * @return Integer[]
     */
    function divisibilityArray($word, $m) {
        
    }
}","function divisibilityArray(word: string, m: number): number[] {

};","(define/contract (divisibility-array word m)
  (-> string? exact-integer? (listof exact-integer?))

  )","-spec divisibility_array(Word :: unicode:unicode_binary(), M :: integer()) -> [integer()].
divisibility_array(Word, M) ->
  .","defmodule Solution do
  @spec divisibility_array(word :: String.t, m :: integer) :: [integer]
  def divisibility_array(word, m) do

  end
end","class Solution {
  List<int> divisibilityArray(String word, int m) {

  }
}",
find-the-maximum-number-of-marked-indices,Find the Maximum Number of Marked Indices,2576.0,2712.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>

<p>Initially, all of the indices are unmarked. You are allowed to make this operation any number of times:</p>

<ul>
	<li>Pick two <strong>different unmarked</strong> indices <code>i</code> and <code>j</code> such that <code>2 * nums[i] &lt;= nums[j]</code>, then mark <code>i</code> and <code>j</code>.</li>
</ul>

<p>Return <em>the maximum possible number of marked indices in <code>nums</code> using the above operation any number of times</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,5,2,4]
<strong>Output:</strong> 2
<strong>Explanation: </strong>In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] &lt;= nums[1]. Then mark index 2 and 1.
It can be shown that there&#39;s no other valid operation so the answer is 2.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [9,2,5,4]
<strong>Output:</strong> 4
<strong>Explanation: </strong>In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] &lt;= nums[0]. Then mark index 3 and 0.
In the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] &lt;= nums[2]. Then mark index 1 and 2.
Since there is no other operation, the answer is 4.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,6,8]
<strong>Output:</strong> 0
<strong>Explanation: </strong>There is no valid operation to do, so the answer is 0.

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<style type=""text/css"">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value=""Show Message""] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value=""Hide Message""] + .spoiler {padding:5px;}
</style>
",2.0,False,"class Solution {
public:
    int maxNumOfMarkedIndices(vector<int>& nums) {
        
    }
};","class Solution {
    public int maxNumOfMarkedIndices(int[] nums) {
        
    }
}","class Solution(object):
    def maxNumOfMarkedIndices(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:
        ","int maxNumOfMarkedIndices(int* nums, int numsSize){

}","public class Solution {
    public int MaxNumOfMarkedIndices(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var maxNumOfMarkedIndices = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def max_num_of_marked_indices(nums)
    
end","class Solution {
    func maxNumOfMarkedIndices(_ nums: [Int]) -> Int {
        
    }
}","func maxNumOfMarkedIndices(nums []int) int {
    
}","object Solution {
    def maxNumOfMarkedIndices(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxNumOfMarkedIndices(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_num_of_marked_indices(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maxNumOfMarkedIndices($nums) {
        
    }
}","function maxNumOfMarkedIndices(nums: number[]): number {

};","(define/contract (max-num-of-marked-indices nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec max_num_of_marked_indices(Nums :: [integer()]) -> integer().
max_num_of_marked_indices(Nums) ->
  .","defmodule Solution do
  @spec max_num_of_marked_indices(nums :: [integer]) :: integer
  def max_num_of_marked_indices(nums) do

  end
end","class Solution {
  int maxNumOfMarkedIndices(List<int> nums) {

  }
}",
minimum-time-to-visit-a-cell-in-a-grid,Minimum Time to Visit a Cell In a Grid,2577.0,2711.0,"<p>You are given a <code>m x n</code> matrix <code>grid</code> consisting of <b>non-negative</b> integers where <code>grid[row][col]</code> represents the <strong>minimum</strong> time required to be able to visit the cell <code>(row, col)</code>, which means you can visit the cell <code>(row, col)</code> only when the time you visit it is greater than or equal to <code>grid[row][col]</code>.</p>

<p>You are standing in the <strong>top-left</strong> cell of the matrix in the <code>0<sup>th</sup></code> second, and you must move to <strong>any</strong> adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.</p>

<p>Return <em>the <strong>minimum</strong> time required in which you can visit the bottom-right cell of the matrix</em>. If you cannot visit the bottom-right cell, then return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<p><img alt="""" src=""https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png"" /></p>

<pre>
<strong>Input:</strong> grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> One of the paths that we can take is the following:
- at t = 0, we are on the cell (0,0).
- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] &lt;= 1.
- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 2.
- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 3.
- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 4.
- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 5.
- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] &lt;= 6.
- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] &lt;= 7.
The final time is 7. It can be shown that it is the minimum time possible.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<p><img alt="""" src=""https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png"" style=""width: 151px; height: 151px;"" /></p>

<pre>
<strong>Input:</strong> grid = [[0,2,4],[3,2,1],[1,0,4]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no path from the top left to the bottom-right cell.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[0][0] == 0</code></li>
</ul>

<p>&nbsp;</p>
<style type=""text/css"">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value=""Show Message""] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value=""Hide Message""] + .spoiler {padding:5px;}
</style>
",3.0,False,"class Solution {
public:
    int minimumTime(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int minimumTime(int[][] grid) {
        
    }
}","class Solution(object):
    def minimumTime(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minimumTime(self, grid: List[List[int]]) -> int:
        ","int minimumTime(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int MinimumTime(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var minimumTime = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def minimum_time(grid)
    
end","class Solution {
    func minimumTime(_ grid: [[Int]]) -> Int {
        
    }
}","func minimumTime(grid [][]int) int {
    
}","object Solution {
    def minimumTime(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun minimumTime(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn minimum_time(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function minimumTime($grid) {
        
    }
}","function minimumTime(grid: number[][]): number {

};","(define/contract (minimum-time grid)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec minimum_time(Grid :: [[integer()]]) -> integer().
minimum_time(Grid) ->
  .","defmodule Solution do
  @spec minimum_time(grid :: [[integer]]) :: integer
  def minimum_time(grid) do

  end
end","class Solution {
  int minimumTime(List<List<int>> grid) {

  }
}",
minimum-operations-to-reduce-an-integer-to-0,Minimum Operations to Reduce an Integer to 0,2571.0,2710.0,"<p>You are given a positive integer <code>n</code>, you can do the following operation <strong>any</strong> number of times:</p>

<ul>
	<li>Add or subtract a <strong>power</strong> of <code>2</code> from <code>n</code>.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> number of operations to make </em><code>n</code><em> equal to </em><code>0</code>.</p>

<p>A number <code>x</code> is power of <code>2</code> if <code>x == 2<sup>i</sup></code>&nbsp;where <code>i &gt;= 0</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 39
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can do the following operations:
- Add 2<sup>0</sup> = 1 to n, so now n = 40.
- Subtract 2<sup>3</sup> = 8 from n, so now n = 32.
- Subtract 2<sup>5</sup> = 32 from n, so now n = 0.
It can be shown that 3 is the minimum number of operations we need to make n equal to 0.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 54
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can do the following operations:
- Add 2<sup>1</sup> = 2 to n, so now n = 56.
- Add 2<sup>3</sup> = 8 to n, so now n = 64.
- Subtract 2<sup>6</sup> = 64 from n, so now n = 0.
So the minimum number of operations is 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int minOperations(int n) {
        
    }
};","class Solution {
    public int minOperations(int n) {
        
    }
}","class Solution(object):
    def minOperations(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def minOperations(self, n: int) -> int:
        ","int minOperations(int n){

}","public class Solution {
    public int MinOperations(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var minOperations = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def min_operations(n)
    
end","class Solution {
    func minOperations(_ n: Int) -> Int {
        
    }
}","func minOperations(n int) int {
    
}","object Solution {
    def minOperations(n: Int): Int = {
        
    }
}","class Solution {
    fun minOperations(n: Int): Int {
        
    }
}","impl Solution {
    pub fn min_operations(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function minOperations($n) {
        
    }
}","function minOperations(n: number): number {

};","(define/contract (min-operations n)
  (-> exact-integer? exact-integer?)

  )","-spec min_operations(N :: integer()) -> integer().
min_operations(N) ->
  .","defmodule Solution do
  @spec min_operations(n :: integer) :: integer
  def min_operations(n) do

  end
end","class Solution {
  int minOperations(int n) {

  }
}",
count-the-number-of-square-free-subsets,Count the Number of Square-Free Subsets,2572.0,2709.0,"<p>You are given a positive integer <strong>0-indexed</strong>&nbsp;array <code>nums</code>.</p>

<p>A subset of the array <code>nums</code> is <strong>square-free</strong> if the product of its elements is a <strong>square-free integer</strong>.</p>

<p>A <strong>square-free integer</strong> is an integer that is divisible by no square number other than <code>1</code>.</p>

<p>Return <em>the number of square-free non-empty subsets of the array</em> <strong>nums</strong>. Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>A <strong>non-empty</strong>&nbsp;<strong>subset</strong> of <code>nums</code> is an array that can be obtained by deleting some (possibly none but not all) elements from <code>nums</code>. Two subsets are different if and only if the chosen indices to delete are different.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,4,4,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 square-free subsets in this example:
- The subset consisting of the 0<sup>th</sup> element [3]. The product of its elements is 3, which is a square-free integer.
- The subset consisting of the 3<sup>rd</sup> element [5]. The product of its elements is 5, which is a square-free integer.
- The subset consisting of 0<sup>th</sup> and 3<sup>rd</sup> elements [3,5]. The product of its elements is 15, which is a square-free integer.
It can be proven that there are no more than 3 square-free subsets in the given array.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is 1 square-free subset in this example:
- The subset consisting of the 0<sup>th</sup> element [1]. The product of its elements is 1, which is a square-free integer.
It can be proven that there is no more than 1 square-free subset in the given array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length&nbsp;&lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 30</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int squareFreeSubsets(vector<int>& nums) {
        
    }
};","class Solution {
    public int squareFreeSubsets(int[] nums) {
        
    }
}","class Solution(object):
    def squareFreeSubsets(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def squareFreeSubsets(self, nums: List[int]) -> int:
        ","int squareFreeSubsets(int* nums, int numsSize){

}","public class Solution {
    public int SquareFreeSubsets(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var squareFreeSubsets = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def square_free_subsets(nums)
    
end","class Solution {
    func squareFreeSubsets(_ nums: [Int]) -> Int {
        
    }
}","func squareFreeSubsets(nums []int) int {
    
}","object Solution {
    def squareFreeSubsets(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun squareFreeSubsets(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn square_free_subsets(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function squareFreeSubsets($nums) {
        
    }
}","function squareFreeSubsets(nums: number[]): number {

};","(define/contract (square-free-subsets nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec square_free_subsets(Nums :: [integer()]) -> integer().
square_free_subsets(Nums) ->
  .","defmodule Solution do
  @spec square_free_subsets(nums :: [integer]) :: integer
  def square_free_subsets(nums) do

  end
end","class Solution {
  int squareFreeSubsets(List<int> nums) {

  }
}",
find-the-string-with-lcp,Find the String with LCP,2573.0,2708.0,"<p>We define the <code>lcp</code> matrix of any <strong>0-indexed</strong> string <code>word</code> of <code>n</code> lowercase English letters as an <code>n x n</code> grid such that:</p>

<ul>
	<li><code>lcp[i][j]</code> is equal to the length of the <strong>longest common prefix</strong> between the substrings <code>word[i,n-1]</code> and <code>word[j,n-1]</code>.</li>
</ul>

<p>Given an&nbsp;<code>n x n</code> matrix <code>lcp</code>, return the alphabetically smallest string <code>word</code> that corresponds to <code>lcp</code>. If there is no such string, return an empty string.</p>

<p>A string <code>a</code> is lexicographically smaller than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears earlier in the alphabet than the corresponding letter in <code>b</code>. For example, <code>&quot;aabd&quot;</code> is lexicographically smaller than <code>&quot;aaca&quot;</code> because the first position they differ is at the third letter, and <code>&#39;b&#39;</code> comes before <code>&#39;c&#39;</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]
<strong>Output:</strong> &quot;abab&quot;
<strong>Explanation:</strong> lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is &quot;abab&quot;.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]
<strong>Output:</strong> &quot;aaaa&quot;
<strong>Explanation:</strong> lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is &quot;aaaa&quot;. 
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n ==&nbsp;</code><code>lcp.length == </code><code>lcp[i].length</code>&nbsp;<code>&lt;= 1000</code></li>
	<li><code><font face=""monospace"">0 &lt;= lcp[i][j] &lt;= n</font></code></li>
</ul>
",3.0,False,"class Solution {
public:
    string findTheString(vector<vector<int>>& lcp) {
        
    }
};","class Solution {
    public String findTheString(int[][] lcp) {
        
    }
}","class Solution(object):
    def findTheString(self, lcp):
        """"""
        :type lcp: List[List[int]]
        :rtype: str
        """"""
        ","class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        ","char * findTheString(int** lcp, int lcpSize, int* lcpColSize){

}","public class Solution {
    public string FindTheString(int[][] lcp) {
        
    }
}","/**
 * @param {number[][]} lcp
 * @return {string}
 */
var findTheString = function(lcp) {
    
};","# @param {Integer[][]} lcp
# @return {String}
def find_the_string(lcp)
    
end","class Solution {
    func findTheString(_ lcp: [[Int]]) -> String {
        
    }
}","func findTheString(lcp [][]int) string {
    
}","object Solution {
    def findTheString(lcp: Array[Array[Int]]): String = {
        
    }
}","class Solution {
    fun findTheString(lcp: Array<IntArray>): String {
        
    }
}","impl Solution {
    pub fn find_the_string(lcp: Vec<Vec<i32>>) -> String {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $lcp
     * @return String
     */
    function findTheString($lcp) {
        
    }
}","function findTheString(lcp: number[][]): string {

};","(define/contract (find-the-string lcp)
  (-> (listof (listof exact-integer?)) string?)

  )","-spec find_the_string(Lcp :: [[integer()]]) -> unicode:unicode_binary().
find_the_string(Lcp) ->
  .","defmodule Solution do
  @spec find_the_string(lcp :: [[integer]]) :: String.t
  def find_the_string(lcp) do

  end
end","class Solution {
  String findTheString(List<List<int>> lcp) {

  }
}",
merge-two-2d-arrays-by-summing-values,Merge Two 2D Arrays by Summing Values,2570.0,2707.0,"<p>You are given two <strong>2D</strong> integer arrays <code>nums1</code> and <code>nums2.</code></p>

<ul>
	<li><code>nums1[i] = [id<sub>i</sub>, val<sub>i</sub>]</code>&nbsp;indicate that the number with the id <code>id<sub>i</sub></code> has a value equal to <code>val<sub>i</sub></code>.</li>
	<li><code>nums2[i] = [id<sub>i</sub>, val<sub>i</sub>]</code>&nbsp;indicate that the number with the id <code>id<sub>i</sub></code> has a value equal to <code>val<sub>i</sub></code>.</li>
</ul>

<p>Each array contains <strong>unique</strong> ids and is sorted in <strong>ascending</strong> order by id.</p>

<p>Merge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:</p>

<ul>
	<li>Only ids that appear in at least one of the two arrays should be included in the resulting array.</li>
	<li>Each id should be included <strong>only once</strong> and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be <code>0</code>.</li>
</ul>

<p>Return <em>the resulting array</em>. The returned array must be sorted in ascending order by id.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]
<strong>Output:</strong> [[1,6],[2,3],[3,2],[4,6]]
<strong>Explanation:</strong> The resulting array contains the following:
- id = 1, the value of this id is 2 + 4 = 6.
- id = 2, the value of this id is 3.
- id = 3, the value of this id is 2.
- id = 4, the value of this id is 5 + 1 = 6.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]
<strong>Output:</strong> [[1,3],[2,4],[3,6],[4,3],[5,5]]
<strong>Explanation:</strong> There are no common ids, so we just include each id with its value in the resulting list.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 200</code></li>
	<li><code>nums1[i].length == nums2[j].length == 2</code></li>
	<li><code>1 &lt;= id<sub>i</sub>, val<sub>i</sub> &lt;= 1000</code></li>
	<li>Both arrays contain unique ids.</li>
	<li>Both arrays are in&nbsp;strictly ascending order by id.</li>
</ul>
",1.0,False,"class Solution {
public:
    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {
        
    }
};","class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        
    }
}","class Solution(object):
    def mergeArrays(self, nums1, nums2):
        """"""
        :type nums1: List[List[int]]
        :type nums2: List[List[int]]
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** mergeArrays(int** nums1, int nums1Size, int* nums1ColSize, int** nums2, int nums2Size, int* nums2ColSize, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public int[][] MergeArrays(int[][] nums1, int[][] nums2) {
        
    }
}","/**
 * @param {number[][]} nums1
 * @param {number[][]} nums2
 * @return {number[][]}
 */
var mergeArrays = function(nums1, nums2) {
    
};","# @param {Integer[][]} nums1
# @param {Integer[][]} nums2
# @return {Integer[][]}
def merge_arrays(nums1, nums2)
    
end","class Solution {
    func mergeArrays(_ nums1: [[Int]], _ nums2: [[Int]]) -> [[Int]] {
        
    }
}","func mergeArrays(nums1 [][]int, nums2 [][]int) [][]int {
    
}","object Solution {
    def mergeArrays(nums1: Array[Array[Int]], nums2: Array[Array[Int]]): Array[Array[Int]] = {
        
    }
}","class Solution {
    fun mergeArrays(nums1: Array<IntArray>, nums2: Array<IntArray>): Array<IntArray> {
        
    }
}","impl Solution {
    pub fn merge_arrays(nums1: Vec<Vec<i32>>, nums2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $nums1
     * @param Integer[][] $nums2
     * @return Integer[][]
     */
    function mergeArrays($nums1, $nums2) {
        
    }
}","function mergeArrays(nums1: number[][], nums2: number[][]): number[][] {

};","(define/contract (merge-arrays nums1 nums2)
  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)) (listof (listof exact-integer?)))

  )","-spec merge_arrays(Nums1 :: [[integer()]], Nums2 :: [[integer()]]) -> [[integer()]].
merge_arrays(Nums1, Nums2) ->
  .","defmodule Solution do
  @spec merge_arrays(nums1 :: [[integer]], nums2 :: [[integer]]) :: [[integer]]
  def merge_arrays(nums1, nums2) do

  end
end","class Solution {
  List<List<int>> mergeArrays(List<List<int>> nums1, List<List<int>> nums2) {

  }
}",
minimum-score-by-changing-two-elements,Minimum Score by Changing Two Elements,2567.0,2706.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>

<ul>
	<li>The <strong>low</strong> score of <code><font face=""monospace"">nums</font></code> is the minimum value of <code>|nums[i]&nbsp;- nums[j]|</code> over all <code>0 &lt;= i &lt; j &lt; nums.length</code>.</li>
	<li>The <strong>high</strong> score of&nbsp;<code><font face=""monospace"">nums</font></code> is the maximum value of <code>|nums[i]&nbsp;- nums[j]|</code> over all <code>0 &lt;= i &lt; j &lt; nums.length</code>.</li>
	<li>The <strong>score</strong> of <code>nums</code> is the sum of the <strong>high</strong> and <strong>low</strong> scores of nums.</li>
</ul>

<p>To minimize the score of <code>nums</code>, we can change the value of <strong>at most two</strong> elements of <code>nums</code>.</p>

<p>Return <em>the <strong>minimum</strong> possible <strong>score</strong> after changing&nbsp;the value of <strong>at most two</strong> elements o</em>f <code>nums</code>.</p>

<p>Note that <code>|x|</code> denotes the absolute value of <code>x</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Change value of nums[1] and nums[2] to 1 so that nums becomes [1,1,1]. Now, the value of <code>|nums[i] - nums[j]|</code> is always equal to 0, so we return 0 + 0 = 0.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,7,8,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Change nums[0] and nums[1] to be 6. Now nums becomes [6,6,7,8,5].
Our low score is achieved when i = 0 and j = 1, in which case |<code>nums[i] - nums[j]</code>| = |6 - 6| = 0.
Our high score is achieved when i = 3 and j = 4, in which case |<code>nums[i] - nums[j]</code>| = |8 - 5| = 3.
The sum of our high and low score is 3, which we can prove to be minimal.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int minimizeSum(vector<int>& nums) {
        
    }
};","class Solution {
    public int minimizeSum(int[] nums) {
        
    }
}","class Solution(object):
    def minimizeSum(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minimizeSum(self, nums: List[int]) -> int:
        ","int minimizeSum(int* nums, int numsSize){

}","public class Solution {
    public int MinimizeSum(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var minimizeSum = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def minimize_sum(nums)
    
end","class Solution {
    func minimizeSum(_ nums: [Int]) -> Int {
        
    }
}","func minimizeSum(nums []int) int {
    
}","object Solution {
    def minimizeSum(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minimizeSum(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn minimize_sum(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function minimizeSum($nums) {
        
    }
}","function minimizeSum(nums: number[]): number {

};","(define/contract (minimize-sum nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec minimize_sum(Nums :: [integer()]) -> integer().
minimize_sum(Nums) ->
  .","defmodule Solution do
  @spec minimize_sum(nums :: [integer]) :: integer
  def minimize_sum(nums) do

  end
end","class Solution {
  int minimizeSum(List<int> nums) {

  }
}",
minimum-impossible-or,Minimum Impossible OR,2568.0,2705.0,"<p>You are given a <strong>0-indexed</strong>&nbsp;integer array <code>nums</code>.</p>

<p>We say that an integer x is <strong>expressible</strong> from <code>nums</code> if there exist some integers <code>0 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt; ... &lt; index<sub>k</sub> &lt; nums.length</code> for which <code>nums[index<sub>1</sub>] | nums[index<sub>2</sub>] | ... | nums[index<sub>k</sub>] = x</code>. In other words, an integer is expressible if it can be written as the bitwise OR of some subsequence of <code>nums</code>.</p>

<p>Return <em>the minimum <strong>positive non-zero integer</strong>&nbsp;that is not </em><em>expressible from </em><code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> 1 and 2 are already present in the array. We know that 3 is expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is not expressible, we return 4.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,3,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can show that 1 is the smallest number that is not expressible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int minImpossibleOR(vector<int>& nums) {
        
    }
};","class Solution {
    public int minImpossibleOR(int[] nums) {
        
    }
}","class Solution(object):
    def minImpossibleOR(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minImpossibleOR(self, nums: List[int]) -> int:
        ","int minImpossibleOR(int* nums, int numsSize){

}","public class Solution {
    public int MinImpossibleOR(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var minImpossibleOR = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def min_impossible_or(nums)
    
end","class Solution {
    func minImpossibleOR(_ nums: [Int]) -> Int {
        
    }
}","func minImpossibleOR(nums []int) int {
    
}","object Solution {
    def minImpossibleOR(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minImpossibleOR(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn min_impossible_or(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function minImpossibleOR($nums) {
        
    }
}","function minImpossibleOR(nums: number[]): number {

};","(define/contract (min-impossible-or nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec min_impossible_or(Nums :: [integer()]) -> integer().
min_impossible_or(Nums) ->
  .","defmodule Solution do
  @spec min_impossible_or(nums :: [integer]) :: integer
  def min_impossible_or(nums) do

  end
end","class Solution {
  int minImpossibleOR(List<int> nums) {

  }
}",
maximum-difference-by-remapping-a-digit,Maximum Difference by Remapping a Digit,2566.0,2704.0,"<p>You are given an integer <code>num</code>. You know that Danny Mittal will sneakily <strong>remap</strong> one of the <code>10</code> possible digits (<code>0</code> to <code>9</code>) to another digit.</p>

<p>Return <em>the difference between the maximum and minimum</em><em>&nbsp;values Danny can make by remapping&nbsp;<strong>exactly</strong> <strong>one</strong> digit</em><em> in </em><code>num</code>.</p>

<p><strong>Notes:</strong></p>

<ul>
	<li>When Danny remaps a digit <font face=""monospace"">d1</font>&nbsp;to another digit <font face=""monospace"">d2</font>, Danny replaces all occurrences of <code>d1</code>&nbsp;in <code>num</code>&nbsp;with <code>d2</code>.</li>
	<li>Danny can remap a digit to itself, in which case <code>num</code>&nbsp;does not change.</li>
	<li>Danny can remap different digits for obtaining minimum and maximum values respectively.</li>
	<li>The resulting number after remapping can contain leading zeroes.</li>
	<li>We mentioned &quot;Danny Mittal&quot; to congratulate him on being in the top 10 in Weekly Contest 326.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre>
<strong>Input:</strong> num = 11891
<strong>Output:</strong> 99009
<strong>Explanation:</strong> 
To achieve the maximum value, Danny can remap the digit 1 to the digit 9 to yield 99899.
To achieve the minimum value, Danny can remap the digit 1 to the digit 0, yielding 890.
The difference between these two numbers is 99009.
</pre>

<p><strong>Example 2:</strong></p>

<pre>
<strong>Input:</strong> num = 90
<strong>Output:</strong> 99
<strong>Explanation:</strong>
The maximum value that can be returned by the function is 99 (if 0 is replaced by 9) and the minimum value that can be returned by the function is 0 (if 9 is replaced by 0).
Thus, we return 99.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= num &lt;= 10<sup>8</sup></code></li>
</ul>
",1.0,False,"class Solution {
public:
    int minMaxDifference(int num) {
        
    }
};","class Solution {
    public int minMaxDifference(int num) {
        
    }
}","class Solution(object):
    def minMaxDifference(self, num):
        """"""
        :type num: int
        :rtype: int
        """"""
        ","class Solution:
    def minMaxDifference(self, num: int) -> int:
        ","int minMaxDifference(int num){

}","public class Solution {
    public int MinMaxDifference(int num) {
        
    }
}","/**
 * @param {number} num
 * @return {number}
 */
var minMaxDifference = function(num) {
    
};","# @param {Integer} num
# @return {Integer}
def min_max_difference(num)
    
end","class Solution {
    func minMaxDifference(_ num: Int) -> Int {
        
    }
}","func minMaxDifference(num int) int {
    
}","object Solution {
    def minMaxDifference(num: Int): Int = {
        
    }
}","class Solution {
    fun minMaxDifference(num: Int): Int {
        
    }
}","impl Solution {
    pub fn min_max_difference(num: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $num
     * @return Integer
     */
    function minMaxDifference($num) {
        
    }
}","function minMaxDifference(num: number): number {

};","(define/contract (min-max-difference num)
  (-> exact-integer? exact-integer?)

  )","-spec min_max_difference(Num :: integer()) -> integer().
min_max_difference(Num) ->
  .","defmodule Solution do
  @spec min_max_difference(num :: integer) :: integer
  def min_max_difference(num) do

  end
end","class Solution {
  int minMaxDifference(int num) {

  }
}",
handling-sum-queries-after-update,Handling Sum Queries After Update,2569.0,2703.0,"<p>You are given two <strong>0-indexed</strong> arrays <code>nums1</code> and <code>nums2</code> and a 2D array <code>queries</code> of queries. There are three types of queries:</p>

<ol>
	<li>For a query of type 1, <code>queries[i]&nbsp;= [1, l, r]</code>. Flip the values from <code>0</code> to <code>1</code> and from <code>1</code> to <code>0</code> in <code>nums1 </code>from index <code>l</code> to index <code>r</code>. Both <code>l</code> and <code>r</code> are <strong>0-indexed</strong>.</li>
	<li>For a query of type 2, <code>queries[i]&nbsp;= [2, p, 0]</code>. For every index <code>0 &lt;= i &lt; n</code>, set&nbsp;<code>nums2[i] =&nbsp;nums2[i]&nbsp;+ nums1[i]&nbsp;* p</code>.</li>
	<li>For a query of type 3, <code>queries[i]&nbsp;= [3, 0, 0]</code>. Find the sum of the elements in <code>nums2</code>.</li>
</ol>

<p>Return <em>an array containing all the answers to the third type&nbsp;queries.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]
<strong>Output:</strong> [3]
<strong>Explanation:</strong> After the first query nums1 becomes [1,1,1]. After the second query, nums2 becomes [1,1,1], so the answer to the third query is 3. Thus, [3] is returned.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]
<strong>Output:</strong> [5]
<strong>Explanation:</strong> After the first query, nums2 remains [5], so the answer to the second query is 5. Thus, [5] is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length,nums2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>nums1.length = nums2.length</code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code><font face=""monospace"">queries[i].length = 3</font></code></li>
	<li><code><font face=""monospace"">0 &lt;= l &lt;= r &lt;= nums1.length - 1</font></code></li>
	<li><code><font face=""monospace"">0 &lt;= p &lt;= 10<sup>6</sup></font></code></li>
	<li><code>0 &lt;= nums1[i] &lt;= 1</code></li>
	<li><code>0 &lt;= nums2[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {
        
    }
};","class Solution {
    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {
        
    }
}","class Solution(object):
    def handleQuery(self, nums1, nums2, queries):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :type queries: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
long long* handleQuery(int* nums1, int nums1Size, int* nums2, int nums2Size, int** queries, int queriesSize, int* queriesColSize, int* returnSize){

}","public class Solution {
    public long[] HandleQuery(int[] nums1, int[] nums2, int[][] queries) {
        
    }
}","/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number[][]} queries
 * @return {number[]}
 */
var handleQuery = function(nums1, nums2, queries) {
    
};","# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @param {Integer[][]} queries
# @return {Integer[]}
def handle_query(nums1, nums2, queries)
    
end","class Solution {
    func handleQuery(_ nums1: [Int], _ nums2: [Int], _ queries: [[Int]]) -> [Int] {
        
    }
}","func handleQuery(nums1 []int, nums2 []int, queries [][]int) []int64 {
    
}","object Solution {
    def handleQuery(nums1: Array[Int], nums2: Array[Int], queries: Array[Array[Int]]): Array[Long] = {
        
    }
}","class Solution {
    fun handleQuery(nums1: IntArray, nums2: IntArray, queries: Array<IntArray>): LongArray {
        
    }
}","impl Solution {
    pub fn handle_query(nums1: Vec<i32>, nums2: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i64> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @param Integer[][] $queries
     * @return Integer[]
     */
    function handleQuery($nums1, $nums2, $queries) {
        
    }
}","function handleQuery(nums1: number[], nums2: number[], queries: number[][]): number[] {

};","(define/contract (handle-query nums1 nums2 queries)
  (-> (listof exact-integer?) (listof exact-integer?) (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec handle_query(Nums1 :: [integer()], Nums2 :: [integer()], Queries :: [[integer()]]) -> [integer()].
handle_query(Nums1, Nums2, Queries) ->
  .","defmodule Solution do
  @spec handle_query(nums1 :: [integer], nums2 :: [integer], queries :: [[integer]]) :: [integer]
  def handle_query(nums1, nums2, queries) do

  end
end","class Solution {
  List<int> handleQuery(List<int> nums1, List<int> nums2, List<List<int>> queries) {

  }
}",
subsequence-with-the-minimum-score,Subsequence With the Minimum Score,2565.0,2701.0,"<p>You are given two strings <code>s</code> and <code>t</code>.</p>

<p>You are allowed to remove any number of characters from the string <code>t</code>.</p>

<p>The score of the string is <code>0</code> if no characters are removed from the string <code>t</code>, otherwise:</p>

<ul>
	<li>Let <code>left</code> be the minimum index among all removed characters.</li>
	<li>Let <code>right</code> be the maximum index among all removed characters.</li>
</ul>

<p>Then the score of the string is <code>right - left + 1</code>.</p>

<p>Return <em>the minimum possible score to make </em><code>t</code><em>&nbsp;a subsequence of </em><code>s</code><em>.</em></p>

<p>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;<u>a</u>b<u>c</u>d<u>e</u>&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abacaba&quot;, t = &quot;bzaa&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> In this example, we remove the character &quot;z&quot; at index 1 (0-indexed).
The string t becomes &quot;baa&quot; which is a subsequence of the string &quot;abacaba&quot; and the score is 1 - 1 + 1 = 1.
It can be proven that 1 is the minimum score that we can achieve.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cde&quot;, t = &quot;xyz&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> In this example, we remove characters &quot;x&quot;, &quot;y&quot; and &quot;z&quot; at indices 0, 1, and 2 (0-indexed).
The string t becomes &quot;&quot; which is a subsequence of the string &quot;cde&quot; and the score is 2 - 0 + 1 = 3.
It can be proven that 3 is the minimum score that we can achieve.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> and <code>t</code> consist of only lowercase English letters.</li>
</ul>
",3.0,False,"class Solution {
public:
    int minimumScore(string s, string t) {
        
    }
};","class Solution {
    public int minimumScore(String s, String t) {
        
    }
}","class Solution(object):
    def minimumScore(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: int
        """"""
        ","class Solution:
    def minimumScore(self, s: str, t: str) -> int:
        ","int minimumScore(char * s, char * t){

}","public class Solution {
    public int MinimumScore(string s, string t) {
        
    }
}","/**
 * @param {string} s
 * @param {string} t
 * @return {number}
 */
var minimumScore = function(s, t) {
    
};","# @param {String} s
# @param {String} t
# @return {Integer}
def minimum_score(s, t)
    
end","class Solution {
    func minimumScore(_ s: String, _ t: String) -> Int {
        
    }
}","func minimumScore(s string, t string) int {
    
}","object Solution {
    def minimumScore(s: String, t: String): Int = {
        
    }
}","class Solution {
    fun minimumScore(s: String, t: String): Int {
        
    }
}","impl Solution {
    pub fn minimum_score(s: String, t: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param String $t
     * @return Integer
     */
    function minimumScore($s, $t) {
        
    }
}","function minimumScore(s: string, t: string): number {

};","(define/contract (minimum-score s t)
  (-> string? string? exact-integer?)

  )","-spec minimum_score(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> integer().
minimum_score(S, T) ->
  .","defmodule Solution do
  @spec minimum_score(s :: String.t, t :: String.t) :: integer
  def minimum_score(s, t) do

  end
end","class Solution {
  int minimumScore(String s, String t) {

  }
}",
substring-xor-queries,Substring XOR Queries,2564.0,2700.0,"<p>You are given a <strong>binary string</strong> <code>s</code>, and a <strong>2D</strong> integer array <code>queries</code> where <code>queries[i] = [first<sub>i</sub>, second<sub>i</sub>]</code>.</p>

<p>For the <code>i<sup>th</sup></code> query, find the <strong>shortest substring</strong> of <code>s</code> whose <strong>decimal value</strong>, <code>val</code>, yields <code>second<sub>i</sub></code> when <strong>bitwise XORed</strong> with <code>first<sub>i</sub></code>. In other words, <code>val ^ first<sub>i</sub> == second<sub>i</sub></code>.</p>

<p>The answer to the <code>i<sup>th</sup></code> query is the endpoints (<strong>0-indexed</strong>) of the substring <code>[left<sub>i</sub>, right<sub>i</sub>]</code> or <code>[-1, -1]</code> if no such substring exists. If there are multiple answers, choose the one with the <strong>minimum</strong> <code>left<sub>i</sub></code>.</p>

<p><em>Return an array</em> <code>ans</code> <em>where</em> <code>ans[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> <em>is the answer to the</em> <code>i<sup>th</sup></code> <em>query.</em></p>

<p>A <strong>substring</strong> is a contiguous non-empty sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;101101&quot;, queries = [[0,5],[1,2]]
<strong>Output:</strong> [[0,2],[2,3]]
<strong>Explanation:</strong> For the first query the substring in range <code>[0,2]</code> is <strong>&quot;101&quot;</strong> which has a decimal value of <strong><code>5</code></strong>, and <strong><code>5 ^ 0 = 5</code></strong>, hence the answer to the first query is <code>[0,2]</code>. In the second query, the substring in range <code>[2,3]</code> is <strong>&quot;11&quot;,</strong> and has a decimal value of <strong>3</strong>, and <strong>3<code> ^ 1 = 2</code></strong>.&nbsp;So, <code>[2,3]</code> is returned for the second query. 

</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;0101&quot;, queries = [[12,8]]
<strong>Output:</strong> [[-1,-1]]
<strong>Explanation:</strong> In this example there is no substring that answers the query, hence <code>[-1,-1] is returned</code>.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;1&quot;, queries = [[4,5]]
<strong>Output:</strong> [[0,0]]
<strong>Explanation:</strong> For this example, the substring in range <code>[0,0]</code> has a decimal value of <strong><code>1</code></strong>, and <strong><code>1 ^ 4 = 5</code></strong>. So, the answer is <code>[0,0]</code>.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= first<sub>i</sub>, second<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {
        
    }
};","class Solution {
    public int[][] substringXorQueries(String s, int[][] queries) {
        
    }
}","class Solution(object):
    def substringXorQueries(self, s, queries):
        """"""
        :type s: str
        :type queries: List[List[int]]
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public int[][] SubstringXorQueries(string s, int[][] queries) {
        
    }
}","/**
 * @param {string} s
 * @param {number[][]} queries
 * @return {number[][]}
 */
var substringXorQueries = function(s, queries) {
    
};","# @param {String} s
# @param {Integer[][]} queries
# @return {Integer[][]}
def substring_xor_queries(s, queries)
    
end","class Solution {
    func substringXorQueries(_ s: String, _ queries: [[Int]]) -> [[Int]] {
        
    }
}","func substringXorQueries(s string, queries [][]int) [][]int {
    
}","object Solution {
    def substringXorQueries(s: String, queries: Array[Array[Int]]): Array[Array[Int]] = {
        
    }
}","class Solution {
    fun substringXorQueries(s: String, queries: Array<IntArray>): Array<IntArray> {
        
    }
}","impl Solution {
    pub fn substring_xor_queries(s: String, queries: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param Integer[][] $queries
     * @return Integer[][]
     */
    function substringXorQueries($s, $queries) {
        
    }
}","function substringXorQueries(s: string, queries: number[][]): number[][] {

};","(define/contract (substring-xor-queries s queries)
  (-> string? (listof (listof exact-integer?)) (listof (listof exact-integer?)))

  )","-spec substring_xor_queries(S :: unicode:unicode_binary(), Queries :: [[integer()]]) -> [[integer()]].
substring_xor_queries(S, Queries) ->
  .","defmodule Solution do
  @spec substring_xor_queries(s :: String.t, queries :: [[integer]]) :: [[integer]]
  def substring_xor_queries(s, queries) do

  end
end","class Solution {
  List<List<int>> substringXorQueries(String s, List<List<int>> queries) {

  }
}",
count-the-number-of-fair-pairs,Count the Number of Fair Pairs,2563.0,2699.0,"<p>Given a <strong>0-indexed</strong> integer array <code>nums</code> of size <code>n</code> and two integers <code>lower</code> and <code>upper</code>, return <em>the number of fair pairs</em>.</p>

<p>A pair <code>(i, j)</code> is <b>fair </b>if:</p>

<ul>
	<li><code>0 &lt;= i &lt; j &lt; n</code>, and</li>
	<li><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,7,4,4,5], lower = 3, upper = 6
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,7,9,2,5], lower = 11, upper = 11
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is a single fair pair: (2,3).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>nums.length == n</code></li>
	<li><code><font face=""monospace"">-10<sup>9</sup></font>&nbsp;&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code><font face=""monospace"">-10<sup>9</sup>&nbsp;&lt;= lower &lt;= upper &lt;= 10<sup>9</sup></font></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long countFairPairs(vector<int>& nums, int lower, int upper) {
        
    }
};","class Solution {
    public long countFairPairs(int[] nums, int lower, int upper) {
        
    }
}","class Solution(object):
    def countFairPairs(self, nums, lower, upper):
        """"""
        :type nums: List[int]
        :type lower: int
        :type upper: int
        :rtype: int
        """"""
        ","class Solution:
    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:
        ","long long countFairPairs(int* nums, int numsSize, int lower, int upper){

}","public class Solution {
    public long CountFairPairs(int[] nums, int lower, int upper) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} lower
 * @param {number} upper
 * @return {number}
 */
var countFairPairs = function(nums, lower, upper) {
    
};","# @param {Integer[]} nums
# @param {Integer} lower
# @param {Integer} upper
# @return {Integer}
def count_fair_pairs(nums, lower, upper)
    
end","class Solution {
    func countFairPairs(_ nums: [Int], _ lower: Int, _ upper: Int) -> Int {
        
    }
}","func countFairPairs(nums []int, lower int, upper int) int64 {
    
}","object Solution {
    def countFairPairs(nums: Array[Int], lower: Int, upper: Int): Long = {
        
    }
}","class Solution {
    fun countFairPairs(nums: IntArray, lower: Int, upper: Int): Long {
        
    }
}","impl Solution {
    pub fn count_fair_pairs(nums: Vec<i32>, lower: i32, upper: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $lower
     * @param Integer $upper
     * @return Integer
     */
    function countFairPairs($nums, $lower, $upper) {
        
    }
}","function countFairPairs(nums: number[], lower: number, upper: number): number {

};","(define/contract (count-fair-pairs nums lower upper)
  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)

  )","-spec count_fair_pairs(Nums :: [integer()], Lower :: integer(), Upper :: integer()) -> integer().
count_fair_pairs(Nums, Lower, Upper) ->
  .","defmodule Solution do
  @spec count_fair_pairs(nums :: [integer], lower :: integer, upper :: integer) :: integer
  def count_fair_pairs(nums, lower, upper) do

  end
end","class Solution {
  int countFairPairs(List<int> nums, int lower, int upper) {

  }
}",
find-the-array-concatenation-value,Find the Array Concatenation Value,2562.0,2698.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>

<p>The <strong>concatenation</strong> of two numbers is the number formed by concatenating their numerals.</p>

<ul>
	<li>For example, the concatenation of <code>15</code>, <code>49</code> is <code>1549</code>.</li>
</ul>

<p>The <strong>concatenation value</strong> of <code>nums</code> is initially equal to <code>0</code>. Perform this operation until <code>nums</code> becomes empty:</p>

<ul>
	<li>If there exists more than one number in <code>nums</code>, pick the first element and last element in <code>nums</code> respectively and add the value of their concatenation to the <strong>concatenation value</strong> of <code>nums</code>, then delete the first and last element from <code>nums</code>.</li>
	<li>If one element exists, add its value to the <strong>concatenation value</strong> of <code>nums</code>, then delete it.</li>
</ul>

<p>Return<em> the concatenation value of the <code>nums</code></em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,52,2,4]
<strong>Output:</strong> 596
<strong>Explanation:</strong> Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.
 - In the first operation:
We pick the first element, 7, and the last element, 4.
Their concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.
Then we delete them from nums, so nums becomes equal to [52,2].
 - In the second operation:
We pick the first element, 52, and the last element, 2.
Their concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.
Then we delete them from the nums, so nums becomes empty.
Since the concatenation value is 596 so the answer is 596.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,14,13,8,12]
<strong>Output:</strong> 673
<strong>Explanation:</strong> Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.
 - In the first operation:
We pick the first element, 5, and the last element, 12.
Their concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.
Then we delete them from the nums, so nums becomes equal to [14,13,8].
 - In the second operation:
We pick the first element, 14, and the last element, 8.
Their concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.
Then we delete them from the nums, so nums becomes equal to [13].
 - In the third operation:
nums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.
Then we delete it from nums, so nums become empty.
Since the concatenation value is 673 so the answer is 673.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>

<p>&nbsp;</p>
<style type=""text/css"">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value=""Show Message""] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value=""Hide Message""] + .spoiler {padding:5px;}
</style>
",1.0,False,"class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        
    }
};","class Solution {
    public long findTheArrayConcVal(int[] nums) {
        
    }
}","class Solution(object):
    def findTheArrayConcVal(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        ","long long findTheArrayConcVal(int* nums, int numsSize){

}","public class Solution {
    public long FindTheArrayConcVal(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var findTheArrayConcVal = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def find_the_array_conc_val(nums)
    
end","class Solution {
    func findTheArrayConcVal(_ nums: [Int]) -> Int {
        
    }
}","func findTheArrayConcVal(nums []int) int64 {
    
}","object Solution {
    def findTheArrayConcVal(nums: Array[Int]): Long = {
        
    }
}","class Solution {
    fun findTheArrayConcVal(nums: IntArray): Long {
        
    }
}","impl Solution {
    pub fn find_the_array_conc_val(nums: Vec<i32>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findTheArrayConcVal($nums) {
        
    }
}","function findTheArrayConcVal(nums: number[]): number {

};","(define/contract (find-the-array-conc-val nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec find_the_array_conc_val(Nums :: [integer()]) -> integer().
find_the_array_conc_val(Nums) ->
  .","defmodule Solution do
  @spec find_the_array_conc_val(nums :: [integer]) :: integer
  def find_the_array_conc_val(nums) do

  end
end","class Solution {
  int findTheArrayConcVal(List<int> nums) {

  }
}",
minimum-number-of-visited-cells-in-a-grid,Minimum Number of Visited Cells in a Grid,2617.0,2697.0,"<p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code>. Your initial position is at the <strong>top-left</strong> cell <code>(0, 0)</code>.</p>

<p>Starting from the cell <code>(i, j)</code>, you can move to one of the following cells:</p>

<ul>
	<li>Cells <code>(i, k)</code> with <code>j &lt; k &lt;= grid[i][j] + j</code> (rightward movement), or</li>
	<li>Cells <code>(k, j)</code> with <code>i &lt; k &lt;= grid[i][j] + i</code> (downward movement).</li>
</ul>

<p>Return <em>the minimum number of cells you need to visit to reach the <strong>bottom-right</strong> cell</em> <code>(m - 1, n - 1)</code>. If there is no valid path, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/01/25/ex1.png"" style=""width: 271px; height: 171px;"" />
<pre>
<strong>Input:</strong> grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The image above shows one of the paths that visits exactly 4 cells.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/01/25/ex2.png"" style=""width: 271px; height: 171px;"" />
<pre>
<strong>Input:</strong> grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]
<strong>Output:</strong> 3
<strong>Explanation: </strong>The image above shows one of the paths that visits exactly 3 cells.
</pre>

<p><strong class=""example"">Example 3:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/01/26/ex3.png"" style=""width: 181px; height: 81px;"" />
<pre>
<strong>Input:</strong> grid = [[2,1,0],[1,0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be proven that no path exists.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt; m * n</code></li>
	<li><code>grid[m - 1][n - 1] == 0</code></li>
</ul>
",3.0,False,"class Solution {
public:
    int minimumVisitedCells(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int minimumVisitedCells(int[][] grid) {
        
    }
}","class Solution(object):
    def minimumVisitedCells(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minimumVisitedCells(self, grid: List[List[int]]) -> int:
        ","int minimumVisitedCells(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int MinimumVisitedCells(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var minimumVisitedCells = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def minimum_visited_cells(grid)
    
end","class Solution {
    func minimumVisitedCells(_ grid: [[Int]]) -> Int {
        
    }
}","func minimumVisitedCells(grid [][]int) int {
    
}","object Solution {
    def minimumVisitedCells(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun minimumVisitedCells(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn minimum_visited_cells(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function minimumVisitedCells($grid) {
        
    }
}","function minimumVisitedCells(grid: number[][]): number {

};","(define/contract (minimum-visited-cells grid)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec minimum_visited_cells(Grid :: [[integer()]]) -> integer().
minimum_visited_cells(Grid) ->
  .","defmodule Solution do
  @spec minimum_visited_cells(grid :: [[integer]]) :: integer
  def minimum_visited_cells(grid) do

  end
end","class Solution {
  int minimumVisitedCells(List<List<int>> grid) {

  }
}",
the-number-of-beautiful-subsets,The Number of Beautiful Subsets,2597.0,2696.0,"<p>You are given an array <code>nums</code> of positive integers and a <strong>positive</strong> integer <code>k</code>.</p>

<p>A subset of <code>nums</code> is <strong>beautiful</strong> if it does not contain two integers with an absolute difference equal to <code>k</code>.</p>

<p>Return <em>the number of <strong>non-empty beautiful </strong>subsets of the array</em> <code>nums</code>.</p>

<p>A <strong>subset</strong> of <code>nums</code> is an array that can be obtained by deleting some (possibly none) elements from <code>nums</code>. Two subsets are different if and only if the chosen indices to delete are different.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,6], k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> The beautiful subsets of the array nums are: [2], [4], [6], [2, 6].
It can be proved that there are only 4 beautiful subsets in the array [2,4,6].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1], k = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> The beautiful subset of the array nums is [1].
It can be proved that there is only 1 beautiful subset in the array [1].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 20</code></li>
	<li><code>1 &lt;= nums[i], k &lt;= 1000</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int beautifulSubsets(int[] nums, int k) {
        
    }
}","class Solution(object):
    def beautifulSubsets(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def beautifulSubsets(self, nums: List[int], k: int) -> int:
        ","int beautifulSubsets(int* nums, int numsSize, int k){

}","public class Solution {
    public int BeautifulSubsets(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var beautifulSubsets = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def beautiful_subsets(nums, k)
    
end","class Solution {
    func beautifulSubsets(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func beautifulSubsets(nums []int, k int) int {
    
}","object Solution {
    def beautifulSubsets(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun beautifulSubsets(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn beautiful_subsets(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function beautifulSubsets($nums, $k) {
        
    }
}","function beautifulSubsets(nums: number[], k: number): number {

};","(define/contract (beautiful-subsets nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec beautiful_subsets(Nums :: [integer()], K :: integer()) -> integer().
beautiful_subsets(Nums, K) ->
  .","defmodule Solution do
  @spec beautiful_subsets(nums :: [integer], k :: integer) :: integer
  def beautiful_subsets(nums, k) do

  end
end","class Solution {
  int beautifulSubsets(List<int> nums, int k) {

  }
}",
find-score-of-an-array-after-marking-all-elements,Find Score of an Array After Marking All Elements,2593.0,2695.0,"<p>You are given an array <code>nums</code> consisting of positive integers.</p>

<p>Starting with <code>score = 0</code>, apply the following algorithm:</p>

<ul>
	<li>Choose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index.</li>
	<li>Add the value of the chosen integer to <code>score</code>.</li>
	<li>Mark <strong>the chosen element and its two adjacent elements if they exist</strong>.</li>
	<li>Repeat until all the array elements are marked.</li>
</ul>

<p>Return <em>the score you get after applying the above algorithm</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,3,4,5,2]
<strong>Output:</strong> 7
<strong>Explanation:</strong> We mark the elements as follows:
- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [<u>2</u>,<u>1</u>,<u>3</u>,4,5,2].
- 2 is the smallest unmarked element, so we mark it and its left adjacent element: [<u>2</u>,<u>1</u>,<u>3</u>,4,<u>5</u>,<u>2</u>].
- 4 is the only remaining unmarked element, so we mark it: [<u>2</u>,<u>1</u>,<u>3</u>,<u>4</u>,<u>5</u>,<u>2</u>].
Our score is 1 + 2 + 4 = 7.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,5,1,3,2]
<strong>Output:</strong> 5
<strong>Explanation:</strong> We mark the elements as follows:
- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,3,<u>5</u>,<u>1</u>,<u>3</u>,2].
- 2 is the smallest unmarked element, since there are two of them, we choose the left-most one, so we mark the one at index 0 and its right adjacent element: [<u>2</u>,<u>3</u>,<u>5</u>,<u>1</u>,<u>3</u>,2].
- 2 is the only remaining unmarked element, so we mark it: [<u>2</u>,<u>3</u>,<u>5</u>,<u>1</u>,<u>3</u>,<u>2</u>].
Our score is 1 + 2 + 2 = 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long findScore(vector<int>& nums) {
        
    }
};","class Solution {
    public long findScore(int[] nums) {
        
    }
}","class Solution(object):
    def findScore(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def findScore(self, nums: List[int]) -> int:
        ","long long findScore(int* nums, int numsSize){

}","public class Solution {
    public long FindScore(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var findScore = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def find_score(nums)
    
end","class Solution {
    func findScore(_ nums: [Int]) -> Int {
        
    }
}","func findScore(nums []int) int64 {
    
}","object Solution {
    def findScore(nums: Array[Int]): Long = {
        
    }
}","class Solution {
    fun findScore(nums: IntArray): Long {
        
    }
}","impl Solution {
    pub fn find_score(nums: Vec<i32>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findScore($nums) {
        
    }
}","function findScore(nums: number[]): number {

};","(define/contract (find-score nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec find_score(Nums :: [integer()]) -> integer().
find_score(Nums) ->
  .","defmodule Solution do
  @spec find_score(nums :: [integer]) :: integer
  def find_score(nums) do

  end
end","class Solution {
  int findScore(List<int> nums) {

  }
}",
find-the-maximum-divisibility-score,Find the Maximum Divisibility Score,2644.0,2694.0,"<p>You are given two <strong>0-indexed</strong> integer arrays <code>nums</code> and <code>divisors</code>.</p>

<p>The <strong>divisibility score</strong> of <code>divisors[i]</code> is the number of indices <code>j</code> such that <code>nums[j]</code> is divisible by <code>divisors[i]</code>.</p>

<p>Return <em>the integer</em> <code>divisors[i]</code> <em>with the maximum divisibility score</em>. If there is more than one integer with the maximum score, return the minimum of them.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,7,9,3,9], divisors = [5,2,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The divisibility score for every element in divisors is:
The divisibility score of divisors[0] is 0 since no number in nums is divisible by 5.
The divisibility score of divisors[1] is 1 since nums[0] is divisible by 2.
The divisibility score of divisors[2] is 3 since nums[2], nums[3], and nums[4] are divisible by 3.
Since divisors[2] has the maximum divisibility score, we return it.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [20,14,21,10], divisors = [5,7,5]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The divisibility score for every element in divisors is:
The divisibility score of divisors[0] is 2 since nums[0] and nums[3] are divisible by 5.
The divisibility score of divisors[1] is 2 since nums[1] and nums[2] are divisible by 7.
The divisibility score of divisors[2] is 2 since nums[0] and nums[3] are divisible by 5.
Since divisors[0], divisors[1], and divisors[2] all have the maximum divisibility score, we return the minimum of them (i.e., divisors[2]).
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [12], divisors = [10,16]
<strong>Output:</strong> 10
<strong>Explanation:</strong> The divisibility score for every element in divisors is:
The divisibility score of divisors[0] is 0 since no number in nums is divisible by 10.
The divisibility score of divisors[1] is 0 since no number in nums is divisible by 16.
Since divisors[0] and divisors[1] both have the maximum divisibility score, we return the minimum of them (i.e., divisors[0]).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length, divisors.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i], divisors[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",1.0,False,"class Solution {
public:
    int maxDivScore(vector<int>& nums, vector<int>& divisors) {
        
    }
};","class Solution {
    public int maxDivScore(int[] nums, int[] divisors) {
        
    }
}","class Solution(object):
    def maxDivScore(self, nums, divisors):
        """"""
        :type nums: List[int]
        :type divisors: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:
        ","int maxDivScore(int* nums, int numsSize, int* divisors, int divisorsSize){

}","public class Solution {
    public int MaxDivScore(int[] nums, int[] divisors) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number[]} divisors
 * @return {number}
 */
var maxDivScore = function(nums, divisors) {
    
};","# @param {Integer[]} nums
# @param {Integer[]} divisors
# @return {Integer}
def max_div_score(nums, divisors)
    
end","class Solution {
    func maxDivScore(_ nums: [Int], _ divisors: [Int]) -> Int {
        
    }
}","func maxDivScore(nums []int, divisors []int) int {
    
}","object Solution {
    def maxDivScore(nums: Array[Int], divisors: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxDivScore(nums: IntArray, divisors: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_div_score(nums: Vec<i32>, divisors: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer[] $divisors
     * @return Integer
     */
    function maxDivScore($nums, $divisors) {
        
    }
}","function maxDivScore(nums: number[], divisors: number[]): number {

};","(define/contract (max-div-score nums divisors)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)

  )","-spec max_div_score(Nums :: [integer()], Divisors :: [integer()]) -> integer().
max_div_score(Nums, Divisors) ->
  .","defmodule Solution do
  @spec max_div_score(nums :: [integer], divisors :: [integer]) :: integer
  def max_div_score(nums, divisors) do

  end
end","class Solution {
  int maxDivScore(List<int> nums, List<int> divisors) {

  }
}",
take-gifts-from-the-richest-pile,Take Gifts From the Richest Pile,2558.0,2692.0,"<p>You are given an integer array <code>gifts</code> denoting the number of gifts in various piles. Every second, you do the following:</p>

<ul>
	<li>Choose the pile with the maximum number of gifts.</li>
	<li>If there is more than one pile with the maximum number of gifts, choose any.</li>
	<li>Leave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts.</li>
</ul>

<p>Return <em>the number of gifts remaining after </em><code>k</code><em> seconds.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> gifts = [25,64,9,4,100], k = 4
<strong>Output:</strong> 29
<strong>Explanation:</strong> 
The gifts are taken in the following way:
- In the first second, the last pile is chosen and 10 gifts are left behind.
- Then the second pile is chosen and 8 gifts are left behind.
- After that the first pile is chosen and 5 gifts are left behind.
- Finally, the last pile is chosen again and 3 gifts are left behind.
The final remaining gifts are [5,8,9,4,3], so the total number of gifts remaining is 29.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> gifts = [1,1,1,1], k = 4
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
In this case, regardless which pile you choose, you have to leave behind 1 gift in each pile. 
That is, you can&#39;t take any pile with you. 
So, the total gifts remaining are 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= gifts.length &lt;= 10<sup>3</sup></code></li>
	<li><code>1 &lt;= gifts[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>3</sup></code></li>
</ul>
",1.0,False,"class Solution {
public:
    long long pickGifts(vector<int>& gifts, int k) {
        
    }
};","class Solution {
    public long pickGifts(int[] gifts, int k) {
        
    }
}","class Solution(object):
    def pickGifts(self, gifts, k):
        """"""
        :type gifts: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def pickGifts(self, gifts: List[int], k: int) -> int:
        ","long long pickGifts(int* gifts, int giftsSize, int k){

}","public class Solution {
    public long PickGifts(int[] gifts, int k) {
        
    }
}","/**
 * @param {number[]} gifts
 * @param {number} k
 * @return {number}
 */
var pickGifts = function(gifts, k) {
    
};","# @param {Integer[]} gifts
# @param {Integer} k
# @return {Integer}
def pick_gifts(gifts, k)
    
end","class Solution {
    func pickGifts(_ gifts: [Int], _ k: Int) -> Int {
        
    }
}","func pickGifts(gifts []int, k int) int64 {
    
}","object Solution {
    def pickGifts(gifts: Array[Int], k: Int): Long = {
        
    }
}","class Solution {
    fun pickGifts(gifts: IntArray, k: Int): Long {
        
    }
}","impl Solution {
    pub fn pick_gifts(gifts: Vec<i32>, k: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $gifts
     * @param Integer $k
     * @return Integer
     */
    function pickGifts($gifts, $k) {
        
    }
}","function pickGifts(gifts: number[], k: number): number {

};","(define/contract (pick-gifts gifts k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec pick_gifts(Gifts :: [integer()], K :: integer()) -> integer().
pick_gifts(Gifts, K) ->
  .","defmodule Solution do
  @spec pick_gifts(gifts :: [integer], k :: integer) :: integer
  def pick_gifts(gifts, k) do

  end
end","class Solution {
  int pickGifts(List<int> gifts, int k) {

  }
}",
count-vowel-strings-in-ranges,Count Vowel Strings in Ranges,2559.0,2691.0,"<p>You are given a <strong>0-indexed</strong> array of strings <code>words</code> and a 2D array of integers <code>queries</code>.</p>

<p>Each query <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> asks us to find the number of strings present in the range <code>l<sub>i</sub></code> to <code>r<sub>i</sub></code> (both <strong>inclusive</strong>) of <code>words</code> that start and end with a vowel.</p>

<p>Return <em>an array </em><code>ans</code><em> of size </em><code>queries.length</code><em>, where </em><code>ans[i]</code><em> is the answer to the </em><code>i</code><sup>th</sup><em> query</em>.</p>

<p><strong>Note</strong> that the vowel letters are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;aba&quot;,&quot;bcb&quot;,&quot;ece&quot;,&quot;aa&quot;,&quot;e&quot;], queries = [[0,2],[1,4],[1,1]]
<strong>Output:</strong> [2,3,0]
<strong>Explanation:</strong> The strings starting and ending with a vowel are &quot;aba&quot;, &quot;ece&quot;, &quot;aa&quot; and &quot;e&quot;.
The answer to the query [0,2] is 2 (strings &quot;aba&quot; and &quot;ece&quot;).
to query [1,4] is 3 (strings &quot;ece&quot;, &quot;aa&quot;, &quot;e&quot;).
to query [1,1] is 0.
We return [2,3,0].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;e&quot;,&quot;i&quot;], queries = [[0,2],[0,1],[2,2]]
<strong>Output:</strong> [3,2,1]
<strong>Explanation:</strong> Every string satisfies the conditions, so we return [3,2,1].</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= words[i].length &lt;= 40</code></li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
	<li><code>sum(words[i].length) &lt;= 3 * 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt;&nbsp;words.length</code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {
        
    }
};","class Solution {
    public int[] vowelStrings(String[] words, int[][] queries) {
        
    }
}","class Solution(object):
    def vowelStrings(self, words, queries):
        """"""
        :type words: List[str]
        :type queries: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* vowelStrings(char ** words, int wordsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){

}","public class Solution {
    public int[] VowelStrings(string[] words, int[][] queries) {
        
    }
}","/**
 * @param {string[]} words
 * @param {number[][]} queries
 * @return {number[]}
 */
var vowelStrings = function(words, queries) {
    
};","# @param {String[]} words
# @param {Integer[][]} queries
# @return {Integer[]}
def vowel_strings(words, queries)
    
end","class Solution {
    func vowelStrings(_ words: [String], _ queries: [[Int]]) -> [Int] {
        
    }
}","func vowelStrings(words []string, queries [][]int) []int {
    
}","object Solution {
    def vowelStrings(words: Array[String], queries: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun vowelStrings(words: Array<String>, queries: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn vowel_strings(words: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @param Integer[][] $queries
     * @return Integer[]
     */
    function vowelStrings($words, $queries) {
        
    }
}","function vowelStrings(words: string[], queries: number[][]): number[] {

};","(define/contract (vowel-strings words queries)
  (-> (listof string?) (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec vowel_strings(Words :: [unicode:unicode_binary()], Queries :: [[integer()]]) -> [integer()].
vowel_strings(Words, Queries) ->
  .","defmodule Solution do
  @spec vowel_strings(words :: [String.t], queries :: [[integer]]) :: [integer]
  def vowel_strings(words, queries) do

  end
end","class Solution {
  List<int> vowelStrings(List<String> words, List<List<int>> queries) {

  }
}",
house-robber-iv,House Robber IV,2560.0,2690.0,"<p>There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he <strong>refuses to steal from adjacent homes</strong>.</p>

<p>The <strong>capability</strong> of the robber is the maximum amount of money he steals from one house of all the houses he robbed.</p>

<p>You are given an integer array <code>nums</code> representing how much money is stashed in each house. More formally, the <code>i<sup>th</sup></code> house from the left has <code>nums[i]</code> dollars.</p>

<p>You are also given an integer <code>k</code>, representing the <strong>minimum</strong> number of houses the robber will steal from. It is always possible to steal at least <code>k</code> houses.</p>

<p>Return <em>the <strong>minimum</strong> capability of the robber out of all the possible ways to steal at least </em><code>k</code><em> houses</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,5,9], k = 2
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
There are three ways to rob at least 2 houses:
- Rob the houses at indices 0 and 2. Capability is max(nums[0], nums[2]) = 5.
- Rob the houses at indices 0 and 3. Capability is max(nums[0], nums[3]) = 9.
- Rob the houses at indices 1 and 3. Capability is max(nums[1], nums[3]) = 9.
Therefore, we return min(5, 9, 9) = 5.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,7,9,3,1], k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= (nums.length + 1)/2</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int minCapability(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int minCapability(int[] nums, int k) {
        
    }
}","class Solution(object):
    def minCapability(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        ","int minCapability(int* nums, int numsSize, int k){

}","public class Solution {
    public int MinCapability(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var minCapability = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def min_capability(nums, k)
    
end","class Solution {
    func minCapability(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func minCapability(nums []int, k int) int {
    
}","object Solution {
    def minCapability(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun minCapability(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn min_capability(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function minCapability($nums, $k) {
        
    }
}","function minCapability(nums: number[], k: number): number {

};","(define/contract (min-capability nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec min_capability(Nums :: [integer()], K :: integer()) -> integer().
min_capability(Nums, K) ->
  .","defmodule Solution do
  @spec min_capability(nums :: [integer], k :: integer) :: integer
  def min_capability(nums, k) do

  end
end","class Solution {
  int minCapability(List<int> nums, int k) {

  }
}",
rearranging-fruits,Rearranging Fruits,2561.0,2689.0,"<p>You have two fruit baskets containing <code>n</code> fruits each. You are given two <strong>0-indexed</strong> integer arrays <code>basket1</code> and <code>basket2</code> representing the cost of fruit in each basket. You want to make both baskets <strong>equal</strong>. To do so, you can use the following operation as many times as you want:</p>

<ul>
	<li>Chose two indices <code>i</code> and <code>j</code>, and swap the <code>i<sup>th</sup> </code>fruit of <code>basket1</code> with the <code>j<sup>th</sup></code> fruit of <code>basket2</code>.</li>
	<li>The cost of the swap is <code>min(basket1[i],basket2[j])</code>.</li>
</ul>

<p>Two baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets.</p>

<p>Return <em>the minimum cost to make both the baskets equal or </em><code>-1</code><em> if impossible.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> basket1 = [4,2,2,2], basket2 = [1,4,1,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Swap index 1 of basket1 with index 0 of basket2, which has cost 1. Now basket1 = [4,1,2,2] and basket2 = [2,4,1,2]. Rearranging both the arrays makes them equal.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> basket1 = [2,3,4,1], basket2 = [3,2,5,1]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be shown that it is impossible to make both the baskets equal.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>basket1.length == bakste2.length</code></li>
	<li><code>1 &lt;= basket1.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= basket1[i],basket2[i]&nbsp;&lt;= 10<sup>9</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    long long minCost(vector<int>& basket1, vector<int>& basket2) {
        
    }
};","class Solution {
    public long minCost(int[] basket1, int[] basket2) {
        
    }
}","class Solution(object):
    def minCost(self, basket1, basket2):
        """"""
        :type basket1: List[int]
        :type basket2: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minCost(self, basket1: List[int], basket2: List[int]) -> int:
        ","long long minCost(int* basket1, int basket1Size, int* basket2, int basket2Size){

}","public class Solution {
    public long MinCost(int[] basket1, int[] basket2) {
        
    }
}","/**
 * @param {number[]} basket1
 * @param {number[]} basket2
 * @return {number}
 */
var minCost = function(basket1, basket2) {
    
};","# @param {Integer[]} basket1
# @param {Integer[]} basket2
# @return {Integer}
def min_cost(basket1, basket2)
    
end","class Solution {
    func minCost(_ basket1: [Int], _ basket2: [Int]) -> Int {
        
    }
}","func minCost(basket1 []int, basket2 []int) int64 {
    
}","object Solution {
    def minCost(basket1: Array[Int], basket2: Array[Int]): Long = {
        
    }
}","class Solution {
    fun minCost(basket1: IntArray, basket2: IntArray): Long {
        
    }
}","impl Solution {
    pub fn min_cost(basket1: Vec<i32>, basket2: Vec<i32>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $basket1
     * @param Integer[] $basket2
     * @return Integer
     */
    function minCost($basket1, $basket2) {
        
    }
}","function minCost(basket1: number[], basket2: number[]): number {

};","(define/contract (min-cost basket1 basket2)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)

  )","-spec min_cost(Basket1 :: [integer()], Basket2 :: [integer()]) -> integer().
min_cost(Basket1, Basket2) ->
  .","defmodule Solution do
  @spec min_cost(basket1 :: [integer], basket2 :: [integer]) :: integer
  def min_cost(basket1, basket2) do

  end
end","class Solution {
  int minCost(List<int> basket1, List<int> basket2) {

  }
}",
lexicographically-smallest-beautiful-string,Lexicographically Smallest Beautiful String,2663.0,2687.0,"<p>A string is <strong>beautiful</strong> if:</p>

<ul>
	<li>It consists of the first <code>k</code> letters of the English lowercase alphabet.</li>
	<li>It does not contain any substring of length <code>2</code> or more which is a palindrome.</li>
</ul>

<p>You are given a beautiful string <code>s</code> of length <code>n</code> and a positive integer <code>k</code>.</p>

<p>Return <em>the lexicographically smallest string of length </em><code>n</code><em>, which is larger than </em><code>s</code><em> and is <strong>beautiful</strong></em>. If there is no such string, return an empty string.</p>

<p>A string <code>a</code> is lexicographically larger than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, <code>a</code> has a character strictly larger than the corresponding character in <code>b</code>.</p>

<ul>
	<li>For example, <code>&quot;abcd&quot;</code> is lexicographically larger than <code>&quot;abcc&quot;</code> because the first position they differ is at the fourth character, and <code>d</code> is greater than <code>c</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcz&quot;, k = 26
<strong>Output:</strong> &quot;abda&quot;
<strong>Explanation:</strong> The string &quot;abda&quot; is beautiful and lexicographically larger than the string &quot;abcz&quot;.
It can be proven that there is no string that is lexicographically larger than the string &quot;abcz&quot;, beautiful, and lexicographically smaller than the string &quot;abda&quot;.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;dc&quot;, k = 4
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> It can be proven that there is no string that is lexicographically larger than the string &quot;dc&quot; and is beautiful.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>4 &lt;= k &lt;= 26</code></li>
	<li><code>s</code> is a beautiful string.</li>
</ul>
",3.0,False,"class Solution {
public:
    string smallestBeautifulString(string s, int k) {
        
    }
};","class Solution {
    public String smallestBeautifulString(String s, int k) {
        
    }
}","class Solution(object):
    def smallestBeautifulString(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: str
        """"""
        ","class Solution:
    def smallestBeautifulString(self, s: str, k: int) -> str:
        ","char * smallestBeautifulString(char * s, int k){

}","public class Solution {
    public string SmallestBeautifulString(string s, int k) {
        
    }
}","/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var smallestBeautifulString = function(s, k) {
    
};","# @param {String} s
# @param {Integer} k
# @return {String}
def smallest_beautiful_string(s, k)
    
end","class Solution {
    func smallestBeautifulString(_ s: String, _ k: Int) -> String {
        
    }
}","func smallestBeautifulString(s string, k int) string {
    
}","object Solution {
    def smallestBeautifulString(s: String, k: Int): String = {
        
    }
}","class Solution {
    fun smallestBeautifulString(s: String, k: Int): String {
        
    }
}","impl Solution {
    pub fn smallest_beautiful_string(s: String, k: i32) -> String {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param Integer $k
     * @return String
     */
    function smallestBeautifulString($s, $k) {
        
    }
}","function smallestBeautifulString(s: string, k: number): string {

};","(define/contract (smallest-beautiful-string s k)
  (-> string? exact-integer? string?)

  )","-spec smallest_beautiful_string(S :: unicode:unicode_binary(), K :: integer()) -> unicode:unicode_binary().
smallest_beautiful_string(S, K) ->
  .","defmodule Solution do
  @spec smallest_beautiful_string(s :: String.t, k :: integer) :: String.t
  def smallest_beautiful_string(s, k) do

  end
end","class Solution {
  String smallestBeautifulString(String s, int k) {

  }
}",
minimum-cost-of-a-path-with-special-roads,Minimum Cost of a Path With Special Roads,2662.0,2686.0,"<p>You are given an array <code>start</code> where <code>start = [startX, startY]</code> represents your initial position <code>(startX, startY)</code> in a 2D space. You are also given the array <code>target</code> where <code>target = [targetX, targetY]</code> represents your target position <code>(targetX, targetY)</code>.</p>

<p>The cost of going from a position <code>(x1, y1)</code> to any other position in the space <code>(x2, y2)</code> is <code>|x2 - x1| + |y2 - y1|</code>.</p>

<p>There are also some special roads. You are given a 2D array <code>specialRoads</code> where <code>specialRoads[i] = [x1<sub>i</sub>, y1<sub>i</sub>, x2<sub>i</sub>, y2<sub>i</sub>, cost<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> special road can take you from <code>(x1<sub>i</sub>, y1<sub>i</sub>)</code> to <code>(x2<sub>i</sub>, y2<sub>i</sub>)</code> with a cost equal to <code>cost<sub>i</sub></code>. You can use each special road any number of times.</p>

<p>Return <em>the minimum cost required to go from</em> <code>(startX, startY)</code> to <code>(targetX, targetY)</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The optimal path from (1,1) to (4,5) is the following:
- (1,1) -&gt; (1,2). This move has a cost of |1 - 1| + |2 - 1| = 1.
- (1,2) -&gt; (3,3). This move uses the first special edge, the cost is 2.
- (3,3) -&gt; (3,4). This move has a cost of |3 - 3| + |4 - 3| = 1.
- (3,4) -&gt; (4,5). This move uses the second special edge, the cost is 1.
So the total cost is 1 + 2 + 1 + 1 = 5.
It can be shown that we cannot achieve a smaller total cost than 5.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> start = [3,2], target = [5,7], specialRoads = [[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> It is optimal to not use any special edges and go directly from the starting to the ending position with a cost |5 - 3| + |7 - 2| = 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>start.length == target.length == 2</code></li>
	<li><code>1 &lt;= startX &lt;= targetX &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= startY &lt;= targetY &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= specialRoads.length &lt;= 200</code></li>
	<li><code>specialRoads[i].length == 5</code></li>
	<li><code>startX &lt;= x1<sub>i</sub>, x2<sub>i</sub> &lt;= targetX</code></li>
	<li><code>startY &lt;= y1<sub>i</sub>, y2<sub>i</sub> &lt;= targetY</code></li>
	<li><code>1 &lt;= cost<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {
        
    }
};","class Solution {
    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {
        
    }
}","class Solution(object):
    def minimumCost(self, start, target, specialRoads):
        """"""
        :type start: List[int]
        :type target: List[int]
        :type specialRoads: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:
        ","int minimumCost(int* start, int startSize, int* target, int targetSize, int** specialRoads, int specialRoadsSize, int* specialRoadsColSize){

}","public class Solution {
    public int MinimumCost(int[] start, int[] target, int[][] specialRoads) {
        
    }
}","/**
 * @param {number[]} start
 * @param {number[]} target
 * @param {number[][]} specialRoads
 * @return {number}
 */
var minimumCost = function(start, target, specialRoads) {
    
};","# @param {Integer[]} start
# @param {Integer[]} target
# @param {Integer[][]} special_roads
# @return {Integer}
def minimum_cost(start, target, special_roads)
    
end","class Solution {
    func minimumCost(_ start: [Int], _ target: [Int], _ specialRoads: [[Int]]) -> Int {
        
    }
}","func minimumCost(start []int, target []int, specialRoads [][]int) int {
    
}","object Solution {
    def minimumCost(start: Array[Int], target: Array[Int], specialRoads: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun minimumCost(start: IntArray, target: IntArray, specialRoads: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn minimum_cost(start: Vec<i32>, target: Vec<i32>, special_roads: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $start
     * @param Integer[] $target
     * @param Integer[][] $specialRoads
     * @return Integer
     */
    function minimumCost($start, $target, $specialRoads) {
        
    }
}","function minimumCost(start: number[], target: number[], specialRoads: number[][]): number {

};","(define/contract (minimum-cost start target specialRoads)
  (-> (listof exact-integer?) (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)

  )","-spec minimum_cost(Start :: [integer()], Target :: [integer()], SpecialRoads :: [[integer()]]) -> integer().
minimum_cost(Start, Target, SpecialRoads) ->
  .","defmodule Solution do
  @spec minimum_cost(start :: [integer], target :: [integer], special_roads :: [[integer]]) :: integer
  def minimum_cost(start, target, special_roads) do

  end
end","class Solution {
  int minimumCost(List<int> start, List<int> target, List<List<int>> specialRoads) {

  }
}",
first-completely-painted-row-or-column,First Completely Painted Row or Column,2661.0,2685.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>arr</code>, and an <code>m x n</code> integer <strong>matrix</strong> <code>mat</code>. <code>arr</code> and <code>mat</code> both contain <strong>all</strong> the integers in the range <code>[1, m * n]</code>.</p>

<p>Go through each index <code>i</code> in <code>arr</code> starting from index <code>0</code> and paint the cell in <code>mat</code> containing the integer <code>arr[i]</code>.</p>

<p>Return <em>the smallest index</em> <code>i</code> <em>at which either a row or a column will be completely painted in</em> <code>mat</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""image explanation for example 1"" /><img alt=""image explanation for example 1"" src=""https://assets.leetcode.com/uploads/2023/01/18/grid1.jpg"" style=""width: 321px; height: 81px;"" />
<pre>
<strong>Input:</strong> arr = [1,3,4,2], mat = [[1,4],[2,3]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2].
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt=""image explanation for example 2"" src=""https://assets.leetcode.com/uploads/2023/01/18/grid2.jpg"" style=""width: 601px; height: 121px;"" />
<pre>
<strong>Input:</strong> arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The second column becomes fully painted at arr[3].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n = mat[i].length</code></li>
	<li><code>arr.length == m * n</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= arr[i], mat[r][c] &lt;= m * n</code></li>
	<li>All the integers of <code>arr</code> are <strong>unique</strong>.</li>
	<li>All the integers of <code>mat</code> are <strong>unique</strong>.</li>
</ul>
",2.0,False,"class Solution {
public:
    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {
        
    }
};","class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        
    }
}","class Solution(object):
    def firstCompleteIndex(self, arr, mat):
        """"""
        :type arr: List[int]
        :type mat: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:
        ","int firstCompleteIndex(int* arr, int arrSize, int** mat, int matSize, int* matColSize){

}","public class Solution {
    public int FirstCompleteIndex(int[] arr, int[][] mat) {
        
    }
}","/**
 * @param {number[]} arr
 * @param {number[][]} mat
 * @return {number}
 */
var firstCompleteIndex = function(arr, mat) {
    
};","# @param {Integer[]} arr
# @param {Integer[][]} mat
# @return {Integer}
def first_complete_index(arr, mat)
    
end","class Solution {
    func firstCompleteIndex(_ arr: [Int], _ mat: [[Int]]) -> Int {
        
    }
}","func firstCompleteIndex(arr []int, mat [][]int) int {
    
}","object Solution {
    def firstCompleteIndex(arr: Array[Int], mat: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun firstCompleteIndex(arr: IntArray, mat: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn first_complete_index(arr: Vec<i32>, mat: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $arr
     * @param Integer[][] $mat
     * @return Integer
     */
    function firstCompleteIndex($arr, $mat) {
        
    }
}","function firstCompleteIndex(arr: number[], mat: number[][]): number {

};","(define/contract (first-complete-index arr mat)
  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)

  )","-spec first_complete_index(Arr :: [integer()], Mat :: [[integer()]]) -> integer().
first_complete_index(Arr, Mat) ->
  .","defmodule Solution do
  @spec first_complete_index(arr :: [integer], mat :: [[integer]]) :: integer
  def first_complete_index(arr, mat) do

  end
end","class Solution {
  int firstCompleteIndex(List<int> arr, List<List<int>> mat) {

  }
}",
determine-the-winner-of-a-bowling-game,Determine the Winner of a Bowling Game,2660.0,2684.0,"<p>You are given two <strong>0-indexed</strong> integer arrays <code><font face=""monospace"">player1</font></code> and <code>player2</code>, that represent the number of pins that player 1 and player 2 hit in a bowling game, respectively.</p>

<p>The bowling game consists of <code>n</code> turns, and the number of pins in each turn is exactly <code>10</code>.</p>

<p>Assume a player hit <code>x<sub>i</sub></code> pins in the <code>i<sup>th</sup></code> turn. The value of the <code>i<sup>th</sup></code> turn for the player is:</p>

<ul>
	<li><code>2x<sub>i</sub></code> if the player hit <code>10</code> pins in any of the previous two turns.</li>
	<li>Otherwise, It is <code>x<sub>i</sub></code>.</li>
</ul>

<p>The score of the player is the sum of the values of their <code>n</code> turns.</p>

<p>Return</p>

<ul>
	<li><code>1</code> <em>if the score of player 1 is more than the score of player 2,</em></li>
	<li><code>2</code> <em>if the score of player 2 is more than the score of player 1, and</em></li>
	<li><code>0</code> <em>in case of a draw.</em></li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> player1 = [4,10,7,9], player2 = [6,5,2,3]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The score of player1 is 4 + 10 + 2*7 + 2*9 = 46.
The score of player2 is 6 + 5 + 2 + 3 = 16.
Score of player1 is more than the score of player2, so, player1 is the winner, and the answer is 1.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> player1 = [3,5,7,6], player2 = [8,10,10,2]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The score of player1 is 3 + 5 + 7 + 6 = 21.
The score of player2 is 8 + 10 + 2*10 + 2*2 = 42.
Score of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> player1 = [2,3], player2 = [4,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The score of player1 is 2 + 3 = 5
The score of player2 is 4 + 1 = 5
The score of player1 equals to the score of player2, so, there is a draw, and the answer is 0.

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == player1.length == player2.length</code></li>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
	<li><code>0 &lt;= player1[i], player2[i] &lt;= 10</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int isWinner(vector<int>& player1, vector<int>& player2) {
        
    }
};","class Solution {
    public int isWinner(int[] player1, int[] player2) {
        
    }
}","class Solution(object):
    def isWinner(self, player1, player2):
        """"""
        :type player1: List[int]
        :type player2: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def isWinner(self, player1: List[int], player2: List[int]) -> int:
        ","int isWinner(int* player1, int player1Size, int* player2, int player2Size){

}","public class Solution {
    public int IsWinner(int[] player1, int[] player2) {
        
    }
}","/**
 * @param {number[]} player1
 * @param {number[]} player2
 * @return {number}
 */
var isWinner = function(player1, player2) {
    
};","# @param {Integer[]} player1
# @param {Integer[]} player2
# @return {Integer}
def is_winner(player1, player2)
    
end","class Solution {
    func isWinner(_ player1: [Int], _ player2: [Int]) -> Int {
        
    }
}","func isWinner(player1 []int, player2 []int) int {
    
}","object Solution {
    def isWinner(player1: Array[Int], player2: Array[Int]): Int = {
        
    }
}","class Solution {
    fun isWinner(player1: IntArray, player2: IntArray): Int {
        
    }
}","impl Solution {
    pub fn is_winner(player1: Vec<i32>, player2: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $player1
     * @param Integer[] $player2
     * @return Integer
     */
    function isWinner($player1, $player2) {
        
    }
}","function isWinner(player1: number[], player2: number[]): number {

};","(define/contract (is-winner player1 player2)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)

  )","-spec is_winner(Player1 :: [integer()], Player2 :: [integer()]) -> integer().
is_winner(Player1, Player2) ->
  .","defmodule Solution do
  @spec is_winner(player1 :: [integer], player2 :: [integer]) :: integer
  def is_winner(player1, player2) do

  end
end","class Solution {
  int isWinner(List<int> player1, List<int> player2) {

  }
}",
count-increasing-quadruplets,Count Increasing Quadruplets,2552.0,2682.0,"<p>Given a <strong>0-indexed</strong> integer array <code>nums</code> of size <code>n</code> containing all numbers from <code>1</code> to <code>n</code>, return <em>the number of increasing quadruplets</em>.</p>

<p>A quadruplet <code>(i, j, k, l)</code> is increasing if:</p>

<ul>
	<li><code>0 &lt;= i &lt; j &lt; k &lt; l &lt; n</code>, and</li>
	<li><code>nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l]</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,2,4,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
- When i = 0, j = 1, k = 2, and l = 3, nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l].
- When i = 0, j = 1, k = 2, and l = 4, nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l]. 
There are no other quadruplets, so we return 2.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There exists only one quadruplet with i = 0, j = 1, k = 2, l = 3, but since nums[j] &lt; nums[k], we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>4 &lt;= nums.length &lt;= 4000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
	<li>All the integers of <code>nums</code> are <strong>unique</strong>. <code>nums</code> is a permutation.</li>
</ul>
",3.0,False,"class Solution {
public:
    long long countQuadruplets(vector<int>& nums) {
        
    }
};","class Solution {
    public long countQuadruplets(int[] nums) {
        
    }
}","class Solution(object):
    def countQuadruplets(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        ","long long countQuadruplets(int* nums, int numsSize){

}","public class Solution {
    public long CountQuadruplets(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var countQuadruplets = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def count_quadruplets(nums)
    
end","class Solution {
    func countQuadruplets(_ nums: [Int]) -> Int {
        
    }
}","func countQuadruplets(nums []int) int64 {
    
}","object Solution {
    def countQuadruplets(nums: Array[Int]): Long = {
        
    }
}","class Solution {
    fun countQuadruplets(nums: IntArray): Long {
        
    }
}","impl Solution {
    pub fn count_quadruplets(nums: Vec<i32>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function countQuadruplets($nums) {
        
    }
}","function countQuadruplets(nums: number[]): number {

};","(define/contract (count-quadruplets nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec count_quadruplets(Nums :: [integer()]) -> integer().
count_quadruplets(Nums) ->
  .","defmodule Solution do
  @spec count_quadruplets(nums :: [integer]) :: integer
  def count_quadruplets(nums) do

  end
end","class Solution {
  int countQuadruplets(List<int> nums) {

  }
}",
put-marbles-in-bags,Put Marbles in Bags,2551.0,2681.0,"<p>You have <code>k</code> bags. You are given a <strong>0-indexed</strong> integer array <code>weights</code> where <code>weights[i]</code> is the weight of the <code>i<sup>th</sup></code> marble. You are also given the integer <code>k.</code></p>

<p>Divide the marbles into the <code>k</code> bags according to the following rules:</p>

<ul>
	<li>No bag is empty.</li>
	<li>If the <code>i<sup>th</sup></code> marble and <code>j<sup>th</sup></code> marble are in a bag, then all marbles with an index between the <code>i<sup>th</sup></code> and <code>j<sup>th</sup></code> indices should also be in that same bag.</li>
	<li>If a bag consists of all the marbles with an index from <code>i</code> to <code>j</code> inclusively, then the cost of the bag is <code>weights[i] + weights[j]</code>.</li>
</ul>

<p>The <strong>score</strong> after distributing the marbles is the sum of the costs of all the <code>k</code> bags.</p>

<p>Return <em>the <strong>difference</strong> between the <strong>maximum</strong> and <strong>minimum</strong> scores among marble distributions</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> weights = [1,3,5,1], k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
The distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6. 
The distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10. 
Thus, we return their difference 10 - 6 = 4.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> weights = [1, 3], k = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong> The only distribution possible is [1],[3]. 
Since both the maximal and minimal score are the same, we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= weights.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= weights[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    long long putMarbles(vector<int>& weights, int k) {
        
    }
};","class Solution {
    public long putMarbles(int[] weights, int k) {
        
    }
}","class Solution(object):
    def putMarbles(self, weights, k):
        """"""
        :type weights: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def putMarbles(self, weights: List[int], k: int) -> int:
        ","long long putMarbles(int* weights, int weightsSize, int k){

}","public class Solution {
    public long PutMarbles(int[] weights, int k) {
        
    }
}","/**
 * @param {number[]} weights
 * @param {number} k
 * @return {number}
 */
var putMarbles = function(weights, k) {
    
};","# @param {Integer[]} weights
# @param {Integer} k
# @return {Integer}
def put_marbles(weights, k)
    
end","class Solution {
    func putMarbles(_ weights: [Int], _ k: Int) -> Int {
        
    }
}","func putMarbles(weights []int, k int) int64 {
    
}","object Solution {
    def putMarbles(weights: Array[Int], k: Int): Long = {
        
    }
}","class Solution {
    fun putMarbles(weights: IntArray, k: Int): Long {
        
    }
}","impl Solution {
    pub fn put_marbles(weights: Vec<i32>, k: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $weights
     * @param Integer $k
     * @return Integer
     */
    function putMarbles($weights, $k) {
        
    }
}","function putMarbles(weights: number[], k: number): number {

};","(define/contract (put-marbles weights k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec put_marbles(Weights :: [integer()], K :: integer()) -> integer().
put_marbles(Weights, K) ->
  .","defmodule Solution do
  @spec put_marbles(weights :: [integer], k :: integer) :: integer
  def put_marbles(weights, k) do

  end
end","class Solution {
  int putMarbles(List<int> weights, int k) {

  }
}",
count-collisions-of-monkeys-on-a-polygon,Count Collisions of Monkeys on a Polygon,2550.0,2680.0,"<p>There is a regular convex polygon with <code>n</code> vertices. The vertices are labeled from <code>0</code> to <code>n - 1</code> in a clockwise direction, and each vertex has <strong>exactly one monkey</strong>. The following figure shows a convex polygon of <code>6</code> vertices.</p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/01/22/hexagon.jpg"" style=""width: 300px; height: 293px;"" />
<p>Each monkey moves simultaneously to a neighboring vertex. A neighboring vertex for a vertex <code>i</code> can be:</p>

<ul>
	<li>the vertex <code>(i + 1) % n</code> in the clockwise direction, or</li>
	<li>the vertex <code>(i - 1 + n) % n</code> in the counter-clockwise direction.</li>
</ul>

<p>A <strong>collision</strong> happens if at least two monkeys reside on the same vertex after the movement or intersect&nbsp;on an edge.</p>

<p>Return <em>the number of ways the monkeys can move so that at least <strong>one collision</strong></em> <em> happens</em>. Since the answer may be very large, return it modulo <code>10<sup>9 </sup>+ 7</code>.</p>

<p><strong>Note</strong> that each monkey can only move once.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are 8 total possible movements.
Two ways such that they collide at some point are:
- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide.
- Monkey 1 moves in an anticlockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 3 collide.
It can be shown 6 total movements result in a collision.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> 14
<strong>Explanation:</strong> It can be shown that there are 14 ways for the monkeys to collide.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int monkeyMove(int n) {
        
    }
};","class Solution {
    public int monkeyMove(int n) {
        
    }
}","class Solution(object):
    def monkeyMove(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def monkeyMove(self, n: int) -> int:
        ","int monkeyMove(int n){

}","public class Solution {
    public int MonkeyMove(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var monkeyMove = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def monkey_move(n)
    
end","class Solution {
    func monkeyMove(_ n: Int) -> Int {
        
    }
}","func monkeyMove(n int) int {
    
}","object Solution {
    def monkeyMove(n: Int): Int = {
        
    }
}","class Solution {
    fun monkeyMove(n: Int): Int {
        
    }
}","impl Solution {
    pub fn monkey_move(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function monkeyMove($n) {
        
    }
}","function monkeyMove(n: number): number {

};","(define/contract (monkey-move n)
  (-> exact-integer? exact-integer?)

  )","-spec monkey_move(N :: integer()) -> integer().
monkey_move(N) ->
  .","defmodule Solution do
  @spec monkey_move(n :: integer) :: integer
  def monkey_move(n) do

  end
end","class Solution {
  int monkeyMove(int n) {

  }
}",
count-distinct-numbers-on-board,Count Distinct Numbers on Board,2549.0,2679.0,"<p>You are given a positive integer <code>n</code>, that is initially placed on a board. Every day, for <code>10<sup>9</sup></code> days, you perform the following procedure:</p>

<ul>
	<li>For each number <code>x</code> present on the board, find all numbers <code>1 &lt;= i &lt;= n</code> such that <code>x % i == 1</code>.</li>
	<li>Then, place those numbers on the board.</li>
</ul>

<p>Return<em> the number of <strong>distinct</strong> integers present on the board after</em> <code>10<sup>9</sup></code> <em>days have elapsed</em>.</p>

<p><strong>Note:</strong></p>

<ul>
	<li>Once a number is placed on the board, it will remain on it until the end.</li>
	<li><code>%</code>&nbsp;stands&nbsp;for the modulo operation. For example,&nbsp;<code>14 % 3</code> is <code>2</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 5
<strong>Output:</strong> 4
<strong>Explanation:</strong> Initially, 5 is present on the board. 
The next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1. 
After that day, 3 will be added to the board because 4 % 3 == 1. 
At the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5. 
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
Since 3 % 2 == 1, 2 will be added to the board. 
After a billion days, the only two distinct numbers on the board are 2 and 3. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int distinctIntegers(int n) {
        
    }
};","class Solution {
    public int distinctIntegers(int n) {
        
    }
}","class Solution(object):
    def distinctIntegers(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def distinctIntegers(self, n: int) -> int:
        ","int distinctIntegers(int n){

}","public class Solution {
    public int DistinctIntegers(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var distinctIntegers = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def distinct_integers(n)
    
end","class Solution {
    func distinctIntegers(_ n: Int) -> Int {
        
    }
}","func distinctIntegers(n int) int {
    
}","object Solution {
    def distinctIntegers(n: Int): Int = {
        
    }
}","class Solution {
    fun distinctIntegers(n: Int): Int {
        
    }
}","impl Solution {
    pub fn distinct_integers(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function distinctIntegers($n) {
        
    }
}","function distinctIntegers(n: number): number {

};","(define/contract (distinct-integers n)
  (-> exact-integer? exact-integer?)

  )","-spec distinct_integers(N :: integer()) -> integer().
distinct_integers(N) ->
  .","defmodule Solution do
  @spec distinct_integers(n :: integer) :: integer
  def distinct_integers(n) do

  end
end","class Solution {
  int distinctIntegers(int n) {

  }
}",
design-graph-with-shortest-path-calculator,Design Graph With Shortest Path Calculator,2642.0,2678.0,"<p>There is a <strong>directed weighted</strong> graph that consists of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>. The edges of the graph are initially represented by the given array <code>edges</code> where <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, edgeCost<sub>i</sub>]</code> meaning that there is an edge from <code>from<sub>i</sub></code> to <code>to<sub>i</sub></code> with the cost <code>edgeCost<sub>i</sub></code>.</p>

<p>Implement the <code>Graph</code> class:</p>

<ul>
	<li><code>Graph(int n, int[][] edges)</code> initializes the object with <code>n</code> nodes and the given edges.</li>
	<li><code>addEdge(int[] edge)</code> adds an edge to the list of edges where <code>edge = [from, to, edgeCost]</code>. It is guaranteed that there is no edge between the two nodes before adding this one.</li>
	<li><code>int shortestPath(int node1, int node2)</code> returns the <strong>minimum</strong> cost of a path from <code>node1</code> to <code>node2</code>. If no path exists, return <code>-1</code>. The cost of a path is the sum of the costs of the edges in the path.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png"" style=""width: 621px; height: 191px;"" />
<pre>
<strong>Input</strong>
[&quot;Graph&quot;, &quot;shortestPath&quot;, &quot;shortestPath&quot;, &quot;addEdge&quot;, &quot;shortestPath&quot;]
[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]
<strong>Output</strong>
[null, 6, -1, null, 6]

<strong>Explanation</strong>
Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);
g.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -&gt; 0 -&gt; 1 -&gt; 2 with a total cost of 3 + 2 + 1 = 6.
g.shortestPath(0, 3); // return -1. There is no path from 0 to 3.
g.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.
g.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -&gt; 1 -&gt; 3 with a total cost of 2 + 4 = 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= edges.length &lt;= n * (n - 1)</code></li>
	<li><code>edges[i].length == edge.length == 3</code></li>
	<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, from, to, node1, node2 &lt;= n - 1</code></li>
	<li><code>1 &lt;= edgeCost<sub>i</sub>, edgeCost &lt;= 10<sup>6</sup></code></li>
	<li>There are no repeated edges and no self-loops in the graph at any point.</li>
	<li>At most <code>100</code> calls will be made for <code>addEdge</code>.</li>
	<li>At most <code>100</code> calls will be made for <code>shortestPath</code>.</li>
</ul>
",3.0,False,"class Graph {
public:
    Graph(int n, vector<vector<int>>& edges) {
        
    }
    
    void addEdge(vector<int> edge) {
        
    }
    
    int shortestPath(int node1, int node2) {
        
    }
};

/**
 * Your Graph object will be instantiated and called as such:
 * Graph* obj = new Graph(n, edges);
 * obj->addEdge(edge);
 * int param_2 = obj->shortestPath(node1,node2);
 */","class Graph {

    public Graph(int n, int[][] edges) {
        
    }
    
    public void addEdge(int[] edge) {
        
    }
    
    public int shortestPath(int node1, int node2) {
        
    }
}

/**
 * Your Graph object will be instantiated and called as such:
 * Graph obj = new Graph(n, edges);
 * obj.addEdge(edge);
 * int param_2 = obj.shortestPath(node1,node2);
 */","class Graph(object):

    def __init__(self, n, edges):
        """"""
        :type n: int
        :type edges: List[List[int]]
        """"""
        

    def addEdge(self, edge):
        """"""
        :type edge: List[int]
        :rtype: None
        """"""
        

    def shortestPath(self, node1, node2):
        """"""
        :type node1: int
        :type node2: int
        :rtype: int
        """"""
        


# Your Graph object will be instantiated and called as such:
# obj = Graph(n, edges)
# obj.addEdge(edge)
# param_2 = obj.shortestPath(node1,node2)","class Graph:

    def __init__(self, n: int, edges: List[List[int]]):
        

    def addEdge(self, edge: List[int]) -> None:
        

    def shortestPath(self, node1: int, node2: int) -> int:
        


# Your Graph object will be instantiated and called as such:
# obj = Graph(n, edges)
# obj.addEdge(edge)
# param_2 = obj.shortestPath(node1,node2)","


typedef struct {
    
} Graph;


Graph* graphCreate(int n, int** edges, int edgesSize, int* edgesColSize) {
    
}

void graphAddEdge(Graph* obj, int* edge, int edgeSize) {
  
}

int graphShortestPath(Graph* obj, int node1, int node2) {
  
}

void graphFree(Graph* obj) {
    
}

/**
 * Your Graph struct will be instantiated and called as such:
 * Graph* obj = graphCreate(n, edges, edgesSize, edgesColSize);
 * graphAddEdge(obj, edge, edgeSize);
 
 * int param_2 = graphShortestPath(obj, node1, node2);
 
 * graphFree(obj);
*/","public class Graph {

    public Graph(int n, int[][] edges) {
        
    }
    
    public void AddEdge(int[] edge) {
        
    }
    
    public int ShortestPath(int node1, int node2) {
        
    }
}

/**
 * Your Graph object will be instantiated and called as such:
 * Graph obj = new Graph(n, edges);
 * obj.AddEdge(edge);
 * int param_2 = obj.ShortestPath(node1,node2);
 */","/**
 * @param {number} n
 * @param {number[][]} edges
 */
var Graph = function(n, edges) {
    
};

/** 
 * @param {number[]} edge
 * @return {void}
 */
Graph.prototype.addEdge = function(edge) {
    
};

/** 
 * @param {number} node1 
 * @param {number} node2
 * @return {number}
 */
Graph.prototype.shortestPath = function(node1, node2) {
    
};

/** 
 * Your Graph object will be instantiated and called as such:
 * var obj = new Graph(n, edges)
 * obj.addEdge(edge)
 * var param_2 = obj.shortestPath(node1,node2)
 */","class Graph

=begin
    :type n: Integer
    :type edges: Integer[][]
=end
    def initialize(n, edges)
        
    end


=begin
    :type edge: Integer[]
    :rtype: Void
=end
    def add_edge(edge)
        
    end


=begin
    :type node1: Integer
    :type node2: Integer
    :rtype: Integer
=end
    def shortest_path(node1, node2)
        
    end


end

# Your Graph object will be instantiated and called as such:
# obj = Graph.new(n, edges)
# obj.add_edge(edge)
# param_2 = obj.shortest_path(node1, node2)","
class Graph {

    init(_ n: Int, _ edges: [[Int]]) {
        
    }
    
    func addEdge(_ edge: [Int]) {
        
    }
    
    func shortestPath(_ node1: Int, _ node2: Int) -> Int {
        
    }
}

/**
 * Your Graph object will be instantiated and called as such:
 * let obj = Graph(n, edges)
 * obj.addEdge(edge)
 * let ret_2: Int = obj.shortestPath(node1, node2)
 */","type Graph struct {
    
}


func Constructor(n int, edges [][]int) Graph {
    
}


func (this *Graph) AddEdge(edge []int)  {
    
}


func (this *Graph) ShortestPath(node1 int, node2 int) int {
    
}


/**
 * Your Graph object will be instantiated and called as such:
 * obj := Constructor(n, edges);
 * obj.AddEdge(edge);
 * param_2 := obj.ShortestPath(node1,node2);
 */","class Graph(_n: Int, _edges: Array[Array[Int]]) {

    def addEdge(edge: Array[Int]) {
        
    }

    def shortestPath(node1: Int, node2: Int): Int = {
        
    }

}

/**
 * Your Graph object will be instantiated and called as such:
 * var obj = new Graph(n, edges)
 * obj.addEdge(edge)
 * var param_2 = obj.shortestPath(node1,node2)
 */","class Graph(n: Int, edges: Array<IntArray>) {

    fun addEdge(edge: IntArray) {
        
    }

    fun shortestPath(node1: Int, node2: Int): Int {
        
    }

}

/**
 * Your Graph object will be instantiated and called as such:
 * var obj = Graph(n, edges)
 * obj.addEdge(edge)
 * var param_2 = obj.shortestPath(node1,node2)
 */","struct Graph {

}


/** 
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl Graph {

    fn new(n: i32, edges: Vec<Vec<i32>>) -> Self {
        
    }
    
    fn add_edge(&self, edge: Vec<i32>) {
        
    }
    
    fn shortest_path(&self, node1: i32, node2: i32) -> i32 {
        
    }
}

/**
 * Your Graph object will be instantiated and called as such:
 * let obj = Graph::new(n, edges);
 * obj.add_edge(edge);
 * let ret_2: i32 = obj.shortest_path(node1, node2);
 */","class Graph {
    /**
     * @param Integer $n
     * @param Integer[][] $edges
     */
    function __construct($n, $edges) {
        
    }
  
    /**
     * @param Integer[] $edge
     * @return NULL
     */
    function addEdge($edge) {
        
    }
  
    /**
     * @param Integer $node1
     * @param Integer $node2
     * @return Integer
     */
    function shortestPath($node1, $node2) {
        
    }
}

/**
 * Your Graph object will be instantiated and called as such:
 * $obj = Graph($n, $edges);
 * $obj->addEdge($edge);
 * $ret_2 = $obj->shortestPath($node1, $node2);
 */","class Graph {
    constructor(n: number, edges: number[][]) {

    }

    addEdge(edge: number[]): void {

    }

    shortestPath(node1: number, node2: number): number {

    }
}

/**
 * Your Graph object will be instantiated and called as such:
 * var obj = new Graph(n, edges)
 * obj.addEdge(edge)
 * var param_2 = obj.shortestPath(node1,node2)
 */","(define graph%
  (class object%
    (super-new)
    
    ; n : exact-integer?
    ; edges : (listof (listof exact-integer?))
    (init-field
      n
      edges)
    
    ; add-edge : (listof exact-integer?) -> void?
    (define/public (add-edge edge)

      )
    ; shortest-path : exact-integer? exact-integer? -> exact-integer?
    (define/public (shortest-path node1 node2)

      )))

;; Your graph% object will be instantiated and called as such:
;; (define obj (new graph% [n n] [edges edges]))
;; (send obj add-edge edge)
;; (define param_2 (send obj shortest-path node1 node2))","-spec graph_init_(N :: integer(), Edges :: [[integer()]]) -> any().
graph_init_(N, Edges) ->
  .

-spec graph_add_edge(Edge :: [integer()]) -> any().
graph_add_edge(Edge) ->
  .

-spec graph_shortest_path(Node1 :: integer(), Node2 :: integer()) -> integer().
graph_shortest_path(Node1, Node2) ->
  .


%% Your functions will be called as such:
%% graph_init_(N, Edges),
%% graph_add_edge(Edge),
%% Param_2 = graph_shortest_path(Node1, Node2),

%% graph_init_ will be called before every test case, in which you can do some necessary initializations.","defmodule Graph do
  @spec init_(n :: integer, edges :: [[integer]]) :: any
  def init_(n, edges) do

  end

  @spec add_edge(edge :: [integer]) :: any
  def add_edge(edge) do

  end

  @spec shortest_path(node1 :: integer, node2 :: integer) :: integer
  def shortest_path(node1, node2) do

  end
end

# Your functions will be called as such:
# Graph.init_(n, edges)
# Graph.add_edge(edge)
# param_2 = Graph.shortest_path(node1, node2)

# Graph.init_ will be called before every test case, in which you can do some necessary initializations.","class Graph {

  Graph(int n, List<List<int>> edges) {

  }
  
  void addEdge(List<int> edge) {

  }
  
  int shortestPath(int node1, int node2) {

  }
}

/**
 * Your Graph object will be instantiated and called as such:
 * Graph obj = Graph(n, edges);
 * obj.addEdge(edge);
 * int param2 = obj.shortestPath(node1,node2);
 */",
cousins-in-binary-tree-ii,Cousins in Binary Tree II,2641.0,2677.0,"<p>Given the <code>root</code> of a binary tree, replace the value of each node in the tree with the <strong>sum of all its cousins&#39; values</strong>.</p>

<p>Two nodes of a binary tree are <strong>cousins</strong> if they have the same depth with different parents.</p>

<p>Return <em>the </em><code>root</code><em> of the modified tree</em>.</p>

<p><strong>Note</strong> that the depth of a node is the number of edges in the path from the root node to it.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/01/11/example11.png"" style=""width: 571px; height: 151px;"" />
<pre>
<strong>Input:</strong> root = [5,4,9,1,10,null,7]
<strong>Output:</strong> [0,0,0,7,7,null,11]
<strong>Explanation:</strong> The diagram above shows the initial binary tree and the binary tree after changing the value of each node.
- Node with value 5 does not have any cousins so its sum is 0.
- Node with value 4 does not have any cousins so its sum is 0.
- Node with value 9 does not have any cousins so its sum is 0.
- Node with value 1 has a cousin with value 7 so its sum is 7.
- Node with value 10 has a cousin with value 7 so its sum is 7.
- Node with value 7 has cousins with values 1 and 10 so its sum is 11.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/01/11/diagram33.png"" style=""width: 481px; height: 91px;"" />
<pre>
<strong>Input:</strong> root = [3,1,2]
<strong>Output:</strong> [0,0,0]
<strong>Explanation:</strong> The diagram above shows the initial binary tree and the binary tree after changing the value of each node.
- Node with value 3 does not have any cousins so its sum is 0.
- Node with value 1 does not have any cousins so its sum is 0.
- Node with value 2 does not have any cousins so its sum is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
</ul>
",2.0,False,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* replaceValueInTree(TreeNode* root) {
        
    }
};","/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode replaceValueInTree(TreeNode root) {
        
    }
}","# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def replaceValueInTree(self, root):
        """"""
        :type root: Optional[TreeNode]
        :rtype: Optional[TreeNode]
        """"""
        ","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        ","/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNode* replaceValueInTree(struct TreeNode* root){

}","/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public TreeNode ReplaceValueInTree(TreeNode root) {
        
    }
}","/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var replaceValueInTree = function(root) {
    
};","# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {TreeNode}
def replace_value_in_tree(root)
    
end","/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func replaceValueInTree(_ root: TreeNode?) -> TreeNode? {
        
    }
}","/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func replaceValueInTree(root *TreeNode) *TreeNode {
    
}","/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    def replaceValueInTree(root: TreeNode): TreeNode = {
        
    }
}","/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */
class Solution {
    fun replaceValueInTree(root: TreeNode?): TreeNode? {
        
    }
}","// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn replace_value_in_tree(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        
    }
}","/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     public $val = null;
 *     public $left = null;
 *     public $right = null;
 *     function __construct($val = 0, $left = null, $right = null) {
 *         $this->val = $val;
 *         $this->left = $left;
 *         $this->right = $right;
 *     }
 * }
 */
class Solution {

    /**
     * @param TreeNode $root
     * @return TreeNode
     */
    function replaceValueInTree($root) {
        
    }
}","/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function replaceValueInTree(root: TreeNode | null): TreeNode | null {

};","; Definition for a binary tree node.
#|

; val : integer?
; left : (or/c tree-node? #f)
; right : (or/c tree-node? #f)
(struct tree-node
  (val left right) #:mutable #:transparent)

; constructor
(define (make-tree-node [val 0])
  (tree-node val #f #f))

|#

(define/contract (replace-value-in-tree root)
  (-> (or/c tree-node? #f) (or/c tree-node? #f))

  )","%% Definition for a binary tree node.
%%
%% -record(tree_node, {val = 0 :: integer(),
%%                     left = null  :: 'null' | #tree_node{},
%%                     right = null :: 'null' | #tree_node{}}).

-spec replace_value_in_tree(Root :: #tree_node{} | null) -> #tree_node{} | null.
replace_value_in_tree(Root) ->
  .","# Definition for a binary tree node.
#
# defmodule TreeNode do
#   @type t :: %__MODULE__{
#           val: integer,
#           left: TreeNode.t() | nil,
#           right: TreeNode.t() | nil
#         }
#   defstruct val: 0, left: nil, right: nil
# end

defmodule Solution do
  @spec replace_value_in_tree(root :: TreeNode.t | nil) :: TreeNode.t | nil
  def replace_value_in_tree(root) do

  end
end","/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   int val;
 *   TreeNode? left;
 *   TreeNode? right;
 *   TreeNode([this.val = 0, this.left, this.right]);
 * }
 */
class Solution {
  TreeNode? replaceValueInTree(TreeNode? root) {

  }
}",
find-the-score-of-all-prefixes-of-an-array,Find the Score of All Prefixes of an Array,2640.0,2676.0,"<p>We define the <strong>conversion array</strong> <code>conver</code> of an array <code>arr</code> as follows:</p>

<ul>
	<li><code>conver[i] = arr[i] + max(arr[0..i])</code> where <code>max(arr[0..i])</code> is the maximum value of <code>arr[j]</code> over <code>0 &lt;= j &lt;= i</code>.</li>
</ul>

<p>We also define the <strong>score</strong> of an array <code>arr</code> as the sum of the values of the conversion array of <code>arr</code>.</p>

<p>Given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code>, return <em>an array </em><code>ans</code><em> of length </em><code>n</code><em> where </em><code>ans[i]</code><em> is the score of the prefix</em> <code>nums[0..i]</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,7,5,10]
<strong>Output:</strong> [4,10,24,36,56]
<strong>Explanation:</strong> 
For the prefix [2], the conversion array is [4] hence the score is 4
For the prefix [2, 3], the conversion array is [4, 6] hence the score is 10
For the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence the score is 24
For the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] hence the score is 36
For the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 12, 20] hence the score is 56
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,2,4,8,16]
<strong>Output:</strong> [2,4,8,16,32,64]
<strong>Explanation:</strong> 
For the prefix [1], the conversion array is [2] hence the score is 2
For the prefix [1, 1], the conversion array is [2, 2] hence the score is 4
For the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence the score is 8
For the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] hence the score is 16
For the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] hence the score is 32
For the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 16, 32] hence the score is 64
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<long long> findPrefixScore(vector<int>& nums) {
        
    }
};","class Solution {
    public long[] findPrefixScore(int[] nums) {
        
    }
}","class Solution(object):
    def findPrefixScore(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def findPrefixScore(self, nums: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
long long* findPrefixScore(int* nums, int numsSize, int* returnSize){

}","public class Solution {
    public long[] FindPrefixScore(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findPrefixScore = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer[]}
def find_prefix_score(nums)
    
end","class Solution {
    func findPrefixScore(_ nums: [Int]) -> [Int] {
        
    }
}","func findPrefixScore(nums []int) []int64 {
    
}","object Solution {
    def findPrefixScore(nums: Array[Int]): Array[Long] = {
        
    }
}","class Solution {
    fun findPrefixScore(nums: IntArray): LongArray {
        
    }
}","impl Solution {
    pub fn find_prefix_score(nums: Vec<i32>) -> Vec<i64> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function findPrefixScore($nums) {
        
    }
}","function findPrefixScore(nums: number[]): number[] {

};","(define/contract (find-prefix-score nums)
  (-> (listof exact-integer?) (listof exact-integer?))

  )","-spec find_prefix_score(Nums :: [integer()]) -> [integer()].
find_prefix_score(Nums) ->
  .","defmodule Solution do
  @spec find_prefix_score(nums :: [integer]) :: [integer]
  def find_prefix_score(nums) do

  end
end","class Solution {
  List<int> findPrefixScore(List<int> nums) {

  }
}",
find-the-width-of-columns-of-a-grid,Find the Width of Columns of a Grid,2639.0,2675.0,"<p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code>. The width of a column is the maximum <strong>length </strong>of its integers.</p>

<ul>
	<li>For example, if <code>grid = [[-10], [3], [12]]</code>, the width of the only column is <code>3</code> since <code>-10</code> is of length <code>3</code>.</li>
</ul>

<p>Return <em>an integer array</em> <code>ans</code> <em>of size</em> <code>n</code> <em>where</em> <code>ans[i]</code> <em>is the width of the</em> <code>i<sup>th</sup></code> <em>column</em>.</p>

<p>The <strong>length</strong> of an integer <code>x</code> with <code>len</code> digits is equal to <code>len</code> if <code>x</code> is non-negative, and <code>len + 1</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1],[22],[333]]
<strong>Output:</strong> [3]
<strong>Explanation:</strong> In the 0<sup>th</sup> column, 333 is of length 3.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[-15,1,3],[15,7,12],[5,6,-2]]
<strong>Output:</strong> [3,1,2]
<strong>Explanation:</strong> 
In the 0<sup>th</sup> column, only -15 is of length 3.
In the 1<sup>st</sup> column, all integers are of length 1. 
In the 2<sup>nd</sup> column, both 12 and -2 are of length 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100 </code></li>
	<li><code>-10<sup>9</sup> &lt;= grid[r][c] &lt;= 10<sup>9</sup></code></li>
</ul>
",1.0,False,"class Solution {
public:
    vector<int> findColumnWidth(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int[] findColumnWidth(int[][] grid) {
        
    }
}","class Solution(object):
    def findColumnWidth(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findColumnWidth(int** grid, int gridSize, int* gridColSize, int* returnSize){

}","public class Solution {
    public int[] FindColumnWidth(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number[]}
 */
var findColumnWidth = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer[]}
def find_column_width(grid)
    
end","class Solution {
    func findColumnWidth(_ grid: [[Int]]) -> [Int] {
        
    }
}","func findColumnWidth(grid [][]int) []int {
    
}","object Solution {
    def findColumnWidth(grid: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun findColumnWidth(grid: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn find_column_width(grid: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer[]
     */
    function findColumnWidth($grid) {
        
    }
}","function findColumnWidth(grid: number[][]): number[] {

};","(define/contract (find-column-width grid)
  (-> (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec find_column_width(Grid :: [[integer()]]) -> [integer()].
find_column_width(Grid) ->
  .","defmodule Solution do
  @spec find_column_width(grid :: [[integer]]) :: [integer]
  def find_column_width(grid) do

  end
end","class Solution {
  List<int> findColumnWidth(List<List<int>> grid) {

  }
}",
maximize-win-from-two-segments,Maximize Win From Two Segments,2555.0,2673.0,"<p>There are some prizes on the <strong>X-axis</strong>. You are given an integer array <code>prizePositions</code> that is <strong>sorted in non-decreasing order</strong>, where <code>prizePositions[i]</code> is the position of the <code>i<sup>th</sup></code> prize. There could be different prizes at the same position on the line. You are also given an integer <code>k</code>.</p>

<p>You are allowed to select two segments with integer endpoints. The length of each segment must be <code>k</code>. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.</p>

<ul>
	<li>For example if <code>k = 2</code>, you can choose segments <code>[1, 3]</code> and <code>[2, 4]</code>, and you will win any prize <font face=""monospace"">i</font> that satisfies <code>1 &lt;= prizePositions[i] &lt;= 3</code> or <code>2 &lt;= prizePositions[i] &lt;= 4</code>.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of prizes you can win if you choose the two segments optimally</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> prizePositions = [1,1,2,2,3,3,5], k = 2
<strong>Output:</strong> 7
<strong>Explanation:</strong> In this example, you can win all 7 prizes by selecting two segments [1, 3] and [3, 5].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> prizePositions = [1,2,3,4], k = 0
<strong>Output:</strong> 2
<strong>Explanation:</strong> For this example, <strong>one choice</strong> for the segments is <code>[3, 3]</code> and <code>[4, 4],</code> and you will be able to get <code>2</code> prizes. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= prizePositions.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= prizePositions[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>9</sup> </code></li>
	<li><code>prizePositions</code> is sorted in non-decreasing order.</li>
</ul>

<p>&nbsp;</p>
<style type=""text/css"">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value=""Show Message""] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value=""Hide Message""] + .spoiler {padding:5px;}
</style>
",2.0,False,"class Solution {
public:
    int maximizeWin(vector<int>& prizePositions, int k) {
        
    }
};","class Solution {
    public int maximizeWin(int[] prizePositions, int k) {
        
    }
}","class Solution(object):
    def maximizeWin(self, prizePositions, k):
        """"""
        :type prizePositions: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maximizeWin(self, prizePositions: List[int], k: int) -> int:
        ","int maximizeWin(int* prizePositions, int prizePositionsSize, int k){

}","public class Solution {
    public int MaximizeWin(int[] prizePositions, int k) {
        
    }
}","/**
 * @param {number[]} prizePositions
 * @param {number} k
 * @return {number}
 */
var maximizeWin = function(prizePositions, k) {
    
};","# @param {Integer[]} prize_positions
# @param {Integer} k
# @return {Integer}
def maximize_win(prize_positions, k)
    
end","class Solution {
    func maximizeWin(_ prizePositions: [Int], _ k: Int) -> Int {
        
    }
}","func maximizeWin(prizePositions []int, k int) int {
    
}","object Solution {
    def maximizeWin(prizePositions: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun maximizeWin(prizePositions: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn maximize_win(prize_positions: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $prizePositions
     * @param Integer $k
     * @return Integer
     */
    function maximizeWin($prizePositions, $k) {
        
    }
}","function maximizeWin(prizePositions: number[], k: number): number {

};","(define/contract (maximize-win prizePositions k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec maximize_win(PrizePositions :: [integer()], K :: integer()) -> integer().
maximize_win(PrizePositions, K) ->
  .","defmodule Solution do
  @spec maximize_win(prize_positions :: [integer], k :: integer) :: integer
  def maximize_win(prize_positions, k) do

  end
end","class Solution {
  int maximizeWin(List<int> prizePositions, int k) {

  }
}",
shortest-cycle-in-a-graph,Shortest Cycle in a Graph,2608.0,2671.0,"<p>There is a <strong>bi-directional </strong>graph with <code>n</code> vertices, where each vertex is labeled from <code>0</code> to <code>n - 1</code>. The edges in the graph are represented by a given 2D integer array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> denotes an edge between vertex <code>u<sub>i</sub></code> and vertex <code>v<sub>i</sub></code>. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.</p>

<p>Return <em>the length of the <strong>shortest </strong>cycle in the graph</em>. If no cycle exists, return <code>-1</code>.</p>

<p>A cycle is a path that starts and ends at the same node, and each edge in the path is used only once.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/01/04/cropped.png"" style=""width: 387px; height: 331px;"" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The cycle with the smallest length is : 0 -&gt; 1 -&gt; 2 -&gt; 0 
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/01/04/croppedagin.png"" style=""width: 307px; height: 307px;"" />
<pre>
<strong>Input:</strong> n = 4, edges = [[0,1],[0,2]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There are no cycles in this graph.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 1000</code></li>
	<li><code>1 &lt;= edges.length &lt;= 1000</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
</ul>
",3.0,False,"class Solution {
public:
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        
    }
};","class Solution {
    public int findShortestCycle(int n, int[][] edges) {
        
    }
}","class Solution(object):
    def findShortestCycle(self, n, edges):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:
        ","int findShortestCycle(int n, int** edges, int edgesSize, int* edgesColSize){

}","public class Solution {
    public int FindShortestCycle(int n, int[][] edges) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number}
 */
var findShortestCycle = function(n, edges) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @return {Integer}
def find_shortest_cycle(n, edges)
    
end","class Solution {
    func findShortestCycle(_ n: Int, _ edges: [[Int]]) -> Int {
        
    }
}","func findShortestCycle(n int, edges [][]int) int {
    
}","object Solution {
    def findShortestCycle(n: Int, edges: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun findShortestCycle(n: Int, edges: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn find_shortest_cycle(n: i32, edges: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @return Integer
     */
    function findShortestCycle($n, $edges) {
        
    }
}","function findShortestCycle(n: number, edges: number[][]): number {

};","(define/contract (find-shortest-cycle n edges)
  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)

  )","-spec find_shortest_cycle(N :: integer(), Edges :: [[integer()]]) -> integer().
find_shortest_cycle(N, Edges) ->
  .","defmodule Solution do
  @spec find_shortest_cycle(n :: integer, edges :: [[integer]]) :: integer
  def find_shortest_cycle(n, edges) do

  end
end","class Solution {
  int findShortestCycle(int n, List<List<int>> edges) {

  }
}",
make-k-subarray-sums-equal,Make K-Subarray Sums Equal,2607.0,2670.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>arr</code> and an integer <code>k</code>. The array <code>arr</code> is circular. In other words, the first element of the array is the next element of the last element, and the last element of the array is the previous element of the first element.</p>

<p>You can do the following operation any number of times:</p>

<ul>
	<li>Pick any element from <code>arr</code> and increase or decrease it by <code>1</code>.</li>
</ul>

<p>Return <em>the minimum number of operations such that the sum of each <strong>subarray</strong> of length </em><code>k</code><em> is equal</em>.</p>

<p>A <strong>subarray</strong> is a contiguous part of the array.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,4,1,3], k = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> we can do one operation on index 1 to make its value equal to 3.
The array after the operation is [1,3,1,3]
- Subarray starts at index 0 is [1, 3], and its sum is 4 
- Subarray starts at index 1 is [3, 1], and its sum is 4 
- Subarray starts at index 2 is [1, 3], and its sum is 4 
- Subarray starts at index 3 is [3, 1], and its sum is 4 
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,5,5,7], k = 3
<strong>Output:</strong> 5
<strong>Explanation:</strong> we can do three operations on index 0 to make its value equal to 5 and two operations on index 3 to make its value equal to 5.
The array after the operations is [5,5,5,5]
- Subarray starts at index 0 is [5, 5, 5], and its sum is 15
- Subarray starts at index 1 is [5, 5, 5], and its sum is 15
- Subarray starts at index 2 is [5, 5, 5], and its sum is 15
- Subarray starts at index 3 is [5, 5, 5], and its sum is 15 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long makeSubKSumEqual(vector<int>& arr, int k) {
        
    }
};","class Solution {
    public long makeSubKSumEqual(int[] arr, int k) {
        
    }
}","class Solution(object):
    def makeSubKSumEqual(self, arr, k):
        """"""
        :type arr: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:
        ","long long makeSubKSumEqual(int* arr, int arrSize, int k){

}","public class Solution {
    public long MakeSubKSumEqual(int[] arr, int k) {
        
    }
}","/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number}
 */
var makeSubKSumEqual = function(arr, k) {
    
};","# @param {Integer[]} arr
# @param {Integer} k
# @return {Integer}
def make_sub_k_sum_equal(arr, k)
    
end","class Solution {
    func makeSubKSumEqual(_ arr: [Int], _ k: Int) -> Int {
        
    }
}","func makeSubKSumEqual(arr []int, k int) int64 {
    
}","object Solution {
    def makeSubKSumEqual(arr: Array[Int], k: Int): Long = {
        
    }
}","class Solution {
    fun makeSubKSumEqual(arr: IntArray, k: Int): Long {
        
    }
}","impl Solution {
    pub fn make_sub_k_sum_equal(arr: Vec<i32>, k: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $arr
     * @param Integer $k
     * @return Integer
     */
    function makeSubKSumEqual($arr, $k) {
        
    }
}","function makeSubKSumEqual(arr: number[], k: number): number {

};","(define/contract (make-sub-k-sum-equal arr k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec make_sub_k_sum_equal(Arr :: [integer()], K :: integer()) -> integer().
make_sub_k_sum_equal(Arr, K) ->
  .","defmodule Solution do
  @spec make_sub_k_sum_equal(arr :: [integer], k :: integer) :: integer
  def make_sub_k_sum_equal(arr, k) do

  end
end","class Solution {
  int makeSubKSumEqual(List<int> arr, int k) {

  }
}",
find-the-substring-with-maximum-cost,Find the Substring With Maximum Cost,2606.0,2669.0,"<p>You are given a string <code>s</code>, a string <code>chars</code> of <strong>distinct</strong> characters and an integer array <code>vals</code> of the same length as <code>chars</code>.</p>

<p>The <strong>cost of the substring </strong>is the sum of the values of each character in the substring. The cost of an empty string is considered <code>0</code>.</p>

<p>The <strong>value of the character </strong>is defined in the following way:</p>

<ul>
	<li>If the character is not in the string <code>chars</code>, then its value is its corresponding position <strong>(1-indexed)</strong> in the alphabet.

	<ul>
		<li>For example, the value of <code>&#39;a&#39;</code> is <code>1</code>, the value of <code>&#39;b&#39;</code> is <code>2</code>, and so on. The value of <code>&#39;z&#39;</code> is <code>26</code>.</li>
	</ul>
	</li>
	<li>Otherwise, assuming <code>i</code> is the index where the character occurs in the string <code>chars</code>, then its value is <code>vals[i]</code>.</li>
</ul>

<p>Return <em>the maximum cost among all substrings of the string</em> <code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;adaa&quot;, chars = &quot;d&quot;, vals = [-1000]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The value of the characters &quot;a&quot; and &quot;d&quot; is 1 and -1000 respectively.
The substring with the maximum cost is &quot;aa&quot; and its cost is 1 + 1 = 2.
It can be proven that 2 is the maximum cost.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abc&quot;, chars = &quot;abc&quot;, vals = [-1,-1,-1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The value of the characters &quot;a&quot;, &quot;b&quot; and &quot;c&quot; is -1, -1, and -1 respectively.
The substring with the maximum cost is the empty substring &quot;&quot; and its cost is 0.
It can be proven that 0 is the maximum cost.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consist of lowercase English letters.</li>
	<li><code>1 &lt;= chars.length &lt;= 26</code></li>
	<li><code>chars</code> consist of <strong>distinct</strong> lowercase English letters.</li>
	<li><code>vals.length == chars.length</code></li>
	<li><code>-1000 &lt;= vals[i] &lt;= 1000</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int maximumCostSubstring(string s, string chars, vector<int>& vals) {
        
    }
};","class Solution {
    public int maximumCostSubstring(String s, String chars, int[] vals) {
        
    }
}","class Solution(object):
    def maximumCostSubstring(self, s, chars, vals):
        """"""
        :type s: str
        :type chars: str
        :type vals: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:
        ","int maximumCostSubstring(char * s, char * chars, int* vals, int valsSize){

}","public class Solution {
    public int MaximumCostSubstring(string s, string chars, int[] vals) {
        
    }
}","/**
 * @param {string} s
 * @param {string} chars
 * @param {number[]} vals
 * @return {number}
 */
var maximumCostSubstring = function(s, chars, vals) {
    
};","# @param {String} s
# @param {String} chars
# @param {Integer[]} vals
# @return {Integer}
def maximum_cost_substring(s, chars, vals)
    
end","class Solution {
    func maximumCostSubstring(_ s: String, _ chars: String, _ vals: [Int]) -> Int {
        
    }
}","func maximumCostSubstring(s string, chars string, vals []int) int {
    
}","object Solution {
    def maximumCostSubstring(s: String, chars: String, vals: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maximumCostSubstring(s: String, chars: String, vals: IntArray): Int {
        
    }
}","impl Solution {
    pub fn maximum_cost_substring(s: String, chars: String, vals: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param String $chars
     * @param Integer[] $vals
     * @return Integer
     */
    function maximumCostSubstring($s, $chars, $vals) {
        
    }
}","function maximumCostSubstring(s: string, chars: string, vals: number[]): number {

};","(define/contract (maximum-cost-substring s chars vals)
  (-> string? string? (listof exact-integer?) exact-integer?)

  )","-spec maximum_cost_substring(S :: unicode:unicode_binary(), Chars :: unicode:unicode_binary(), Vals :: [integer()]) -> integer().
maximum_cost_substring(S, Chars, Vals) ->
  .","defmodule Solution do
  @spec maximum_cost_substring(s :: String.t, chars :: String.t, vals :: [integer]) :: integer
  def maximum_cost_substring(s, chars, vals) do

  end
end","class Solution {
  int maximumCostSubstring(String s, String chars, List<int> vals) {

  }
}",
form-smallest-number-from-two-digit-arrays,Form Smallest Number From Two Digit Arrays,2605.0,2668.0,"Given two arrays of <strong>unique</strong> digits <code>nums1</code> and <code>nums2</code>, return <em>the <strong>smallest</strong> number that contains <strong>at least</strong> one digit from each array</em>.
<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,1,3], nums2 = [5,7]
<strong>Output:</strong> 15
<strong>Explanation:</strong> The number 15 contains the digit 1 from nums1 and the digit 5 from nums2. It can be proven that 15 is the smallest number we can have.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,5,2,6], nums2 = [3,1,7]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The number 3 contains the digit 3 which exists in both arrays.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 9</code></li>
	<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>
	<li>All digits in each array are <strong>unique</strong>.</li>
</ul>
",1.0,False,"class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        
    }
};","class Solution {
    public int minNumber(int[] nums1, int[] nums2) {
        
    }
}","class Solution(object):
    def minNumber(self, nums1, nums2):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:
        ","int minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size){

}","public class Solution {
    public int MinNumber(int[] nums1, int[] nums2) {
        
    }
}","/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var minNumber = function(nums1, nums2) {
    
};","# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @return {Integer}
def min_number(nums1, nums2)
    
end","class Solution {
    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {
        
    }
}","func minNumber(nums1 []int, nums2 []int) int {
    
}","object Solution {
    def minNumber(nums1: Array[Int], nums2: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minNumber(nums1: IntArray, nums2: IntArray): Int {
        
    }
}","impl Solution {
    pub fn min_number(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @return Integer
     */
    function minNumber($nums1, $nums2) {
        
    }
}","function minNumber(nums1: number[], nums2: number[]): number {

};","(define/contract (min-number nums1 nums2)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)

  )","-spec min_number(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().
min_number(Nums1, Nums2) ->
  .","defmodule Solution do
  @spec min_number(nums1 :: [integer], nums2 :: [integer]) :: integer
  def min_number(nums1, nums2) do

  end
end","class Solution {
  int minNumber(List<int> nums1, List<int> nums2) {

  }
}",
minimum-time-to-repair-cars,Minimum Time to Repair Cars,2594.0,2665.0,"<p>You are given an integer array <code>ranks</code> representing the <strong>ranks</strong> of some mechanics. <font face=""monospace"">ranks<sub>i</sub></font> is the rank of the <font face=""monospace"">i<sup>th</sup></font> mechanic<font face=""monospace"">.</font> A mechanic with a rank <code>r</code> can repair <font face=""monospace"">n</font> cars in <code>r * n<sup>2</sup></code> minutes.</p>

<p>You are also given an integer <code>cars</code> representing the total number of cars waiting in the garage to be repaired.</p>

<p>Return <em>the <strong>minimum</strong> time taken to repair all the cars.</em></p>

<p><strong>Note:</strong> All the mechanics can repair the cars simultaneously.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> ranks = [4,2,3,1], cars = 10
<strong>Output:</strong> 16
<strong>Explanation:</strong> 
- The first mechanic will repair two cars. The time required is 4 * 2 * 2 = 16 minutes.
- The second mechanic will repair two cars. The time required is 2 * 2 * 2 = 8 minutes.
- The third mechanic will repair two cars. The time required is 3 * 2 * 2 = 12 minutes.
- The fourth mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> ranks = [5,1,8], cars = 6
<strong>Output:</strong> 16
<strong>Explanation:</strong> 
- The first mechanic will repair one car. The time required is 5 * 1 * 1 = 5 minutes.
- The second mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
- The third mechanic will repair one car. The time required is 8 * 1 * 1 = 8 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= ranks.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= ranks[i] &lt;= 100</code></li>
	<li><code>1 &lt;= cars &lt;= 10<sup>6</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long repairCars(vector<int>& ranks, int cars) {
        
    }
};","class Solution {
    public long repairCars(int[] ranks, int cars) {
        
    }
}","class Solution(object):
    def repairCars(self, ranks, cars):
        """"""
        :type ranks: List[int]
        :type cars: int
        :rtype: int
        """"""
        ","class Solution:
    def repairCars(self, ranks: List[int], cars: int) -> int:
        ","long long repairCars(int* ranks, int ranksSize, int cars){

}","public class Solution {
    public long RepairCars(int[] ranks, int cars) {
        
    }
}","/**
 * @param {number[]} ranks
 * @param {number} cars
 * @return {number}
 */
var repairCars = function(ranks, cars) {
    
};","# @param {Integer[]} ranks
# @param {Integer} cars
# @return {Integer}
def repair_cars(ranks, cars)
    
end","class Solution {
    func repairCars(_ ranks: [Int], _ cars: Int) -> Int {
        
    }
}","func repairCars(ranks []int, cars int) int64 {
    
}","object Solution {
    def repairCars(ranks: Array[Int], cars: Int): Long = {
        
    }
}","class Solution {
    fun repairCars(ranks: IntArray, cars: Int): Long {
        
    }
}","impl Solution {
    pub fn repair_cars(ranks: Vec<i32>, cars: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $ranks
     * @param Integer $cars
     * @return Integer
     */
    function repairCars($ranks, $cars) {
        
    }
}","function repairCars(ranks: number[], cars: number): number {

};","(define/contract (repair-cars ranks cars)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec repair_cars(Ranks :: [integer()], Cars :: integer()) -> integer().
repair_cars(Ranks, Cars) ->
  .","defmodule Solution do
  @spec repair_cars(ranks :: [integer], cars :: integer) :: integer
  def repair_cars(ranks, cars) do

  end
end","class Solution {
  int repairCars(List<int> ranks, int cars) {

  }
}",
maximize-greatness-of-an-array,Maximize Greatness of an Array,2592.0,2664.0,"<p>You are given a 0-indexed integer array <code>nums</code>. You are allowed to permute <code>nums</code> into a new array <code>perm</code> of your choosing.</p>

<p>We define the <strong>greatness</strong> of <code>nums</code> be the number of indices <code>0 &lt;= i &lt; nums.length</code> for which <code>perm[i] &gt; nums[i]</code>.</p>

<p>Return <em>the <strong>maximum</strong> possible greatness you can achieve after permuting</em> <code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,5,2,1,3,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One of the optimal rearrangements is perm = [2,5,1,3,3,1,1].
At indices = 0, 1, 3, and 4, perm[i] &gt; nums[i]. Hence, we return 4.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can prove the optimal perm is [2,3,4,1].
At indices = 0, 1, and 2, perm[i] &gt; nums[i]. Hence, we return 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int maximizeGreatness(vector<int>& nums) {
        
    }
};","class Solution {
    public int maximizeGreatness(int[] nums) {
        
    }
}","class Solution(object):
    def maximizeGreatness(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maximizeGreatness(self, nums: List[int]) -> int:
        ","int maximizeGreatness(int* nums, int numsSize){

}","public class Solution {
    public int MaximizeGreatness(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var maximizeGreatness = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def maximize_greatness(nums)
    
end","class Solution {
    func maximizeGreatness(_ nums: [Int]) -> Int {
        
    }
}","func maximizeGreatness(nums []int) int {
    
}","object Solution {
    def maximizeGreatness(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maximizeGreatness(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn maximize_greatness(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maximizeGreatness($nums) {
        
    }
}","function maximizeGreatness(nums: number[]): number {

};","(define/contract (maximize-greatness nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec maximize_greatness(Nums :: [integer()]) -> integer().
maximize_greatness(Nums) ->
  .","defmodule Solution do
  @spec maximize_greatness(nums :: [integer]) :: integer
  def maximize_greatness(nums) do

  end
end","class Solution {
  int maximizeGreatness(List<int> nums) {

  }
}",
distribute-money-to-maximum-children,Distribute Money to Maximum Children,2591.0,2663.0,"<p>You are given an integer <code>money</code> denoting the amount of money (in dollars) that you have and another integer <code>children</code> denoting the number of children that you must distribute the money to.</p>

<p>You have to distribute the money according to the following rules:</p>

<ul>
	<li>All money must be distributed.</li>
	<li>Everyone must receive at least <code>1</code> dollar.</li>
	<li>Nobody receives <code>4</code> dollars.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of children who may receive <strong>exactly</strong> </em><code>8</code> <em>dollars if you distribute the money according to the aforementioned rules</em>. If there is no way to distribute the money, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> money = 20, children = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> 
The maximum number of children with 8 dollars will be 1. One of the ways to distribute the money is:
- 8 dollars to the first child.
- 9 dollars to the second child. 
- 3 dollars to the third child.
It can be proven that no distribution exists such that number of children getting 8 dollars is greater than 1.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> money = 16, children = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> Each child can be given 8 dollars.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= money &lt;= 200</code></li>
	<li><code>2 &lt;= children &lt;= 30</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int distMoney(int money, int children) {
        
    }
};","class Solution {
    public int distMoney(int money, int children) {
        
    }
}","class Solution(object):
    def distMoney(self, money, children):
        """"""
        :type money: int
        :type children: int
        :rtype: int
        """"""
        ","class Solution:
    def distMoney(self, money: int, children: int) -> int:
        ","int distMoney(int money, int children){

}","public class Solution {
    public int DistMoney(int money, int children) {
        
    }
}","/**
 * @param {number} money
 * @param {number} children
 * @return {number}
 */
var distMoney = function(money, children) {
    
};","# @param {Integer} money
# @param {Integer} children
# @return {Integer}
def dist_money(money, children)
    
end","class Solution {
    func distMoney(_ money: Int, _ children: Int) -> Int {
        
    }
}","func distMoney(money int, children int) int {
    
}","object Solution {
    def distMoney(money: Int, children: Int): Int = {
        
    }
}","class Solution {
    fun distMoney(money: Int, children: Int): Int {
        
    }
}","impl Solution {
    pub fn dist_money(money: i32, children: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $money
     * @param Integer $children
     * @return Integer
     */
    function distMoney($money, $children) {
        
    }
}","function distMoney(money: number, children: number): number {

};","(define/contract (dist-money money children)
  (-> exact-integer? exact-integer? exact-integer?)

  )","-spec dist_money(Money :: integer(), Children :: integer()) -> integer().
dist_money(Money, Children) ->
  .","defmodule Solution do
  @spec dist_money(money :: integer, children :: integer) :: integer
  def dist_money(money, children) do

  end
end","class Solution {
  int distMoney(int money, int children) {

  }
}",
check-knight-tour-configuration,Check Knight Tour Configuration,2596.0,2662.0,"<p>There is a knight on an <code>n x n</code> chessboard. In a valid configuration, the knight starts <strong>at the top-left cell</strong> of the board and visits every cell on the board <strong>exactly once</strong>.</p>

<p>You are given an <code>n x n</code> integer matrix <code>grid</code> consisting of distinct integers from the range <code>[0, n * n - 1]</code> where <code>grid[row][col]</code> indicates that the cell <code>(row, col)</code> is the <code>grid[row][col]<sup>th</sup></code> cell that the knight visited. The moves are <strong>0-indexed</strong>.</p>

<p>Return <code>true</code> <em>if</em> <code>grid</code> <em>represents a valid configuration of the knight&#39;s movements or</em> <code>false</code> <em>otherwise</em>.</p>

<p><strong>Note</strong> that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.</p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2018/10/12/knight.png"" style=""width: 300px; height: 300px;"" />
<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-5.png"" style=""width: 251px; height: 251px;"" />
<pre>
<strong>Input:</strong> grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]
<strong>Output:</strong> true
<strong>Explanation:</strong> The above diagram represents the grid. It can be shown that it is a valid configuration.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-6.png"" style=""width: 151px; height: 151px;"" />
<pre>
<strong>Input:</strong> grid = [[0,3,6],[5,8,1],[2,7,4]]
<strong>Output:</strong> false
<strong>Explanation:</strong> The above diagram represents the grid. The 8<sup>th</sup> move of the knight is not valid considering its position after the 7<sup>th</sup> move.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>3 &lt;= n &lt;= 7</code></li>
	<li><code>0 &lt;= grid[row][col] &lt; n * n</code></li>
	<li>All integers in <code>grid</code> are <strong>unique</strong>.</li>
</ul>
",2.0,False,"class Solution {
public:
    bool checkValidGrid(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public boolean checkValidGrid(int[][] grid) {
        
    }
}","class Solution(object):
    def checkValidGrid(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: bool
        """"""
        ","class Solution:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        ","bool checkValidGrid(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public bool CheckValidGrid(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {boolean}
 */
var checkValidGrid = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Boolean}
def check_valid_grid(grid)
    
end","class Solution {
    func checkValidGrid(_ grid: [[Int]]) -> Bool {
        
    }
}","func checkValidGrid(grid [][]int) bool {
    
}","object Solution {
    def checkValidGrid(grid: Array[Array[Int]]): Boolean = {
        
    }
}","class Solution {
    fun checkValidGrid(grid: Array<IntArray>): Boolean {
        
    }
}","impl Solution {
    pub fn check_valid_grid(grid: Vec<Vec<i32>>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Boolean
     */
    function checkValidGrid($grid) {
        
    }
}","function checkValidGrid(grid: number[][]): boolean {

};","(define/contract (check-valid-grid grid)
  (-> (listof (listof exact-integer?)) boolean?)

  )","-spec check_valid_grid(Grid :: [[integer()]]) -> boolean().
check_valid_grid(Grid) ->
  .","defmodule Solution do
  @spec check_valid_grid(grid :: [[integer]]) :: boolean
  def check_valid_grid(grid) do

  end
end","class Solution {
  bool checkValidGrid(List<List<int>> grid) {

  }
}",
smallest-missing-non-negative-integer-after-operations,Smallest Missing Non-negative Integer After Operations,2598.0,2661.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>value</code>.</p>

<p>In one operation, you can add or subtract <code>value</code> from any element of <code>nums</code>.</p>

<ul>
	<li>For example, if <code>nums = [1,2,3]</code> and <code>value = 2</code>, you can choose to subtract <code>value</code> from <code>nums[0]</code> to make <code>nums = [-1,2,3]</code>.</li>
</ul>

<p>The MEX (minimum excluded) of an array is the smallest missing <strong>non-negative</strong> integer in it.</p>

<ul>
	<li>For example, the MEX of <code>[-1,2,3]</code> is <code>0</code> while the MEX of <code>[1,0,3]</code> is <code>2</code>.</li>
</ul>

<p>Return <em>the maximum MEX of </em><code>nums</code><em> after applying the mentioned operation <strong>any number of times</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,-10,7,13,6,8], value = 5
<strong>Output:</strong> 4
<strong>Explanation:</strong> One can achieve this result by applying the following operations:
- Add value to nums[1] twice to make nums = [1,<strong><u>0</u></strong>,7,13,6,8]
- Subtract value from nums[2] once to make nums = [1,0,<strong><u>2</u></strong>,13,6,8]
- Subtract value from nums[3] twice to make nums = [1,0,2,<strong><u>3</u></strong>,6,8]
The MEX of nums is 4. It can be shown that 4 is the maximum MEX we can achieve.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,-10,7,13,6,8], value = 7
<strong>Output:</strong> 2
<strong>Explanation:</strong> One can achieve this result by applying the following operation:
- subtract value from nums[2] once to make nums = [1,-10,<u><strong>0</strong></u>,13,6,8]
The MEX of nums is 2. It can be shown that 2 is the maximum MEX we can achieve.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length, value &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int findSmallestInteger(vector<int>& nums, int value) {
        
    }
};","class Solution {
    public int findSmallestInteger(int[] nums, int value) {
        
    }
}","class Solution(object):
    def findSmallestInteger(self, nums, value):
        """"""
        :type nums: List[int]
        :type value: int
        :rtype: int
        """"""
        ","class Solution:
    def findSmallestInteger(self, nums: List[int], value: int) -> int:
        ","int findSmallestInteger(int* nums, int numsSize, int value){

}","public class Solution {
    public int FindSmallestInteger(int[] nums, int value) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} value
 * @return {number}
 */
var findSmallestInteger = function(nums, value) {
    
};","# @param {Integer[]} nums
# @param {Integer} value
# @return {Integer}
def find_smallest_integer(nums, value)
    
end","class Solution {
    func findSmallestInteger(_ nums: [Int], _ value: Int) -> Int {
        
    }
}","func findSmallestInteger(nums []int, value int) int {
    
}","object Solution {
    def findSmallestInteger(nums: Array[Int], value: Int): Int = {
        
    }
}","class Solution {
    fun findSmallestInteger(nums: IntArray, value: Int): Int {
        
    }
}","impl Solution {
    pub fn find_smallest_integer(nums: Vec<i32>, value: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $value
     * @return Integer
     */
    function findSmallestInteger($nums, $value) {
        
    }
}","function findSmallestInteger(nums: number[], value: number): number {

};","(define/contract (find-smallest-integer nums value)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec find_smallest_integer(Nums :: [integer()], Value :: integer()) -> integer().
find_smallest_integer(Nums, Value) ->
  .","defmodule Solution do
  @spec find_smallest_integer(nums :: [integer], value :: integer) :: integer
  def find_smallest_integer(nums, value) do

  end
end","class Solution {
  int findSmallestInteger(List<int> nums, int value) {

  }
}",
number-of-even-and-odd-bits,Number of Even and Odd Bits,2595.0,2659.0,"<p>You are given a <strong>positive</strong> integer <code>n</code>.</p>

<p>Let <code>even</code> denote the number of even indices in the binary representation of <code>n</code> (<strong>0-indexed</strong>) with value <code>1</code>.</p>

<p>Let <code>odd</code> denote the number of odd indices in the binary representation of <code>n</code> (<strong>0-indexed</strong>) with value <code>1</code>.</p>

<p>Return <em>an integer array </em><code>answer</code><em> where </em><code>answer = [even, odd]</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 17
<strong>Output:</strong> [2,0]
<strong>Explanation:</strong> The binary representation of 17 is 10001. 
It contains 1 on the 0<sup>th</sup> and 4<sup>th</sup> indices. 
There are 2 even and 0 odd indices.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong> The binary representation of 2 is 10.
It contains 1 on the 1<sup>st</sup> index. 
There are 0 even and 1 odd indices.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
",1.0,False,"class Solution {
public:
    vector<int> evenOddBit(int n) {
        
    }
};","class Solution {
    public int[] evenOddBit(int n) {
        
    }
}","class Solution(object):
    def evenOddBit(self, n):
        """"""
        :type n: int
        :rtype: List[int]
        """"""
        ","class Solution:
    def evenOddBit(self, n: int) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* evenOddBit(int n, int* returnSize){

}","public class Solution {
    public int[] EvenOddBit(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number[]}
 */
var evenOddBit = function(n) {
    
};","# @param {Integer} n
# @return {Integer[]}
def even_odd_bit(n)
    
end","class Solution {
    func evenOddBit(_ n: Int) -> [Int] {
        
    }
}","func evenOddBit(n int) []int {
    
}","object Solution {
    def evenOddBit(n: Int): Array[Int] = {
        
    }
}","class Solution {
    fun evenOddBit(n: Int): IntArray {
        
    }
}","impl Solution {
    pub fn even_odd_bit(n: i32) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer[]
     */
    function evenOddBit($n) {
        
    }
}","function evenOddBit(n: number): number[] {

};","(define/contract (even-odd-bit n)
  (-> exact-integer? (listof exact-integer?))

  )","-spec even_odd_bit(N :: integer()) -> [integer()].
even_odd_bit(N) ->
  .","defmodule Solution do
  @spec even_odd_bit(n :: integer) :: [integer]
  def even_odd_bit(n) do

  end
end","class Solution {
  List<int> evenOddBit(int n) {

  }
}",
minimum-time-to-complete-all-tasks,Minimum Time to Complete All Tasks,2589.0,2657.0,"<p>There is a computer that can run an unlimited number of tasks <strong>at the same time</strong>. You are given a 2D integer array <code>tasks</code> where <code>tasks[i] = [start<sub>i</sub>, end<sub>i</sub>, duration<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> task should run for a total of <code>duration<sub>i</sub></code> seconds (not necessarily continuous) within the <strong>inclusive</strong> time range <code>[start<sub>i</sub>, end<sub>i</sub>]</code>.</p>

<p>You may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.</p>

<p>Return <em>the minimum time during which the computer should be turned on to complete all tasks</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> tasks = [[2,3,1],[4,5,1],[1,5,2]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
- The first task can be run in the inclusive time range [2, 2].
- The second task can be run in the inclusive time range [5, 5].
- The third task can be run in the two inclusive time ranges [2, 2] and [5, 5].
The computer will be on for a total of 2 seconds.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> tasks = [[1,3,2],[2,5,3],[5,6,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
- The first task can be run in the inclusive time range [2, 3].
- The second task can be run in the inclusive time ranges [2, 3] and [5, 5].
- The third task can be run in the two inclusive time range [5, 6].
The computer will be on for a total of 4 seconds.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= tasks.length &lt;= 2000</code></li>
	<li><code>tasks[i].length == 3</code></li>
	<li><code>1 &lt;= start<sub>i</sub>, end<sub>i</sub> &lt;= 2000</code></li>
	<li><code>1 &lt;= duration<sub>i</sub> &lt;= end<sub>i</sub> - start<sub>i</sub> + 1 </code></li>
</ul>
",3.0,False,"class Solution {
public:
    int findMinimumTime(vector<vector<int>>& tasks) {
        
    }
};","class Solution {
    public int findMinimumTime(int[][] tasks) {
        
    }
}","class Solution(object):
    def findMinimumTime(self, tasks):
        """"""
        :type tasks: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        ","int findMinimumTime(int** tasks, int tasksSize, int* tasksColSize){

}","public class Solution {
    public int FindMinimumTime(int[][] tasks) {
        
    }
}","/**
 * @param {number[][]} tasks
 * @return {number}
 */
var findMinimumTime = function(tasks) {
    
};","# @param {Integer[][]} tasks
# @return {Integer}
def find_minimum_time(tasks)
    
end","class Solution {
    func findMinimumTime(_ tasks: [[Int]]) -> Int {
        
    }
}","func findMinimumTime(tasks [][]int) int {
    
}","object Solution {
    def findMinimumTime(tasks: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun findMinimumTime(tasks: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn find_minimum_time(tasks: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $tasks
     * @return Integer
     */
    function findMinimumTime($tasks) {
        
    }
}","function findMinimumTime(tasks: number[][]): number {

};","(define/contract (find-minimum-time tasks)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec find_minimum_time(Tasks :: [[integer()]]) -> integer().
find_minimum_time(Tasks) ->
  .","defmodule Solution do
  @spec find_minimum_time(tasks :: [[integer]]) :: integer
  def find_minimum_time(tasks) do

  end
end","class Solution {
  int findMinimumTime(List<List<int>> tasks) {

  }
}",
count-the-number-of-beautiful-subarrays,Count the Number of Beautiful Subarrays,2588.0,2656.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. In one operation, you can:</p>

<ul>
	<li>Choose two different indices <code>i</code> and <code>j</code> such that <code>0 &lt;= i, j &lt; nums.length</code>.</li>
	<li>Choose a non-negative integer <code>k</code> such that the <code>k<sup>th</sup></code> bit (<strong>0-indexed</strong>) in the binary representation of <code>nums[i]</code> and <code>nums[j]</code> is <code>1</code>.</li>
	<li>Subtract <code>2<sup>k</sup></code> from <code>nums[i]</code> and <code>nums[j]</code>.</li>
</ul>

<p>A subarray is <strong>beautiful</strong> if it is possible to make all of its elements equal to <code>0</code> after applying the above operation any number of times.</p>

<p>Return <em>the number of <strong>beautiful subarrays</strong> in the array</em> <code>nums</code>.</p>

<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,1,2,4]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 2 beautiful subarrays in nums: [4,<u>3,1,2</u>,4] and [<u>4,3,1,2,4</u>].
- We can make all elements in the subarray [3,1,2] equal to 0 in the following way:
  - Choose [<u>3</u>, 1, <u>2</u>] and k = 1. Subtract 2<sup>1</sup> from both numbers. The subarray becomes [1, 1, 0].
  - Choose [<u>1</u>, <u>1</u>, 0] and k = 0. Subtract 2<sup>0</sup> from both numbers. The subarray becomes [0, 0, 0].
- We can make all elements in the subarray [4,3,1,2,4] equal to 0 in the following way:
  - Choose [<u>4</u>, 3, 1, 2, <u>4</u>] and k = 2. Subtract 2<sup>2</sup> from both numbers. The subarray becomes [0, 3, 1, 2, 0].
  - Choose [0, <u>3</u>, <u>1</u>, 2, 0] and k = 0. Subtract 2<sup>0</sup> from both numbers. The subarray becomes [0, 2, 0, 2, 0].
  - Choose [0, <u>2</u>, 0, <u>2</u>, 0] and k = 1. Subtract 2<sup>1</sup> from both numbers. The subarray becomes [0, 0, 0, 0, 0].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,10,4]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no beautiful subarrays in nums.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        
    }
};","class Solution {
    public long beautifulSubarrays(int[] nums) {
        
    }
}","class Solution(object):
    def beautifulSubarrays(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def beautifulSubarrays(self, nums: List[int]) -> int:
        ","long long beautifulSubarrays(int* nums, int numsSize){

}","public class Solution {
    public long BeautifulSubarrays(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var beautifulSubarrays = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def beautiful_subarrays(nums)
    
end","class Solution {
    func beautifulSubarrays(_ nums: [Int]) -> Int {
        
    }
}","func beautifulSubarrays(nums []int) int64 {
    
}","object Solution {
    def beautifulSubarrays(nums: Array[Int]): Long = {
        
    }
}","class Solution {
    fun beautifulSubarrays(nums: IntArray): Long {
        
    }
}","impl Solution {
    pub fn beautiful_subarrays(nums: Vec<i32>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function beautifulSubarrays($nums) {
        
    }
}","function beautifulSubarrays(nums: number[]): number {

};","(define/contract (beautiful-subarrays nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec beautiful_subarrays(Nums :: [integer()]) -> integer().
beautiful_subarrays(Nums) ->
  .","defmodule Solution do
  @spec beautiful_subarrays(nums :: [integer]) :: integer
  def beautiful_subarrays(nums) do

  end
end","class Solution {
  int beautifulSubarrays(List<int> nums) {

  }
}",
rearrange-array-to-maximize-prefix-score,Rearrange Array to Maximize Prefix Score,2587.0,2655.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. You can rearrange the elements of <code>nums</code> to <strong>any order</strong> (including the given order).</p>

<p>Let <code>prefix</code> be the array containing the prefix sums of <code>nums</code> after rearranging it. In other words, <code>prefix[i]</code> is the sum of the elements from <code>0</code> to <code>i</code> in <code>nums</code> after rearranging it. The <strong>score</strong> of <code>nums</code> is the number of positive integers in the array <code>prefix</code>.</p>

<p>Return <em>the maximum score you can achieve</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,-1,0,1,-3,3,-3]
<strong>Output:</strong> 6
<strong>Explanation:</strong> We can rearrange the array into nums = [2,3,1,-1,-3,0,-3].
prefix = [2,5,6,5,2,2,-1], so the score is 6.
It can be shown that 6 is the maximum score we can obtain.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-2,-3,0]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Any rearrangement of the array will result in a score of 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int maxScore(vector<int>& nums) {
        
    }
};","class Solution {
    public int maxScore(int[] nums) {
        
    }
}","class Solution(object):
    def maxScore(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxScore(self, nums: List[int]) -> int:
        ","int maxScore(int* nums, int numsSize){

}","public class Solution {
    public int MaxScore(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var maxScore = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def max_score(nums)
    
end","class Solution {
    func maxScore(_ nums: [Int]) -> Int {
        
    }
}","func maxScore(nums []int) int {
    
}","object Solution {
    def maxScore(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxScore(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_score(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maxScore($nums) {
        
    }
}","function maxScore(nums: number[]): number {

};","(define/contract (max-score nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec max_score(Nums :: [integer()]) -> integer().
max_score(Nums) ->
  .","defmodule Solution do
  @spec max_score(nums :: [integer]) :: integer
  def max_score(nums) do

  end
end","class Solution {
  int maxScore(List<int> nums) {

  }
}",
count-the-number-of-vowel-strings-in-range,Count the Number of Vowel Strings in Range,2586.0,2654.0,"<p>You are given a <strong>0-indexed</strong> array of string <code>words</code> and two integers <code>left</code> and <code>right</code>.</p>

<p>A string is called a <strong>vowel string</strong> if it starts with a vowel character and ends with a vowel character where vowel characters are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>.</p>

<p>Return <em>the number of vowel strings </em><code>words[i]</code><em> where </em><code>i</code><em> belongs to the inclusive range </em><code>[left, right]</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;are&quot;,&quot;amy&quot;,&quot;u&quot;], left = 0, right = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
- &quot;are&quot; is a vowel string because it starts with &#39;a&#39; and ends with &#39;e&#39;.
- &quot;amy&quot; is not a vowel string because it does not end with a vowel.
- &quot;u&quot; is a vowel string because it starts with &#39;u&#39; and ends with &#39;u&#39;.
The number of vowel strings in the mentioned range is 2.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;hey&quot;,&quot;aeo&quot;,&quot;mu&quot;,&quot;ooo&quot;,&quot;artro&quot;], left = 1, right = 4
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
- &quot;aeo&quot; is a vowel string because it starts with &#39;a&#39; and ends with &#39;o&#39;.
- &quot;mu&quot; is not a vowel string because it does not start with a vowel.
- &quot;ooo&quot; is a vowel string because it starts with &#39;o&#39; and ends with &#39;o&#39;.
- &quot;artro&quot; is a vowel string because it starts with &#39;a&#39; and ends with &#39;o&#39;.
The number of vowel strings in the mentioned range is 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 1000</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
	<li><code>words[i]</code> consists of only lowercase English letters.</li>
	<li><code>0 &lt;= left &lt;= right &lt; words.length</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int vowelStrings(vector<string>& words, int left, int right) {
        
    }
};","class Solution {
    public int vowelStrings(String[] words, int left, int right) {
        
    }
}","class Solution(object):
    def vowelStrings(self, words, left, right):
        """"""
        :type words: List[str]
        :type left: int
        :type right: int
        :rtype: int
        """"""
        ","class Solution:
    def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        ","int vowelStrings(char ** words, int wordsSize, int left, int right){

}","public class Solution {
    public int VowelStrings(string[] words, int left, int right) {
        
    }
}","/**
 * @param {string[]} words
 * @param {number} left
 * @param {number} right
 * @return {number}
 */
var vowelStrings = function(words, left, right) {
    
};","# @param {String[]} words
# @param {Integer} left
# @param {Integer} right
# @return {Integer}
def vowel_strings(words, left, right)
    
end","class Solution {
    func vowelStrings(_ words: [String], _ left: Int, _ right: Int) -> Int {
        
    }
}","func vowelStrings(words []string, left int, right int) int {
    
}","object Solution {
    def vowelStrings(words: Array[String], left: Int, right: Int): Int = {
        
    }
}","class Solution {
    fun vowelStrings(words: Array<String>, left: Int, right: Int): Int {
        
    }
}","impl Solution {
    pub fn vowel_strings(words: Vec<String>, left: i32, right: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @param Integer $left
     * @param Integer $right
     * @return Integer
     */
    function vowelStrings($words, $left, $right) {
        
    }
}","function vowelStrings(words: string[], left: number, right: number): number {

};","(define/contract (vowel-strings words left right)
  (-> (listof string?) exact-integer? exact-integer? exact-integer?)

  )","-spec vowel_strings(Words :: [unicode:unicode_binary()], Left :: integer(), Right :: integer()) -> integer().
vowel_strings(Words, Left, Right) ->
  .","defmodule Solution do
  @spec vowel_strings(words :: [String.t], left :: integer, right :: integer) :: integer
  def vowel_strings(words, left, right) do

  end
end","class Solution {
  int vowelStrings(List<String> words, int left, int right) {

  }
}",
count-number-of-possible-root-nodes,Count Number of Possible Root Nodes,2581.0,2652.0,"<p>Alice has an undirected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. The tree is represented as a 2D integer array <code>edges</code> of length <code>n - 1</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>

<p>Alice wants Bob to find the root of the tree. She allows Bob to make several <strong>guesses</strong> about her tree. In one guess, he does the following:</p>

<ul>
	<li>Chooses two <strong>distinct</strong> integers <code>u</code> and <code>v</code> such that there exists an edge <code>[u, v]</code> in the tree.</li>
	<li>He tells Alice that <code>u</code> is the <strong>parent</strong> of <code>v</code> in the tree.</li>
</ul>

<p>Bob&#39;s guesses are represented by a 2D integer array <code>guesses</code> where <code>guesses[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> indicates Bob guessed <code>u<sub>j</sub></code> to be the parent of <code>v<sub>j</sub></code>.</p>

<p>Alice being lazy, does not reply to each of Bob&#39;s guesses, but just says that <strong>at least</strong> <code>k</code> of his guesses are <code>true</code>.</p>

<p>Given the 2D integer arrays <code>edges</code>, <code>guesses</code> and the integer <code>k</code>, return <em>the <strong>number of possible nodes</strong> that can be the root of Alice&#39;s tree</em>. If there is no such tree, return <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<p><img alt="""" src=""https://assets.leetcode.com/uploads/2022/12/19/ex-1.png"" style=""width: 727px; height: 250px;"" /></p>

<pre>
<strong>Input:</strong> edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
Root = 0, correct guesses = [1,3], [0,1], [2,4]
Root = 1, correct guesses = [1,3], [1,0], [2,4]
Root = 2, correct guesses = [1,3], [1,0], [2,4]
Root = 3, correct guesses = [1,0], [2,4]
Root = 4, correct guesses = [1,3], [1,0]
Considering 0, 1, or 2 as root node leads to 3 correct guesses.

</pre>

<p><strong class=""example"">Example 2:</strong></p>

<p><img alt="""" src=""https://assets.leetcode.com/uploads/2022/12/19/ex-2.png"" style=""width: 600px; height: 303px;"" /></p>

<pre>
<strong>Input:</strong> edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
Root = 0, correct guesses = [3,4]
Root = 1, correct guesses = [1,0], [3,4]
Root = 2, correct guesses = [1,0], [2,1], [3,4]
Root = 3, correct guesses = [1,0], [2,1], [3,2], [3,4]
Root = 4, correct guesses = [1,0], [2,1], [3,2]
Considering any node as root will give at least 1 correct guess. 

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>edges.length == n - 1</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= guesses.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>, u<sub>j</sub>, v<sub>j</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
	<li><code>guesses[j]</code> is an edge of the tree.</li>
	<li><code>guesses</code> is unique.</li>
	<li><code>0 &lt;= k &lt;= guesses.length</code></li>
</ul>
",3.0,False,"class Solution {
public:
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        
    }
};","class Solution {
    public int rootCount(int[][] edges, int[][] guesses, int k) {
        
    }
}","class Solution(object):
    def rootCount(self, edges, guesses, k):
        """"""
        :type edges: List[List[int]]
        :type guesses: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:
        ","int rootCount(int** edges, int edgesSize, int* edgesColSize, int** guesses, int guessesSize, int* guessesColSize, int k){

}","public class Solution {
    public int RootCount(int[][] edges, int[][] guesses, int k) {
        
    }
}","/**
 * @param {number[][]} edges
 * @param {number[][]} guesses
 * @param {number} k
 * @return {number}
 */
var rootCount = function(edges, guesses, k) {
    
};","# @param {Integer[][]} edges
# @param {Integer[][]} guesses
# @param {Integer} k
# @return {Integer}
def root_count(edges, guesses, k)
    
end","class Solution {
    func rootCount(_ edges: [[Int]], _ guesses: [[Int]], _ k: Int) -> Int {
        
    }
}","func rootCount(edges [][]int, guesses [][]int, k int) int {
    
}","object Solution {
    def rootCount(edges: Array[Array[Int]], guesses: Array[Array[Int]], k: Int): Int = {
        
    }
}","class Solution {
    fun rootCount(edges: Array<IntArray>, guesses: Array<IntArray>, k: Int): Int {
        
    }
}","impl Solution {
    pub fn root_count(edges: Vec<Vec<i32>>, guesses: Vec<Vec<i32>>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $edges
     * @param Integer[][] $guesses
     * @param Integer $k
     * @return Integer
     */
    function rootCount($edges, $guesses, $k) {
        
    }
}","function rootCount(edges: number[][], guesses: number[][], k: number): number {

};","(define/contract (root-count edges guesses k)
  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)) exact-integer? exact-integer?)

  )","-spec root_count(Edges :: [[integer()]], Guesses :: [[integer()]], K :: integer()) -> integer().
root_count(Edges, Guesses, K) ->
  .","defmodule Solution do
  @spec root_count(edges :: [[integer]], guesses :: [[integer]], k :: integer) :: integer
  def root_count(edges, guesses, k) do

  end
end","class Solution {
  int rootCount(List<List<int>> edges, List<List<int>> guesses, int k) {

  }
}",
count-ways-to-group-overlapping-ranges,Count Ways to Group Overlapping Ranges,2580.0,2651.0,"<p>You are given a 2D integer array <code>ranges</code> where <code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> denotes that all integers between <code>start<sub>i</sub></code> and <code>end<sub>i</sub></code> (both <strong>inclusive</strong>) are contained in the <code>i<sup>th</sup></code> range.</p>

<p>You are to split <code>ranges</code> into <strong>two</strong> (possibly empty) groups such that:</p>

<ul>
	<li>Each range belongs to exactly one group.</li>
	<li>Any two <strong>overlapping</strong> ranges must belong to the <strong>same</strong> group.</li>
</ul>

<p>Two ranges are said to be <strong>overlapping</strong>&nbsp;if there exists at least <strong>one</strong> integer that is present in both ranges.</p>

<ul>
	<li>For example, <code>[1, 3]</code> and <code>[2, 5]</code> are overlapping because <code>2</code> and <code>3</code> occur in both ranges.</li>
</ul>

<p>Return <em>the <strong>total number</strong> of ways to split</em> <code>ranges</code> <em>into two groups</em>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> ranges = [[6,10],[5,15]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
The two ranges are overlapping, so they must be in the same group.
Thus, there are two possible ways:
- Put both the ranges together in group 1.
- Put both the ranges together in group 2.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> ranges = [[1,3],[10,20],[2,5],[4,8]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
Ranges [1,3], and [2,5] are overlapping. So, they must be in the same group.
Again, ranges [2,5] and [4,8] are also overlapping. So, they must also be in the same group. 
Thus, there are four possible ways to group them:
- All the ranges in group 1.
- All the ranges in group 2.
- Ranges [1,3], [2,5], and [4,8] in group 1 and [10,20] in group 2.
- Ranges [1,3], [2,5], and [4,8] in group 2 and [10,20] in group 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= ranges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>ranges[i].length == 2</code></li>
	<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int countWays(vector<vector<int>>& ranges) {
        
    }
};","class Solution {
    public int countWays(int[][] ranges) {
        
    }
}","class Solution(object):
    def countWays(self, ranges):
        """"""
        :type ranges: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def countWays(self, ranges: List[List[int]]) -> int:
        ","int countWays(int** ranges, int rangesSize, int* rangesColSize){

}","public class Solution {
    public int CountWays(int[][] ranges) {
        
    }
}","/**
 * @param {number[][]} ranges
 * @return {number}
 */
var countWays = function(ranges) {
    
};","# @param {Integer[][]} ranges
# @return {Integer}
def count_ways(ranges)
    
end","class Solution {
    func countWays(_ ranges: [[Int]]) -> Int {
        
    }
}","func countWays(ranges [][]int) int {
    
}","object Solution {
    def countWays(ranges: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun countWays(ranges: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn count_ways(ranges: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $ranges
     * @return Integer
     */
    function countWays($ranges) {
        
    }
}","function countWays(ranges: number[][]): number {

};","(define/contract (count-ways ranges)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec count_ways(Ranges :: [[integer()]]) -> integer().
count_ways(Ranges) ->
  .","defmodule Solution do
  @spec count_ways(ranges :: [[integer]]) :: integer
  def count_ways(ranges) do

  end
end","class Solution {
  int countWays(List<List<int>> ranges) {

  }
}",
split-with-minimum-sum,Split With Minimum Sum,2578.0,2650.0,"<p>Given a positive integer <code>num</code>, split it into two non-negative integers <code>num1</code> and <code>num2</code> such that:</p>

<ul>
	<li>The concatenation of <code>num1</code> and <code>num2</code> is a permutation of <code>num</code>.

	<ul>
		<li>In other words, the sum of the number of occurrences of each digit in <code>num1</code> and <code>num2</code> is equal to the number of occurrences of that digit in <code>num</code>.</li>
	</ul>
	</li>
	<li><code>num1</code> and <code>num2</code> can contain leading zeros.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> possible sum of</em> <code>num1</code> <em>and</em> <code>num2</code>.</p>

<p><strong>Notes:</strong></p>

<ul>
	<li>It is guaranteed that <code>num</code> does not contain any leading zeros.</li>
	<li>The order of occurrence of the digits in <code>num1</code> and <code>num2</code> may differ from the order of occurrence of <code>num</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num = 4325
<strong>Output:</strong> 59
<strong>Explanation:</strong> We can split 4325 so that <code>num1 </code>is 24 and num2<code> is </code>35, giving a sum of 59. We can prove that 59 is indeed the minimal possible sum.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num = 687
<strong>Output:</strong> 75
<strong>Explanation:</strong> We can split 687 so that <code>num1</code> is 68 and <code>num2 </code>is 7, which would give an optimal sum of 75.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>10 &lt;= num &lt;= 10<sup>9</sup></code></li>
</ul>
",1.0,False,"class Solution {
public:
    int splitNum(int num) {
        
    }
};","class Solution {
    public int splitNum(int num) {
        
    }
}","class Solution(object):
    def splitNum(self, num):
        """"""
        :type num: int
        :rtype: int
        """"""
        ","class Solution:
    def splitNum(self, num: int) -> int:
        ","int splitNum(int num){

}","public class Solution {
    public int SplitNum(int num) {
        
    }
}","/**
 * @param {number} num
 * @return {number}
 */
var splitNum = function(num) {
    
};","# @param {Integer} num
# @return {Integer}
def split_num(num)
    
end","class Solution {
    func splitNum(_ num: Int) -> Int {
        
    }
}","func splitNum(num int) int {
    
}","object Solution {
    def splitNum(num: Int): Int = {
        
    }
}","class Solution {
    fun splitNum(num: Int): Int {
        
    }
}","impl Solution {
    pub fn split_num(num: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $num
     * @return Integer
     */
    function splitNum($num) {
        
    }
}","function splitNum(num: number): number {

};","(define/contract (split-num num)
  (-> exact-integer? exact-integer?)

  )","-spec split_num(Num :: integer()) -> integer().
split_num(Num) ->
  .","defmodule Solution do
  @spec split_num(num :: integer) :: integer
  def split_num(num) do

  end
end","class Solution {
  int splitNum(int num) {

  }
}",
count-total-number-of-colored-cells,Count Total Number of Colored Cells,2579.0,2649.0,"<p>There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer <code>n</code>, indicating that you must do the following routine for <code>n</code> minutes:</p>

<ul>
	<li>At the first minute, color <strong>any</strong> arbitrary unit cell blue.</li>
	<li>Every minute thereafter, color blue <strong>every</strong> uncolored cell that touches a blue cell.</li>
</ul>

<p>Below is a pictorial representation of the state of the grid after minutes 1, 2, and 3.</p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/01/10/example-copy-2.png"" style=""width: 500px; height: 279px;"" />
<p>Return <em>the number of <strong>colored cells</strong> at the end of </em><code>n</code> <em>minutes</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> After 1 minute, there is only 1 blue cell, so we return 1.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> 5
<strong>Explanation:</strong> After 2 minutes, there are 4 colored cells on the boundary and 1 in the center, so we return 5. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long coloredCells(int n) {
        
    }
};","class Solution {
    public long coloredCells(int n) {
        
    }
}","class Solution(object):
    def coloredCells(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def coloredCells(self, n: int) -> int:
        ","long long coloredCells(int n){

}","public class Solution {
    public long ColoredCells(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var coloredCells = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def colored_cells(n)
    
end","class Solution {
    func coloredCells(_ n: Int) -> Int {
        
    }
}","func coloredCells(n int) int64 {
    
}","object Solution {
    def coloredCells(n: Int): Long = {
        
    }
}","class Solution {
    fun coloredCells(n: Int): Long {
        
    }
}","impl Solution {
    pub fn colored_cells(n: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function coloredCells($n) {
        
    }
}","function coloredCells(n: number): number {

};","(define/contract (colored-cells n)
  (-> exact-integer? exact-integer?)

  )","-spec colored_cells(N :: integer()) -> integer().
colored_cells(N) ->
  .","defmodule Solution do
  @spec colored_cells(n :: integer) :: integer
  def colored_cells(n) do

  end
end","class Solution {
  int coloredCells(int n) {

  }
}",
number-of-ways-to-earn-points,Number of Ways to Earn Points,2585.0,2648.0,"<p>There is a test that has <code>n</code> types of questions. You are given an integer <code>target</code> and a <strong>0-indexed</strong> 2D integer array <code>types</code> where <code>types[i] = [count<sub>i</sub>, marks<sub>i</sub>]</code> indicates that there are <code>count<sub>i</sub></code> questions of the <code>i<sup>th</sup></code> type, and each one of them is worth <code>marks<sub>i</sub></code> points.</p>

<ul>
</ul>

<p>Return <em>the number of ways you can earn <strong>exactly</strong> </em><code>target</code><em> points in the exam</em>. Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p><strong>Note</strong> that questions of the same type are indistinguishable.</p>

<ul>
	<li>For example, if there are <code>3</code> questions of the same type, then solving the <code>1<sup>st</sup></code> and <code>2<sup>nd</sup></code> questions is the same as solving the <code>1<sup>st</sup></code> and <code>3<sup>rd</sup></code> questions, or the <code>2<sup>nd</sup></code> and <code>3<sup>rd</sup></code> questions.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> target = 6, types = [[6,1],[3,2],[2,3]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> You can earn 6 points in one of the seven ways:
- Solve 6 questions of the 0<sup>th</sup> type: 1 + 1 + 1 + 1 + 1 + 1 = 6
- Solve 4 questions of the 0<sup>th</sup> type and 1 question of the 1<sup>st</sup> type: 1 + 1 + 1 + 1 + 2 = 6
- Solve 2 questions of the 0<sup>th</sup> type and 2 questions of the 1<sup>st</sup> type: 1 + 1 + 2 + 2 = 6
- Solve 3 questions of the 0<sup>th</sup> type and 1 question of the 2<sup>nd</sup> type: 1 + 1 + 1 + 3 = 6
- Solve 1 question of the 0<sup>th</sup> type, 1 question of the 1<sup>st</sup> type and 1 question of the 2<sup>nd</sup> type: 1 + 2 + 3 = 6
- Solve 3 questions of the 1<sup>st</sup> type: 2 + 2 + 2 = 6
- Solve 2 questions of the 2<sup>nd</sup> type: 3 + 3 = 6
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> target = 5, types = [[50,1],[50,2],[50,5]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> You can earn 5 points in one of the four ways:
- Solve 5 questions of the 0<sup>th</sup> type: 1 + 1 + 1 + 1 + 1 = 5
- Solve 3 questions of the 0<sup>th</sup> type and 1 question of the 1<sup>st</sup> type: 1 + 1 + 1 + 2 = 5
- Solve 1 questions of the 0<sup>th</sup> type and 2 questions of the 1<sup>st</sup> type: 1 + 2 + 2 = 5
- Solve 1 question of the 2<sup>nd</sup> type: 5
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> target = 18, types = [[6,1],[3,2],[2,3]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> You can only earn 18 points by answering all questions.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= target &lt;= 1000</code></li>
	<li><code>n == types.length</code></li>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>types[i].length == 2</code></li>
	<li><code>1 &lt;= count<sub>i</sub>, marks<sub>i</sub> &lt;= 50</code></li>
</ul>
",3.0,False,"class Solution {
public:
    int waysToReachTarget(int target, vector<vector<int>>& types) {
        
    }
};","class Solution {
    public int waysToReachTarget(int target, int[][] types) {
        
    }
}","class Solution(object):
    def waysToReachTarget(self, target, types):
        """"""
        :type target: int
        :type types: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        ","int waysToReachTarget(int target, int** types, int typesSize, int* typesColSize){

}","public class Solution {
    public int WaysToReachTarget(int target, int[][] types) {
        
    }
}","/**
 * @param {number} target
 * @param {number[][]} types
 * @return {number}
 */
var waysToReachTarget = function(target, types) {
    
};","# @param {Integer} target
# @param {Integer[][]} types
# @return {Integer}
def ways_to_reach_target(target, types)
    
end","class Solution {
    func waysToReachTarget(_ target: Int, _ types: [[Int]]) -> Int {
        
    }
}","func waysToReachTarget(target int, types [][]int) int {
    
}","object Solution {
    def waysToReachTarget(target: Int, types: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun waysToReachTarget(target: Int, types: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn ways_to_reach_target(target: i32, types: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $target
     * @param Integer[][] $types
     * @return Integer
     */
    function waysToReachTarget($target, $types) {
        
    }
}","function waysToReachTarget(target: number, types: number[][]): number {

};","(define/contract (ways-to-reach-target target types)
  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)

  )","-spec ways_to_reach_target(Target :: integer(), Types :: [[integer()]]) -> integer().
ways_to_reach_target(Target, Types) ->
  .","defmodule Solution do
  @spec ways_to_reach_target(target :: integer, types :: [[integer]]) :: integer
  def ways_to_reach_target(target, types) do

  end
end","class Solution {
  int waysToReachTarget(int target, List<List<int>> types) {

  }
}",
split-the-array-to-make-coprime-products,Split the Array to Make Coprime Products,2584.0,2647.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code>.</p>

<p>A <strong>split</strong> at an index <code>i</code> where <code>0 &lt;= i &lt;= n - 2</code> is called <strong>valid</strong> if the product of the first <code>i + 1</code> elements and the product of the remaining elements are coprime.</p>

<ul>
	<li>For example, if <code>nums = [2, 3, 3]</code>, then a split at the index <code>i = 0</code> is valid because <code>2</code> and <code>9</code> are coprime, while a split at the index <code>i = 1</code> is not valid because <code>6</code> and <code>3</code> are not coprime. A split at the index <code>i = 2</code> is not valid because <code>i == n - 1</code>.</li>
</ul>

<p>Return <em>the smallest index </em><code>i</code><em> at which the array can be split validly or </em><code>-1</code><em> if there is no such split</em>.</p>

<p>Two values <code>val1</code> and <code>val2</code> are coprime if <code>gcd(val1, val2) == 1</code> where <code>gcd(val1, val2)</code> is the greatest common divisor of <code>val1</code> and <code>val2</code>.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/12/14/second.PNG"" style=""width: 450px; height: 211px;"" />
<pre>
<strong>Input:</strong> nums = [4,7,8,15,3,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.
The only valid split is at index 2.
</pre>

<p><strong>Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/12/14/capture.PNG"" style=""width: 450px; height: 215px;"" />
<pre>
<strong>Input:</strong> nums = [4,7,15,8,3,5]
<strong>Output:</strong> -1
<strong>Explanation:</strong> The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.
There is no valid split.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    int findValidSplit(vector<int>& nums) {
        
    }
};","class Solution {
    public int findValidSplit(int[] nums) {
        
    }
}","class Solution(object):
    def findValidSplit(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def findValidSplit(self, nums: List[int]) -> int:
        ","int findValidSplit(int* nums, int numsSize){

}","public class Solution {
    public int FindValidSplit(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var findValidSplit = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def find_valid_split(nums)
    
end","class Solution {
    func findValidSplit(_ nums: [Int]) -> Int {
        
    }
}","func findValidSplit(nums []int) int {
    
}","object Solution {
    def findValidSplit(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun findValidSplit(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn find_valid_split(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findValidSplit($nums) {
        
    }
}","function findValidSplit(nums: number[]): number {

};","(define/contract (find-valid-split nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec find_valid_split(Nums :: [integer()]) -> integer().
find_valid_split(Nums) ->
  .","defmodule Solution do
  @spec find_valid_split(nums :: [integer]) :: integer
  def find_valid_split(nums) do

  end
end","class Solution {
  int findValidSplit(List<int> nums) {

  }
}",
kth-largest-sum-in-a-binary-tree,Kth Largest Sum in a Binary Tree,2583.0,2646.0,"<p>You are given the <code>root</code> of a binary tree and a positive integer <code>k</code>.</p>

<p>The <strong>level sum</strong> in the tree is the sum of the values of the nodes that are on the <strong>same</strong> level.</p>

<p>Return<em> the </em><code>k<sup>th</sup></code><em> <strong>largest</strong> level sum in the tree (not necessarily distinct)</em>. If there are fewer than <code>k</code> levels in the tree, return <code>-1</code>.</p>

<p><strong>Note</strong> that two nodes are on the same level if they have the same distance from the root.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/12/14/binaryytreeedrawio-2.png"" style=""width: 301px; height: 284px;"" />
<pre>
<strong>Input:</strong> root = [5,8,9,2,1,3,7,4,6], k = 2
<strong>Output:</strong> 13
<strong>Explanation:</strong> The level sums are the following:
- Level 1: 5.
- Level 2: 8 + 9 = 17.
- Level 3: 2 + 1 + 3 + 7 = 13.
- Level 4: 4 + 6 = 10.
The 2<sup>nd</sup> largest level sum is 13.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/12/14/treedrawio-3.png"" style=""width: 181px; height: 181px;"" />
<pre>
<strong>Input:</strong> root = [1,2,null,3], k = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> The largest level sum is 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is <code>n</code>.</li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
",2.0,False,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        
    }
};","/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public long kthLargestLevelSum(TreeNode root, int k) {
        
    }
}","# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def kthLargestLevelSum(self, root, k):
        """"""
        :type root: Optional[TreeNode]
        :type k: int
        :rtype: int
        """"""
        ","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        ","/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
long long kthLargestLevelSum(struct TreeNode* root, int k){

}","/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public long KthLargestLevelSum(TreeNode root, int k) {
        
    }
}","/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthLargestLevelSum = function(root, k) {
    
};","# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @param {Integer} k
# @return {Integer}
def kth_largest_level_sum(root, k)
    
end","/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func kthLargestLevelSum(_ root: TreeNode?, _ k: Int) -> Int {
        
    }
}","/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func kthLargestLevelSum(root *TreeNode, k int) int64 {
    
}","/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    def kthLargestLevelSum(root: TreeNode, k: Int): Long = {
        
    }
}","/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */
class Solution {
    fun kthLargestLevelSum(root: TreeNode?, k: Int): Long {
        
    }
}","// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn kth_largest_level_sum(root: Option<Rc<RefCell<TreeNode>>>, k: i32) -> i64 {
        
    }
}","/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     public $val = null;
 *     public $left = null;
 *     public $right = null;
 *     function __construct($val = 0, $left = null, $right = null) {
 *         $this->val = $val;
 *         $this->left = $left;
 *         $this->right = $right;
 *     }
 * }
 */
class Solution {

    /**
     * @param TreeNode $root
     * @param Integer $k
     * @return Integer
     */
    function kthLargestLevelSum($root, $k) {
        
    }
}","/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function kthLargestLevelSum(root: TreeNode | null, k: number): number {

};","; Definition for a binary tree node.
#|

; val : integer?
; left : (or/c tree-node? #f)
; right : (or/c tree-node? #f)
(struct tree-node
  (val left right) #:mutable #:transparent)

; constructor
(define (make-tree-node [val 0])
  (tree-node val #f #f))

|#

(define/contract (kth-largest-level-sum root k)
  (-> (or/c tree-node? #f) exact-integer? exact-integer?)

  )","%% Definition for a binary tree node.
%%
%% -record(tree_node, {val = 0 :: integer(),
%%                     left = null  :: 'null' | #tree_node{},
%%                     right = null :: 'null' | #tree_node{}}).

-spec kth_largest_level_sum(Root :: #tree_node{} | null, K :: integer()) -> integer().
kth_largest_level_sum(Root, K) ->
  .","# Definition for a binary tree node.
#
# defmodule TreeNode do
#   @type t :: %__MODULE__{
#           val: integer,
#           left: TreeNode.t() | nil,
#           right: TreeNode.t() | nil
#         }
#   defstruct val: 0, left: nil, right: nil
# end

defmodule Solution do
  @spec kth_largest_level_sum(root :: TreeNode.t | nil, k :: integer) :: integer
  def kth_largest_level_sum(root, k) do

  end
end","/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   int val;
 *   TreeNode? left;
 *   TreeNode? right;
 *   TreeNode([this.val = 0, this.left, this.right]);
 * }
 */
class Solution {
  int kthLargestLevelSum(TreeNode? root, int k) {

  }
}",
pass-the-pillow,Pass the Pillow,2582.0,2645.0,"<p>There are <code>n</code> people standing in a line labeled from <code>1</code> to <code>n</code>. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.</p>

<ul>
	<li>For example, once the pillow reaches the <code>n<sup>th</sup></code> person they pass it to the <code>n - 1<sup>th</sup></code> person, then to the <code>n - 2<sup>th</sup></code> person and so on.</li>
</ul>

<p>Given the two positive integers <code>n</code> and <code>time</code>, return <em>the index of the person holding the pillow after </em><code>time</code><em> seconds</em>.</p>
<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 4, time = 5
<strong>Output:</strong> 2
<strong>Explanation:</strong> People pass the pillow in the following way: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 3 -&gt; 2.
Afer five seconds, the pillow is given to the 2<sup>nd</sup> person.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, time = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong> People pass the pillow in the following way: 1 -&gt; 2 -&gt; 3.
Afer two seconds, the pillow is given to the 3<sup>r</sup><sup>d</sup> person.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 1000</code></li>
	<li><code>1 &lt;= time &lt;= 1000</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int passThePillow(int n, int time) {
        
    }
};","class Solution {
    public int passThePillow(int n, int time) {
        
    }
}","class Solution(object):
    def passThePillow(self, n, time):
        """"""
        :type n: int
        :type time: int
        :rtype: int
        """"""
        ","class Solution:
    def passThePillow(self, n: int, time: int) -> int:
        ","int passThePillow(int n, int time){

}","public class Solution {
    public int PassThePillow(int n, int time) {
        
    }
}","/**
 * @param {number} n
 * @param {number} time
 * @return {number}
 */
var passThePillow = function(n, time) {
    
};","# @param {Integer} n
# @param {Integer} time
# @return {Integer}
def pass_the_pillow(n, time)
    
end","class Solution {
    func passThePillow(_ n: Int, _ time: Int) -> Int {
        
    }
}","func passThePillow(n int, time int) int {
    
}","object Solution {
    def passThePillow(n: Int, time: Int): Int = {
        
    }
}","class Solution {
    fun passThePillow(n: Int, time: Int): Int {
        
    }
}","impl Solution {
    pub fn pass_the_pillow(n: i32, time: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $time
     * @return Integer
     */
    function passThePillow($n, $time) {
        
    }
}","function passThePillow(n: number, time: number): number {

};","(define/contract (pass-the-pillow n time)
  (-> exact-integer? exact-integer? exact-integer?)

  )","-spec pass_the_pillow(N :: integer(), Time :: integer()) -> integer().
pass_the_pillow(N, Time) ->
  .","defmodule Solution do
  @spec pass_the_pillow(n :: integer, time :: integer) :: integer
  def pass_the_pillow(n, time) do

  end
end","class Solution {
  int passThePillow(int n, int time) {

  }
}",
time-to-cross-a-bridge,Time to Cross a Bridge,2532.0,2642.0,"<p>There are <code>k</code> workers who want to move <code>n</code> boxes from an old warehouse to a new one. You are given the two integers <code>n</code> and <code>k</code>, and a 2D integer array <code>time</code> of size <code>k x 4</code> where <code>time[i] = [leftToRight<sub>i</sub>, pickOld<sub>i</sub>, rightToLeft<sub>i</sub>, putNew<sub>i</sub>]</code>.</p>

<p>The warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all <code>k</code> workers are waiting on the left side of the bridge. To move the boxes, the <code>i<sup>th</sup></code> worker (<strong>0-indexed</strong>) can :</p>

<ul>
	<li>Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in <code>leftToRight<sub>i</sub></code> minutes.</li>
	<li>Pick a box from the old warehouse and return to the bridge in <code>pickOld<sub>i</sub></code> minutes. Different workers can pick up their boxes simultaneously.</li>
	<li>Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in <code>rightToLeft<sub>i</sub></code> minutes.</li>
	<li>Put the box in the new warehouse and return to the bridge in <code>putNew<sub>i</sub></code> minutes. Different workers can put their boxes simultaneously.</li>
</ul>

<p>A worker <code>i</code> is <strong>less efficient</strong> than a worker <code>j</code> if either condition is met:</p>

<ul>
	<li><code>leftToRight<sub>i</sub> + rightToLeft<sub>i</sub> &gt; leftToRight<sub>j</sub> + rightToLeft<sub>j</sub></code></li>
	<li><code>leftToRight<sub>i</sub> + rightToLeft<sub>i</sub> == leftToRight<sub>j</sub> + rightToLeft<sub>j</sub></code> and <code>i &gt; j</code></li>
</ul>

<p>The following rules regulate the movement of the workers through the bridge :</p>

<ul>
	<li>If a worker <code>x</code> reaches the bridge while another worker <code>y</code> is crossing the bridge, <code>x</code> waits at their side of the bridge.</li>
	<li>If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with <strong>the lowest efficiency</strong> crosses first.</li>
	<li>If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with <strong>the lowest efficiency</strong> crosses first.</li>
</ul>

<p>Return <em>the instance of time at which the last worker <strong>reaches the left bank</strong> of the river after all n boxes have been put in the new warehouse</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]
<strong>Output:</strong> 6
<strong>Explanation: </strong>
From 0 to 1: worker 2 crosses the bridge from the left bank to the right bank.
From 1 to 2: worker 2 picks up a box from the old warehouse.
From 2 to 6: worker 2 crosses the bridge from the right bank to the left bank.
From 6 to 7: worker 2 puts a box at the new warehouse.
The whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]
<strong>Output:</strong> 50
<strong>Explanation:</strong> 
From 0 &nbsp;to 10: worker 1 crosses the bridge from the left bank to the right bank.
From 10 to 20: worker 1 picks up a box from the old warehouse.
From 10 to 11: worker 0 crosses the bridge from the left bank to the right bank.
From 11 to 20: worker 0 picks up a box from the old warehouse.
From 20 to 30: worker 1 crosses the bridge from the right bank to the left bank.
From 30 to 40: worker 1 puts a box at the new warehouse.
From 30 to 31: worker 0 crosses the bridge from the right bank to the left bank.
From 31 to 39: worker 0 puts a box at the new warehouse.
From 39 to 40: worker 0 crosses the bridge from the left bank to the right bank.
From 40 to 49: worker 0 picks up a box from the old warehouse.
From 49 to 50: worker 0 crosses the bridge from the right bank to the left bank.
From 50 to 58: worker 0 puts a box at the new warehouse.
The whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n, k &lt;= 10<sup>4</sup></code></li>
	<li><code>time.length == k</code></li>
	<li><code>time[i].length == 4</code></li>
	<li><code>1 &lt;= leftToRight<sub>i</sub>, pickOld<sub>i</sub>, rightToLeft<sub>i</sub>, putNew<sub>i</sub> &lt;= 1000</code></li>
</ul>
",3.0,False,"class Solution {
public:
    int findCrossingTime(int n, int k, vector<vector<int>>& time) {
        
    }
};","class Solution {
    public int findCrossingTime(int n, int k, int[][] time) {
        
    }
}","class Solution(object):
    def findCrossingTime(self, n, k, time):
        """"""
        :type n: int
        :type k: int
        :type time: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:
        ","int findCrossingTime(int n, int k, int** time, int timeSize, int* timeColSize){

}","public class Solution {
    public int FindCrossingTime(int n, int k, int[][] time) {
        
    }
}","/**
 * @param {number} n
 * @param {number} k
 * @param {number[][]} time
 * @return {number}
 */
var findCrossingTime = function(n, k, time) {
    
};","# @param {Integer} n
# @param {Integer} k
# @param {Integer[][]} time
# @return {Integer}
def find_crossing_time(n, k, time)
    
end","class Solution {
    func findCrossingTime(_ n: Int, _ k: Int, _ time: [[Int]]) -> Int {
        
    }
}","func findCrossingTime(n int, k int, time [][]int) int {
    
}","object Solution {
    def findCrossingTime(n: Int, k: Int, time: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun findCrossingTime(n: Int, k: Int, time: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn find_crossing_time(n: i32, k: i32, time: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $k
     * @param Integer[][] $time
     * @return Integer
     */
    function findCrossingTime($n, $k, $time) {
        
    }
}","function findCrossingTime(n: number, k: number, time: number[][]): number {

};","(define/contract (find-crossing-time n k time)
  (-> exact-integer? exact-integer? (listof (listof exact-integer?)) exact-integer?)

  )","-spec find_crossing_time(N :: integer(), K :: integer(), Time :: [[integer()]]) -> integer().
find_crossing_time(N, K, Time) ->
  .","defmodule Solution do
  @spec find_crossing_time(n :: integer, k :: integer, time :: [[integer]]) :: integer
  def find_crossing_time(n, k, time) do

  end
end","class Solution {
  int findCrossingTime(int n, int k, List<List<int>> time) {

  }
}",
disconnect-path-in-a-binary-matrix-by-at-most-one-flip,Disconnect Path in a Binary Matrix by at Most One Flip,2556.0,2641.0,"<p>You are given a <strong>0-indexed</strong> <code>m x n</code> <strong>binary</strong> matrix <code>grid</code>. You can move from a cell <code>(row, col)</code> to any of the cells <code>(row + 1, col)</code> or <code>(row, col + 1)</code> that has the value <code>1</code>.&nbsp;The matrix is <strong>disconnected</strong> if there is no path from <code>(0, 0)</code> to <code>(m - 1, n - 1)</code>.</p>

<p>You can flip the value of <strong>at most one</strong> (possibly none) cell. You <strong>cannot flip</strong> the cells <code>(0, 0)</code> and <code>(m - 1, n - 1)</code>.</p>

<p>Return <code>true</code> <em>if it is possible to make the matrix disconnect or </em><code>false</code><em> otherwise</em>.</p>

<p><strong>Note</strong> that flipping a cell changes its value from <code>0</code> to <code>1</code> or from <code>1</code> to <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/12/07/yetgrid2drawio.png"" style=""width: 441px; height: 151px;"" />
<pre>
<strong>Input:</strong> grid = [[1,1,1],[1,0,0],[1,1,1]]
<strong>Output:</strong> true
<strong>Explanation:</strong> We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/12/07/yetgrid3drawio.png"" />
<pre>
<strong>Input:</strong> grid = [[1,1,1],[1,0,1],[1,1,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>grid[0][0] == grid[m - 1][n - 1] == 1</code></li>
</ul>
",2.0,False,"class Solution {
public:
    bool isPossibleToCutPath(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public boolean isPossibleToCutPath(int[][] grid) {
        
    }
}","class Solution(object):
    def isPossibleToCutPath(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: bool
        """"""
        ","class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        ","bool isPossibleToCutPath(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public bool IsPossibleToCutPath(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {boolean}
 */
var isPossibleToCutPath = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Boolean}
def is_possible_to_cut_path(grid)
    
end","class Solution {
    func isPossibleToCutPath(_ grid: [[Int]]) -> Bool {
        
    }
}","func isPossibleToCutPath(grid [][]int) bool {
    
}","object Solution {
    def isPossibleToCutPath(grid: Array[Array[Int]]): Boolean = {
        
    }
}","class Solution {
    fun isPossibleToCutPath(grid: Array<IntArray>): Boolean {
        
    }
}","impl Solution {
    pub fn is_possible_to_cut_path(grid: Vec<Vec<i32>>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Boolean
     */
    function isPossibleToCutPath($grid) {
        
    }
}","function isPossibleToCutPath(grid: number[][]): boolean {

};","(define/contract (is-possible-to-cut-path grid)
  (-> (listof (listof exact-integer?)) boolean?)

  )","-spec is_possible_to_cut_path(Grid :: [[integer()]]) -> boolean().
is_possible_to_cut_path(Grid) ->
  .","defmodule Solution do
  @spec is_possible_to_cut_path(grid :: [[integer]]) :: boolean
  def is_possible_to_cut_path(grid) do

  end
end","class Solution {
  bool isPossibleToCutPath(List<List<int>> grid) {

  }
}",
maximum-number-of-integers-to-choose-from-a-range-i,Maximum Number of Integers to Choose From a Range I,2554.0,2640.0,"<p>You are given an integer array <code>banned</code> and two integers <code>n</code> and <code>maxSum</code>. You are choosing some number of integers following the below rules:</p>

<ul>
	<li>The chosen integers have to be in the range <code>[1, n]</code>.</li>
	<li>Each integer can be chosen <strong>at most once</strong>.</li>
	<li>The chosen integers should not be in the array <code>banned</code>.</li>
	<li>The sum of the chosen integers should not exceed <code>maxSum</code>.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of integers you can choose following the mentioned rules</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> banned = [1,6,5], n = 5, maxSum = 6
<strong>Output:</strong> 2
<strong>Explanation:</strong> You can choose the integers 2 and 4.
2 and 4 are from the range [1, 5], both did not appear in banned, and their sum is 6, which did not exceed maxSum.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> You cannot choose any integer while following the mentioned conditions.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> banned = [11], n = 7, maxSum = 50
<strong>Output:</strong> 7
<strong>Explanation:</strong> You can choose the integers 1, 2, 3, 4, 5, 6, and 7.
They are from the range [1, 7], all did not appear in banned, and their sum is 28, which did not exceed maxSum.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= banned.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= banned[i], n &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= maxSum &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int maxCount(vector<int>& banned, int n, int maxSum) {
        
    }
};","class Solution {
    public int maxCount(int[] banned, int n, int maxSum) {
        
    }
}","class Solution(object):
    def maxCount(self, banned, n, maxSum):
        """"""
        :type banned: List[int]
        :type n: int
        :type maxSum: int
        :rtype: int
        """"""
        ","class Solution:
    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:
        ","int maxCount(int* banned, int bannedSize, int n, int maxSum){

}","public class Solution {
    public int MaxCount(int[] banned, int n, int maxSum) {
        
    }
}","/**
 * @param {number[]} banned
 * @param {number} n
 * @param {number} maxSum
 * @return {number}
 */
var maxCount = function(banned, n, maxSum) {
    
};","# @param {Integer[]} banned
# @param {Integer} n
# @param {Integer} max_sum
# @return {Integer}
def max_count(banned, n, max_sum)
    
end","class Solution {
    func maxCount(_ banned: [Int], _ n: Int, _ maxSum: Int) -> Int {
        
    }
}","func maxCount(banned []int, n int, maxSum int) int {
    
}","object Solution {
    def maxCount(banned: Array[Int], n: Int, maxSum: Int): Int = {
        
    }
}","class Solution {
    fun maxCount(banned: IntArray, n: Int, maxSum: Int): Int {
        
    }
}","impl Solution {
    pub fn max_count(banned: Vec<i32>, n: i32, max_sum: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $banned
     * @param Integer $n
     * @param Integer $maxSum
     * @return Integer
     */
    function maxCount($banned, $n, $maxSum) {
        
    }
}","function maxCount(banned: number[], n: number, maxSum: number): number {

};","(define/contract (max-count banned n maxSum)
  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)

  )","-spec max_count(Banned :: [integer()], N :: integer(), MaxSum :: integer()) -> integer().
max_count(Banned, N, MaxSum) ->
  .","defmodule Solution do
  @spec max_count(banned :: [integer], n :: integer, max_sum :: integer) :: integer
  def max_count(banned, n, max_sum) do

  end
end","class Solution {
  int maxCount(List<int> banned, int n, int maxSum) {

  }
}",
separate-the-digits-in-an-array,Separate the Digits in an Array,2553.0,2639.0,"<p>Given an array of positive integers <code>nums</code>, return <em>an array </em><code>answer</code><em> that consists of the digits of each integer in </em><code>nums</code><em> after separating them in <strong>the same order</strong> they appear in </em><code>nums</code>.</p>

<p>To separate the digits of an integer is to get all the digits it has in the same order.</p>

<ul>
	<li>For example, for the integer <code>10921</code>, the separation of its digits is <code>[1,0,9,2,1]</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [13,25,83,77]
<strong>Output:</strong> [1,3,2,5,8,3,7,7]
<strong>Explanation:</strong> 
- The separation of 13 is [1,3].
- The separation of 25 is [2,5].
- The separation of 83 is [8,3].
- The separation of 77 is [7,7].
answer = [1,3,2,5,8,3,7,7]. Note that answer contains the separations in the same order.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,1,3,9]
<strong>Output:</strong> [7,1,3,9]
<strong>Explanation:</strong> The separation of each integer in nums is itself.
answer = [7,1,3,9].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
",1.0,False,"class Solution {
public:
    vector<int> separateDigits(vector<int>& nums) {
        
    }
};","class Solution {
    public int[] separateDigits(int[] nums) {
        
    }
}","class Solution(object):
    def separateDigits(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def separateDigits(self, nums: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* separateDigits(int* nums, int numsSize, int* returnSize){

}","public class Solution {
    public int[] SeparateDigits(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number[]}
 */
var separateDigits = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer[]}
def separate_digits(nums)
    
end","class Solution {
    func separateDigits(_ nums: [Int]) -> [Int] {
        
    }
}","func separateDigits(nums []int) []int {
    
}","object Solution {
    def separateDigits(nums: Array[Int]): Array[Int] = {
        
    }
}","class Solution {
    fun separateDigits(nums: IntArray): IntArray {
        
    }
}","impl Solution {
    pub fn separate_digits(nums: Vec<i32>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function separateDigits($nums) {
        
    }
}","function separateDigits(nums: number[]): number[] {

};","(define/contract (separate-digits nums)
  (-> (listof exact-integer?) (listof exact-integer?))

  )","-spec separate_digits(Nums :: [integer()]) -> [integer()].
separate_digits(Nums) ->
  .","defmodule Solution do
  @spec separate_digits(nums :: [integer]) :: [integer]
  def separate_digits(nums) do

  end
end","class Solution {
  List<int> separateDigits(List<int> nums) {

  }
}",
maximum-subsequence-score,Maximum Subsequence Score,2542.0,2636.0,"<p>You are given two <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code> of equal length <code>n</code> and a positive integer <code>k</code>. You must choose a <strong>subsequence</strong> of indices from <code>nums1</code> of length <code>k</code>.</p>

<p>For chosen indices <code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, ..., <code>i<sub>k - 1</sub></code>, your <strong>score</strong> is defined as:</p>

<ul>
	<li>The sum of the selected elements from <code>nums1</code> multiplied with the <strong>minimum</strong> of the selected elements from <code>nums2</code>.</li>
	<li>It can defined simply as: <code>(nums1[i<sub>0</sub>] + nums1[i<sub>1</sub>] +...+ nums1[i<sub>k - 1</sub>]) * min(nums2[i<sub>0</sub>] , nums2[i<sub>1</sub>], ... ,nums2[i<sub>k - 1</sub>])</code>.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> possible score.</em></p>

<p>A <strong>subsequence</strong> of indices of an array is a set that can be derived from the set <code>{0, 1, ..., n-1}</code> by deleting some or no elements.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3
<strong>Output:</strong> 12
<strong>Explanation:</strong> 
The four possible subsequence scores are:
- We choose the indices 0, 1, and 2 with score = (1+3+3) * min(2,1,3) = 7.
- We choose the indices 0, 1, and 3 with score = (1+3+2) * min(2,1,4) = 6. 
- We choose the indices 0, 2, and 3 with score = (1+3+2) * min(2,3,4) = 12. 
- We choose the indices 1, 2, and 3 with score = (3+3+2) * min(1,3,4) = 8.
Therefore, we return the max score, which is 12.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1
<strong>Output:</strong> 30
<strong>Explanation:</strong> 
Choosing index 2 is optimal: nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible score.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums1.length == nums2.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {
        
    }
};","class Solution {
    public long maxScore(int[] nums1, int[] nums2, int k) {
        
    }
}","class Solution(object):
    def maxScore(self, nums1, nums2, k):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:
        ","long long maxScore(int* nums1, int nums1Size, int* nums2, int nums2Size, int k){

}","public class Solution {
    public long MaxScore(int[] nums1, int[] nums2, int k) {
        
    }
}","/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number}
 */
var maxScore = function(nums1, nums2, k) {
    
};","# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @param {Integer} k
# @return {Integer}
def max_score(nums1, nums2, k)
    
end","class Solution {
    func maxScore(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> Int {
        
    }
}","func maxScore(nums1 []int, nums2 []int, k int) int64 {
    
}","object Solution {
    def maxScore(nums1: Array[Int], nums2: Array[Int], k: Int): Long = {
        
    }
}","class Solution {
    fun maxScore(nums1: IntArray, nums2: IntArray, k: Int): Long {
        
    }
}","impl Solution {
    pub fn max_score(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @param Integer $k
     * @return Integer
     */
    function maxScore($nums1, $nums2, $k) {
        
    }
}","function maxScore(nums1: number[], nums2: number[], k: number): number {

};","(define/contract (max-score nums1 nums2 k)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec max_score(Nums1 :: [integer()], Nums2 :: [integer()], K :: integer()) -> integer().
max_score(Nums1, Nums2, K) ->
  .","defmodule Solution do
  @spec max_score(nums1 :: [integer], nums2 :: [integer], k :: integer) :: integer
  def max_score(nums1, nums2, k) do

  end
end","class Solution {
  int maxScore(List<int> nums1, List<int> nums2, int k) {

  }
}",
check-if-point-is-reachable,Check if Point Is Reachable,2543.0,2635.0,"<p>There exists an infinitely large grid. You are currently at point <code>(1, 1)</code>, and you need to reach the point <code>(targetX, targetY)</code> using a finite number of steps.</p>

<p>In one <strong>step</strong>, you can move from point <code>(x, y)</code> to any one of the following points:</p>

<ul>
	<li><code>(x, y - x)</code></li>
	<li><code>(x - y, y)</code></li>
	<li><code>(2 * x, y)</code></li>
	<li><code>(x, 2 * y)</code></li>
</ul>

<p>Given two integers <code>targetX</code> and <code>targetY</code> representing the X-coordinate and Y-coordinate of your final position, return <code>true</code> <em>if you can reach the point from</em> <code>(1, 1)</code> <em>using some number of steps, and </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> targetX = 6, targetY = 9
<strong>Output:</strong> false
<strong>Explanation:</strong> It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> targetX = 4, targetY = 7
<strong>Output:</strong> true
<strong>Explanation:</strong> You can follow the path (1,1) -&gt; (1,2) -&gt; (1,4) -&gt; (1,8) -&gt; (1,7) -&gt; (2,7) -&gt; (4,7).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= targetX, targetY&nbsp;&lt;= 10<sup>9</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    bool isReachable(int targetX, int targetY) {
        
    }
};","class Solution {
    public boolean isReachable(int targetX, int targetY) {
        
    }
}","class Solution(object):
    def isReachable(self, targetX, targetY):
        """"""
        :type targetX: int
        :type targetY: int
        :rtype: bool
        """"""
        ","class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        ","bool isReachable(int targetX, int targetY){

}","public class Solution {
    public bool IsReachable(int targetX, int targetY) {
        
    }
}","/**
 * @param {number} targetX
 * @param {number} targetY
 * @return {boolean}
 */
var isReachable = function(targetX, targetY) {
    
};","# @param {Integer} target_x
# @param {Integer} target_y
# @return {Boolean}
def is_reachable(target_x, target_y)
    
end","class Solution {
    func isReachable(_ targetX: Int, _ targetY: Int) -> Bool {
        
    }
}","func isReachable(targetX int, targetY int) bool {
    
}","object Solution {
    def isReachable(targetX: Int, targetY: Int): Boolean = {
        
    }
}","class Solution {
    fun isReachable(targetX: Int, targetY: Int): Boolean {
        
    }
}","impl Solution {
    pub fn is_reachable(target_x: i32, target_y: i32) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer $targetX
     * @param Integer $targetY
     * @return Boolean
     */
    function isReachable($targetX, $targetY) {
        
    }
}","function isReachable(targetX: number, targetY: number): boolean {

};","(define/contract (is-reachable targetX targetY)
  (-> exact-integer? exact-integer? boolean?)

  )","-spec is_reachable(TargetX :: integer(), TargetY :: integer()) -> boolean().
is_reachable(TargetX, TargetY) ->
  .","defmodule Solution do
  @spec is_reachable(target_x :: integer, target_y :: integer) :: boolean
  def is_reachable(target_x, target_y) do

  end
end","class Solution {
  bool isReachable(int targetX, int targetY) {

  }
}",
minimum-common-value,Minimum Common Value,2540.0,2634.0,"<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in non-decreasing order, return <em>the <strong>minimum integer common</strong> to both arrays</em>. If there is no common integer amongst <code>nums1</code> and <code>nums2</code>, return <code>-1</code>.</p>

<p>Note that an integer is said to be <strong>common</strong> to <code>nums1</code> and <code>nums2</code> if both arrays have <strong>at least one</strong> occurrence of that integer.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3], nums2 = [2,4]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The smallest element common to both arrays is 2, so we return 2.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3,6], nums2 = [2,3,4,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>
	<li>Both <code>nums1</code> and <code>nums2</code> are sorted in <strong>non-decreasing</strong> order.</li>
</ul>
",1.0,False,"class Solution {
public:
    int getCommon(vector<int>& nums1, vector<int>& nums2) {
        
    }
};","class Solution {
    public int getCommon(int[] nums1, int[] nums2) {
        
    }
}","class Solution(object):
    def getCommon(self, nums1, nums2):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:
        ","int getCommon(int* nums1, int nums1Size, int* nums2, int nums2Size){

}","public class Solution {
    public int GetCommon(int[] nums1, int[] nums2) {
        
    }
}","/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var getCommon = function(nums1, nums2) {
    
};","# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @return {Integer}
def get_common(nums1, nums2)
    
end","class Solution {
    func getCommon(_ nums1: [Int], _ nums2: [Int]) -> Int {
        
    }
}","func getCommon(nums1 []int, nums2 []int) int {
    
}","object Solution {
    def getCommon(nums1: Array[Int], nums2: Array[Int]): Int = {
        
    }
}","class Solution {
    fun getCommon(nums1: IntArray, nums2: IntArray): Int {
        
    }
}","impl Solution {
    pub fn get_common(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @return Integer
     */
    function getCommon($nums1, $nums2) {
        
    }
}","function getCommon(nums1: number[], nums2: number[]): number {

};","(define/contract (get-common nums1 nums2)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)

  )","-spec get_common(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().
get_common(Nums1, Nums2) ->
  .","defmodule Solution do
  @spec get_common(nums1 :: [integer], nums2 :: [integer]) :: integer
  def get_common(nums1, nums2) do

  end
end","class Solution {
  int getCommon(List<int> nums1, List<int> nums2) {

  }
}",
minimum-cost-to-split-an-array,Minimum Cost to Split an Array,2547.0,2633.0,"<p>You are given an integer array <code>nums</code> and an integer <code>k</code>.</p>

<p>Split the array into some number of non-empty subarrays. The <strong>cost</strong> of a split is the sum of the <strong>importance value</strong> of each subarray in the split.</p>

<p>Let <code>trimmed(subarray)</code> be the version of the subarray where all numbers which appear only once are removed.</p>

<ul>
	<li>For example, <code>trimmed([3,1,2,4,3,4]) = [3,4,3,4].</code></li>
</ul>

<p>The <strong>importance value</strong> of a subarray is <code>k + trimmed(subarray).length</code>.</p>

<ul>
	<li>For example, if a subarray is <code>[1,2,3,3,3,4,4]</code>, then <font face=""monospace"">trimmed(</font><code>[1,2,3,3,3,4,4]) = [3,3,3,4,4].</code>The importance value of this subarray will be <code>k + 5</code>.</li>
</ul>

<p>Return <em>the minimum possible cost of a split of </em><code>nums</code>.</p>

<p>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,2,1,3,3], k = 2
<strong>Output:</strong> 8
<strong>Explanation:</strong> We split nums to have two subarrays: [1,2], [1,2,1,3,3].
The importance value of [1,2] is 2 + (0) = 2.
The importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.
The cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,2,1], k = 2
<strong>Output:</strong> 6
<strong>Explanation:</strong> We split nums to have two subarrays: [1,2], [1,2,1].
The importance value of [1,2] is 2 + (0) = 2.
The importance value of [1,2,1] is 2 + (2) = 4.
The cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,2,1], k = 5
<strong>Output:</strong> 10
<strong>Explanation:</strong> We split nums to have one subarray: [1,2,1,2,1].
The importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.
The cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<style type=""text/css"">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value=""Show Message""] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value=""Hide Message""] + .spoiler {padding:5px;}
</style>
",3.0,False,"class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int minCost(int[] nums, int k) {
        
    }
}","class Solution(object):
    def minCost(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def minCost(self, nums: List[int], k: int) -> int:
        ","int minCost(int* nums, int numsSize, int k){

}","public class Solution {
    public int MinCost(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var minCost = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def min_cost(nums, k)
    
end","class Solution {
    func minCost(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func minCost(nums []int, k int) int {
    
}","object Solution {
    def minCost(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun minCost(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn min_cost(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function minCost($nums, $k) {
        
    }
}","function minCost(nums: number[], k: number): number {

};","(define/contract (min-cost nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec min_cost(Nums :: [integer()], K :: integer()) -> integer().
min_cost(Nums, K) ->
  .","defmodule Solution do
  @spec min_cost(nums :: [integer], k :: integer) :: integer
  def min_cost(nums, k) do

  end
end","class Solution {
  int minCost(List<int> nums, int k) {

  }
}",
apply-bitwise-operations-to-make-strings-equal,Apply Bitwise Operations to Make Strings Equal,2546.0,2632.0,"<p>You are given two <strong>0-indexed binary</strong> strings <code>s</code> and <code>target</code> of the same length <code>n</code>. You can do the following operation on <code>s</code> <strong>any</strong> number of times:</p>

<ul>
	<li>Choose two <strong>different</strong> indices <code>i</code> and <code>j</code> where <code>0 &lt;= i, j &lt; n</code>.</li>
	<li>Simultaneously, replace <code>s[i]</code> with (<code>s[i]</code> <strong>OR</strong> <code>s[j]</code>) and <code>s[j]</code> with (<code>s[i]</code> <strong>XOR</strong> <code>s[j]</code>).</li>
</ul>

<p>For example, if <code>s = &quot;0110&quot;</code>, you can choose <code>i = 0</code> and <code>j = 2</code>, then simultaneously replace <code>s[0]</code> with (<code>s[0]</code> <strong>OR</strong> <code>s[2]</code> = <code>0</code> <strong>OR</strong> <code>1</code> = <code>1</code>), and <code>s[2]</code> with (<code>s[0]</code> <strong>XOR</strong> <code>s[2]</code> = <code>0</code> <strong>XOR</strong> <code>1</code> = <code>1</code>), so we will have <code>s = &quot;1110&quot;</code>.</p>

<p>Return <code>true</code> <em>if you can make the string </em><code>s</code><em> equal to </em><code>target</code><em>, or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;1010&quot;, target = &quot;0110&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> We can do the following operations:
- Choose i = 2 and j = 0. We have now s = &quot;<strong><u>0</u></strong>0<strong><u>1</u></strong>0&quot;.
- Choose i = 2 and j = 1. We have now s = &quot;0<strong><u>11</u></strong>0&quot;.
Since we can make s equal to target, we return true.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;11&quot;, target = &quot;00&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> It is not possible to make s equal to target with any number of operations.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == s.length == target.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> and <code>target</code> consist of only the digits <code>0</code> and <code>1</code>.</li>
</ul>
",2.0,False,"class Solution {
public:
    bool makeStringsEqual(string s, string target) {
        
    }
};","class Solution {
    public boolean makeStringsEqual(String s, String target) {
        
    }
}","class Solution(object):
    def makeStringsEqual(self, s, target):
        """"""
        :type s: str
        :type target: str
        :rtype: bool
        """"""
        ","class Solution:
    def makeStringsEqual(self, s: str, target: str) -> bool:
        ","bool makeStringsEqual(char * s, char * target){

}","public class Solution {
    public bool MakeStringsEqual(string s, string target) {
        
    }
}","/**
 * @param {string} s
 * @param {string} target
 * @return {boolean}
 */
var makeStringsEqual = function(s, target) {
    
};","# @param {String} s
# @param {String} target
# @return {Boolean}
def make_strings_equal(s, target)
    
end","class Solution {
    func makeStringsEqual(_ s: String, _ target: String) -> Bool {
        
    }
}","func makeStringsEqual(s string, target string) bool {
    
}","object Solution {
    def makeStringsEqual(s: String, target: String): Boolean = {
        
    }
}","class Solution {
    fun makeStringsEqual(s: String, target: String): Boolean {
        
    }
}","impl Solution {
    pub fn make_strings_equal(s: String, target: String) -> bool {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param String $target
     * @return Boolean
     */
    function makeStringsEqual($s, $target) {
        
    }
}","function makeStringsEqual(s: string, target: string): boolean {

};","(define/contract (make-strings-equal s target)
  (-> string? string? boolean?)

  )","-spec make_strings_equal(S :: unicode:unicode_binary(), Target :: unicode:unicode_binary()) -> boolean().
make_strings_equal(S, Target) ->
  .","defmodule Solution do
  @spec make_strings_equal(s :: String.t, target :: String.t) :: boolean
  def make_strings_equal(s, target) do

  end
end","class Solution {
  bool makeStringsEqual(String s, String target) {

  }
}",
sort-the-students-by-their-kth-score,Sort the Students by Their Kth Score,2545.0,2631.0,"<p>There is a class with <code>m</code> students and <code>n</code> exams. You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>score</code>, where each row represents one student and <code>score[i][j]</code> denotes the score the <code>i<sup>th</sup></code> student got in the <code>j<sup>th</sup></code> exam. The matrix <code>score</code> contains <strong>distinct</strong> integers only.</p>

<p>You are also given an integer <code>k</code>. Sort the students (i.e., the rows of the matrix) by their scores in the <code>k<sup>th</sup></code>&nbsp;(<strong>0-indexed</strong>) exam from the highest to the lowest.</p>

<p>Return <em>the matrix after sorting it.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/11/30/example1.png"" style=""width: 600px; height: 136px;"" />
<pre>
<strong>Input:</strong> score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2
<strong>Output:</strong> [[7,5,11,2],[10,6,9,1],[4,8,3,15]]
<strong>Explanation:</strong> In the above diagram, S denotes the student, while E denotes the exam.
- The student with index 1 scored 11 in exam 2, which is the highest score, so they got first place.
- The student with index 0 scored 9 in exam 2, which is the second highest score, so they got second place.
- The student with index 2 scored 3 in exam 2, which is the lowest score, so they got third place.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/11/30/example2.png"" style=""width: 486px; height: 121px;"" />
<pre>
<strong>Input:</strong> score = [[3,4],[5,6]], k = 0
<strong>Output:</strong> [[5,6],[3,4]]
<strong>Explanation:</strong> In the above diagram, S denotes the student, while E denotes the exam.
- The student with index 1 scored 5 in exam 0, which is the highest score, so they got first place.
- The student with index 0 scored 3 in exam 0, which is the lowest score, so they got second place.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == score.length</code></li>
	<li><code>n == score[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 250</code></li>
	<li><code>1 &lt;= score[i][j] &lt;= 10<sup>5</sup></code></li>
	<li><code>score</code> consists of <strong>distinct</strong> integers.</li>
	<li><code>0 &lt;= k &lt; n</code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<vector<int>> sortTheStudents(vector<vector<int>>& score, int k) {
        
    }
};","class Solution {
    public int[][] sortTheStudents(int[][] score, int k) {
        
    }
}","class Solution(object):
    def sortTheStudents(self, score, k):
        """"""
        :type score: List[List[int]]
        :type k: int
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** sortTheStudents(int** score, int scoreSize, int* scoreColSize, int k, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public int[][] SortTheStudents(int[][] score, int k) {
        
    }
}","/**
 * @param {number[][]} score
 * @param {number} k
 * @return {number[][]}
 */
var sortTheStudents = function(score, k) {
    
};","# @param {Integer[][]} score
# @param {Integer} k
# @return {Integer[][]}
def sort_the_students(score, k)
    
end","class Solution {
    func sortTheStudents(_ score: [[Int]], _ k: Int) -> [[Int]] {
        
    }
}","func sortTheStudents(score [][]int, k int) [][]int {
    
}","object Solution {
    def sortTheStudents(score: Array[Array[Int]], k: Int): Array[Array[Int]] = {
        
    }
}","class Solution {
    fun sortTheStudents(score: Array<IntArray>, k: Int): Array<IntArray> {
        
    }
}","impl Solution {
    pub fn sort_the_students(score: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $score
     * @param Integer $k
     * @return Integer[][]
     */
    function sortTheStudents($score, $k) {
        
    }
}","function sortTheStudents(score: number[][], k: number): number[][] {

};","(define/contract (sort-the-students score k)
  (-> (listof (listof exact-integer?)) exact-integer? (listof (listof exact-integer?)))

  )","-spec sort_the_students(Score :: [[integer()]], K :: integer()) -> [[integer()]].
sort_the_students(Score, K) ->
  .","defmodule Solution do
  @spec sort_the_students(score :: [[integer]], k :: integer) :: [[integer]]
  def sort_the_students(score, k) do

  end
end","class Solution {
  List<List<int>> sortTheStudents(List<List<int>> score, int k) {

  }
}",
alternating-digit-sum,Alternating Digit Sum,2544.0,2630.0,"<p>You are given a positive integer <code>n</code>. Each digit of <code>n</code> has a sign according to the following rules:</p>

<ul>
	<li>The <strong>most significant digit</strong> is assigned a <strong>positive</strong> sign.</li>
	<li>Each other digit has an opposite sign to its adjacent digits.</li>
</ul>

<p>Return <em>the sum of all digits with their corresponding sign</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 521
<strong>Output:</strong> 4
<strong>Explanation:</strong> (+5) + (-2) + (+1) = 4.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 111
<strong>Output:</strong> 1
<strong>Explanation:</strong> (+1) + (-1) + (+1) = 1.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 886996
<strong>Output:</strong> 0
<strong>Explanation:</strong> (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<style type=""text/css"">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value=""Show Message""] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value=""Hide Message""] + .spoiler {padding:5px;}
</style>
",1.0,False,"class Solution {
public:
    int alternateDigitSum(int n) {
        
    }
};","class Solution {
    public int alternateDigitSum(int n) {
        
    }
}","class Solution(object):
    def alternateDigitSum(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def alternateDigitSum(self, n: int) -> int:
        ","int alternateDigitSum(int n){

}","public class Solution {
    public int AlternateDigitSum(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var alternateDigitSum = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def alternate_digit_sum(n)
    
end","class Solution {
    func alternateDigitSum(_ n: Int) -> Int {
        
    }
}","func alternateDigitSum(n int) int {
    
}","object Solution {
    def alternateDigitSum(n: Int): Int = {
        
    }
}","class Solution {
    fun alternateDigitSum(n: Int): Int {
        
    }
}","impl Solution {
    pub fn alternate_digit_sum(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function alternateDigitSum($n) {
        
    }
}","function alternateDigitSum(n: number): number {

};","(define/contract (alternate-digit-sum n)
  (-> exact-integer? exact-integer?)

  )","-spec alternate_digit_sum(N :: integer()) -> integer().
alternate_digit_sum(N) ->
  .","defmodule Solution do
  @spec alternate_digit_sum(n :: integer) :: integer
  def alternate_digit_sum(n) do

  end
end","class Solution {
  int alternateDigitSum(int n) {

  }
}",
minimize-the-maximum-of-two-arrays,Minimize the Maximum of Two Arrays,2513.0,2628.0,"<p>We have two arrays <code>arr1</code> and <code>arr2</code> which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions:</p>

<ul>
	<li><code>arr1</code> contains <code>uniqueCnt1</code> <strong>distinct</strong> positive integers, each of which is <strong>not divisible</strong> by <code>divisor1</code>.</li>
	<li><code>arr2</code> contains <code>uniqueCnt2</code> <strong>distinct</strong> positive integers, each of which is <strong>not divisible</strong> by <code>divisor2</code>.</li>
	<li><strong>No</strong> integer is present in both <code>arr1</code> and <code>arr2</code>.</li>
</ul>

<p>Given <code>divisor1</code>, <code>divisor2</code>, <code>uniqueCnt1</code>, and <code>uniqueCnt2</code>, return <em>the <strong>minimum possible maximum</strong> integer that can be present in either array</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
We can distribute the first 4 natural numbers into arr1 and arr2.
arr1 = [1] and arr2 = [2,3,4].
We can see that both arrays satisfy all the conditions.
Since the maximum value is 4, we return it.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
Here arr1 = [1,2], and arr2 = [3] satisfy all conditions.
Since the maximum value is 3, we return it.</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2
<strong>Output:</strong> 15
<strong>Explanation:</strong> 
Here, the final possible arrays can be arr1 = [1,3,5,7,9,11,13,15], and arr2 = [2,6].
It can be shown that it is not possible to obtain a lower maximum satisfying all conditions. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= divisor1, divisor2 &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= uniqueCnt1, uniqueCnt2 &lt; 10<sup>9</sup></code></li>
	<li><code>2 &lt;= uniqueCnt1 + uniqueCnt2 &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {
        
    }
};","class Solution {
    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {
        
    }
}","class Solution(object):
    def minimizeSet(self, divisor1, divisor2, uniqueCnt1, uniqueCnt2):
        """"""
        :type divisor1: int
        :type divisor2: int
        :type uniqueCnt1: int
        :type uniqueCnt2: int
        :rtype: int
        """"""
        ","class Solution:
    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:
        ","int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2){

}","public class Solution {
    public int MinimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {
        
    }
}","/**
 * @param {number} divisor1
 * @param {number} divisor2
 * @param {number} uniqueCnt1
 * @param {number} uniqueCnt2
 * @return {number}
 */
var minimizeSet = function(divisor1, divisor2, uniqueCnt1, uniqueCnt2) {
    
};","# @param {Integer} divisor1
# @param {Integer} divisor2
# @param {Integer} unique_cnt1
# @param {Integer} unique_cnt2
# @return {Integer}
def minimize_set(divisor1, divisor2, unique_cnt1, unique_cnt2)
    
end","class Solution {
    func minimizeSet(_ divisor1: Int, _ divisor2: Int, _ uniqueCnt1: Int, _ uniqueCnt2: Int) -> Int {
        
    }
}","func minimizeSet(divisor1 int, divisor2 int, uniqueCnt1 int, uniqueCnt2 int) int {
    
}","object Solution {
    def minimizeSet(divisor1: Int, divisor2: Int, uniqueCnt1: Int, uniqueCnt2: Int): Int = {
        
    }
}","class Solution {
    fun minimizeSet(divisor1: Int, divisor2: Int, uniqueCnt1: Int, uniqueCnt2: Int): Int {
        
    }
}","impl Solution {
    pub fn minimize_set(divisor1: i32, divisor2: i32, unique_cnt1: i32, unique_cnt2: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $divisor1
     * @param Integer $divisor2
     * @param Integer $uniqueCnt1
     * @param Integer $uniqueCnt2
     * @return Integer
     */
    function minimizeSet($divisor1, $divisor2, $uniqueCnt1, $uniqueCnt2) {
        
    }
}","function minimizeSet(divisor1: number, divisor2: number, uniqueCnt1: number, uniqueCnt2: number): number {

};","(define/contract (minimize-set divisor1 divisor2 uniqueCnt1 uniqueCnt2)
  (-> exact-integer? exact-integer? exact-integer? exact-integer? exact-integer?)

  )","-spec minimize_set(Divisor1 :: integer(), Divisor2 :: integer(), UniqueCnt1 :: integer(), UniqueCnt2 :: integer()) -> integer().
minimize_set(Divisor1, Divisor2, UniqueCnt1, UniqueCnt2) ->
  .","defmodule Solution do
  @spec minimize_set(divisor1 :: integer, divisor2 :: integer, unique_cnt1 :: integer, unique_cnt2 :: integer) :: integer
  def minimize_set(divisor1, divisor2, unique_cnt1, unique_cnt2) do

  end
end","class Solution {
  int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {

  }
}",
difference-between-maximum-and-minimum-price-sum,Difference Between Maximum and Minimum Price Sum,2538.0,2627.0,"<p>There exists an undirected and initially unrooted tree with <code>n</code> nodes indexed from <code>0</code> to <code>n - 1</code>. You are given the integer <code>n</code> and a 2D integer array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>

<p>Each node has an associated price. You are given an integer array <code>price</code>, where <code>price[i]</code> is the price of the <code>i<sup>th</sup></code> node.</p>

<p>The <strong>price sum</strong> of a given path is the sum of the prices of all nodes lying on that path.</p>

<p>The tree can be rooted at any node <code>root</code> of your choice. The incurred <strong>cost</strong> after choosing <code>root</code> is the difference between the maximum and minimum <strong>price sum</strong> amongst all paths starting at <code>root</code>.</p>

<p>Return <em>the <strong>maximum</strong> possible <strong>cost</strong></em> <em>amongst all possible root choices</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/12/01/example14.png"" style=""width: 556px; height: 231px;"" />
<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]
<strong>Output:</strong> 24
<strong>Explanation:</strong> The diagram above denotes the tree after rooting it at node 2. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.
- The first path contains nodes [2,1,3,4]: the prices are [7,8,6,10], and the sum of the prices is 31.
- The second path contains the node [2] with the price [7].
The difference between the maximum and minimum price sum is 24. It can be proved that 24 is the maximum cost.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/11/24/p1_example2.png"" style=""width: 352px; height: 184px;"" />
<pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[1,2]], price = [1,1,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The diagram above denotes the tree after rooting it at node 0. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.
- The first path contains nodes [0,1,2]: the prices are [1,1,1], and the sum of the prices is 3.
- The second path contains node [0] with a price [1].
The difference between the maximum and minimum price sum is 2. It can be proved that 2 is the maximum cost.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>edges</code> represents a valid tree.</li>
	<li><code>price.length == n</code></li>
	<li><code>1 &lt;= price[i] &lt;= 10<sup>5</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {
        
    }
};","class Solution {
    public long maxOutput(int n, int[][] edges, int[] price) {
        
    }
}","class Solution(object):
    def maxOutput(self, n, edges, price):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :type price: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:
        ","long long maxOutput(int n, int** edges, int edgesSize, int* edgesColSize, int* price, int priceSize){

}","public class Solution {
    public long MaxOutput(int n, int[][] edges, int[] price) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number[]} price
 * @return {number}
 */
var maxOutput = function(n, edges, price) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @param {Integer[]} price
# @return {Integer}
def max_output(n, edges, price)
    
end","class Solution {
    func maxOutput(_ n: Int, _ edges: [[Int]], _ price: [Int]) -> Int {
        
    }
}","func maxOutput(n int, edges [][]int, price []int) int64 {
    
}","object Solution {
    def maxOutput(n: Int, edges: Array[Array[Int]], price: Array[Int]): Long = {
        
    }
}","class Solution {
    fun maxOutput(n: Int, edges: Array<IntArray>, price: IntArray): Long {
        
    }
}","impl Solution {
    pub fn max_output(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @param Integer[] $price
     * @return Integer
     */
    function maxOutput($n, $edges, $price) {
        
    }
}","function maxOutput(n: number, edges: number[][], price: number[]): number {

};","(define/contract (max-output n edges price)
  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?) exact-integer?)

  )","-spec max_output(N :: integer(), Edges :: [[integer()]], Price :: [integer()]) -> integer().
max_output(N, Edges, Price) ->
  .","defmodule Solution do
  @spec max_output(n :: integer, edges :: [[integer]], price :: [integer]) :: integer
  def max_output(n, edges, price) do

  end
end","class Solution {
  int maxOutput(int n, List<List<int>> edges, List<int> price) {

  }
}",
count-the-number-of-good-subarrays,Count the Number of Good Subarrays,2537.0,2626.0,"<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the number of <strong>good</strong> subarrays of</em> <code>nums</code>.</p>

<p>A subarray <code>arr</code> is <strong>good</strong> if it there are <strong>at least </strong><code>k</code> pairs of indices <code>(i, j)</code> such that <code>i &lt; j</code> and <code>arr[i] == arr[j]</code>.</p>

<p>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,1,1], k = 10
<strong>Output:</strong> 1
<strong>Explanation:</strong> The only good subarray is the array nums itself.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,4,3,2,2,4], k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 4 different good subarrays:
- [3,1,4,3,2,2] that has 2 pairs.
- [3,1,4,3,2,2,4] that has 3 pairs.
- [1,4,3,2,2,4] that has 2 pairs.
- [4,3,2,2,4] that has 2 pairs.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long countGood(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public long countGood(int[] nums, int k) {
        
    }
}","class Solution(object):
    def countGood(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def countGood(self, nums: List[int], k: int) -> int:
        ","long long countGood(int* nums, int numsSize, int k){

}","public class Solution {
    public long CountGood(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var countGood = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def count_good(nums, k)
    
end","class Solution {
    func countGood(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func countGood(nums []int, k int) int64 {
    
}","object Solution {
    def countGood(nums: Array[Int], k: Int): Long = {
        
    }
}","class Solution {
    fun countGood(nums: IntArray, k: Int): Long {
        
    }
}","impl Solution {
    pub fn count_good(nums: Vec<i32>, k: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function countGood($nums, $k) {
        
    }
}","function countGood(nums: number[], k: number): number {

};","(define/contract (count-good nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec count_good(Nums :: [integer()], K :: integer()) -> integer().
count_good(Nums, K) ->
  .","defmodule Solution do
  @spec count_good(nums :: [integer], k :: integer) :: integer
  def count_good(nums, k) do

  end
end","class Solution {
  int countGood(List<int> nums, int k) {

  }
}",
increment-submatrices-by-one,Increment Submatrices by One,2536.0,2625.0,"<p>You are given a positive integer <code>n</code>, indicating that we initially have an <code>n x n</code>&nbsp;<strong>0-indexed</strong> integer matrix <code>mat</code> filled with zeroes.</p>

<p>You are also given a 2D integer array <code>query</code>. For each <code>query[i] = [row1<sub>i</sub>, col1<sub>i</sub>, row2<sub>i</sub>, col2<sub>i</sub>]</code>, you should do the following operation:</p>

<ul>
	<li>Add <code>1</code> to <strong>every element</strong> in the submatrix with the <strong>top left</strong> corner <code>(row1<sub>i</sub>, col1<sub>i</sub>)</code> and the <strong>bottom right</strong> corner <code>(row2<sub>i</sub>, col2<sub>i</sub>)</code>. That is, add <code>1</code> to <code>mat[x][y]</code> for all <code>row1<sub>i</sub> &lt;= x &lt;= row2<sub>i</sub></code> and <code>col1<sub>i</sub> &lt;= y &lt;= col2<sub>i</sub></code>.</li>
</ul>

<p>Return<em> the matrix</em> <code>mat</code><em> after performing every query.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/11/24/p2example11.png"" style=""width: 531px; height: 121px;"" />
<pre>
<strong>Input:</strong> n = 3, queries = [[1,1,2,2],[0,0,1,1]]
<strong>Output:</strong> [[1,1,0],[1,2,1],[0,1,1]]
<strong>Explanation:</strong> The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query.
- In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2).
- In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1).
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/11/24/p2example22.png"" style=""width: 261px; height: 82px;"" />
<pre>
<strong>Input:</strong> n = 2, queries = [[0,0,1,1]]
<strong>Output:</strong> [[1,1],[1,1]]
<strong>Explanation:</strong> The diagram above shows the initial matrix and the matrix after the first query.
- In the first query we add 1 to every element in the matrix.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= row1<sub>i</sub> &lt;= row2<sub>i</sub> &lt; n</code></li>
	<li><code>0 &lt;= col1<sub>i</sub> &lt;= col2<sub>i</sub> &lt; n</code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {
        
    }
};","class Solution {
    public int[][] rangeAddQueries(int n, int[][] queries) {
        
    }
}","class Solution(object):
    def rangeAddQueries(self, n, queries):
        """"""
        :type n: int
        :type queries: List[List[int]]
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** rangeAddQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public int[][] RangeAddQueries(int n, int[][] queries) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} queries
 * @return {number[][]}
 */
var rangeAddQueries = function(n, queries) {
    
};","# @param {Integer} n
# @param {Integer[][]} queries
# @return {Integer[][]}
def range_add_queries(n, queries)
    
end","class Solution {
    func rangeAddQueries(_ n: Int, _ queries: [[Int]]) -> [[Int]] {
        
    }
}","func rangeAddQueries(n int, queries [][]int) [][]int {
    
}","object Solution {
    def rangeAddQueries(n: Int, queries: Array[Array[Int]]): Array[Array[Int]] = {
        
    }
}","class Solution {
    fun rangeAddQueries(n: Int, queries: Array<IntArray>): Array<IntArray> {
        
    }
}","impl Solution {
    pub fn range_add_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $queries
     * @return Integer[][]
     */
    function rangeAddQueries($n, $queries) {
        
    }
}","function rangeAddQueries(n: number, queries: number[][]): number[][] {

};","(define/contract (range-add-queries n queries)
  (-> exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)))

  )","-spec range_add_queries(N :: integer(), Queries :: [[integer()]]) -> [[integer()]].
range_add_queries(N, Queries) ->
  .","defmodule Solution do
  @spec range_add_queries(n :: integer, queries :: [[integer]]) :: [[integer]]
  def range_add_queries(n, queries) do

  end
end","class Solution {
  List<List<int>> rangeAddQueries(int n, List<List<int>> queries) {

  }
}",
difference-between-element-sum-and-digit-sum-of-an-array,Difference Between Element Sum and Digit Sum of an Array,2535.0,2624.0,"<p>You are given a positive integer array <code>nums</code>.</p>

<ul>
	<li>The <strong>element sum</strong> is the sum of all the elements in <code>nums</code>.</li>
	<li>The <strong>digit sum</strong> is the sum of all the digits (not necessarily distinct) that appear in <code>nums</code>.</li>
</ul>

<p>Return <em>the <strong>absolute</strong> difference between the <strong>element sum</strong> and <strong>digit sum</strong> of </em><code>nums</code>.</p>

<p><strong>Note</strong> that the absolute difference between two integers <code>x</code> and <code>y</code> is defined as <code>|x - y|</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,15,6,3]
<strong>Output:</strong> 9
<strong>Explanation:</strong> 
The element sum of nums is 1 + 15 + 6 + 3 = 25.
The digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16.
The absolute difference between the element sum and digit sum is |25 - 16| = 9.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 0
<strong>Explanation:</strong>
The element sum of nums is 1 + 2 + 3 + 4 = 10.
The digit sum of nums is 1 + 2 + 3 + 4 = 10.
The absolute difference between the element sum and digit sum is |10 - 10| = 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 2000</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int differenceOfSum(vector<int>& nums) {
        
    }
};","class Solution {
    public int differenceOfSum(int[] nums) {
        
    }
}","class Solution(object):
    def differenceOfSum(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def differenceOfSum(self, nums: List[int]) -> int:
        ","int differenceOfSum(int* nums, int numsSize){

}","public class Solution {
    public int DifferenceOfSum(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var differenceOfSum = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def difference_of_sum(nums)
    
end","class Solution {
    func differenceOfSum(_ nums: [Int]) -> Int {
        
    }
}","func differenceOfSum(nums []int) int {
    
}","object Solution {
    def differenceOfSum(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun differenceOfSum(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn difference_of_sum(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function differenceOfSum($nums) {
        
    }
}","function differenceOfSum(nums: number[]): number {

};","(define/contract (difference-of-sum nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec difference_of_sum(Nums :: [integer()]) -> integer().
difference_of_sum(Nums) ->
  .","defmodule Solution do
  @spec difference_of_sum(nums :: [integer]) :: integer
  def difference_of_sum(nums) do

  end
end","class Solution {
  int differenceOfSum(List<int> nums) {

  }
}",
find-xor-beauty-of-array,Find Xor-Beauty of Array,2527.0,2621.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>

<p>The <strong>effective value</strong> of three indices <code>i</code>, <code>j</code>, and <code>k</code> is defined as <code>((nums[i] | nums[j]) &amp; nums[k])</code>.</p>

<p>The <strong>xor-beauty</strong> of the array is the XORing of <strong>the effective values of all the possible triplets</strong> of indices <code>(i, j, k)</code> where <code>0 &lt;= i, j, k &lt; n</code>.</p>

<p>Return <em>the xor-beauty of</em> <code>nums</code>.</p>

<p><strong>Note</strong> that:</p>

<ul>
	<li><code>val1 | val2</code> is bitwise OR of <code>val1</code> and <code>val2</code>.</li>
	<li><code>val1 &amp; val2</code> is bitwise AND of <code>val1</code> and <code>val2</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4]
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
The triplets and their corresponding effective values are listed below:
- (0,0,0) with effective value ((1 | 1) &amp; 1) = 1
- (0,0,1) with effective value ((1 | 1) &amp; 4) = 0
- (0,1,0) with effective value ((1 | 4) &amp; 1) = 1
- (0,1,1) with effective value ((1 | 4) &amp; 4) = 4
- (1,0,0) with effective value ((4 | 1) &amp; 1) = 1
- (1,0,1) with effective value ((4 | 1) &amp; 4) = 4
- (1,1,0) with effective value ((4 | 4) &amp; 1) = 0
- (1,1,1) with effective value ((4 | 4) &amp; 4) = 4 
Xor-beauty of array will be bitwise XOR of all beauties = 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [15,45,20,2,34,35,5,44,32,30]
<strong>Output:</strong> 34
<strong>Explanation:</strong> <code>The xor-beauty of the given array is 34.</code>
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length&nbsp;&lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int xorBeauty(vector<int>& nums) {
        
    }
};","class Solution {
    public int xorBeauty(int[] nums) {
        
    }
}","class Solution(object):
    def xorBeauty(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def xorBeauty(self, nums: List[int]) -> int:
        ","int xorBeauty(int* nums, int numsSize){

}","public class Solution {
    public int XorBeauty(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var xorBeauty = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def xor_beauty(nums)
    
end","class Solution {
    func xorBeauty(_ nums: [Int]) -> Int {
        
    }
}","func xorBeauty(nums []int) int {
    
}","object Solution {
    def xorBeauty(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun xorBeauty(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn xor_beauty(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function xorBeauty($nums) {
        
    }
}","function xorBeauty(nums: number[]): number {

};","(define/contract (xor-beauty nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec xor_beauty(Nums :: [integer()]) -> integer().
xor_beauty(Nums) ->
  .","defmodule Solution do
  @spec xor_beauty(nums :: [integer]) :: integer
  def xor_beauty(nums) do

  end
end","class Solution {
  int xorBeauty(List<int> nums) {

  }
}",
find-consecutive-integers-from-a-data-stream,Find Consecutive Integers from a Data Stream,2526.0,2620.0,"<p>For a stream of integers, implement a data structure that checks if the last <code>k</code> integers parsed in the stream are <strong>equal</strong> to <code>value</code>.</p>

<p>Implement the <strong>DataStream</strong> class:</p>

<ul>
	<li><code>DataStream(int value, int k)</code> Initializes the object with an empty integer stream and the two integers <code>value</code> and <code>k</code>.</li>
	<li><code>boolean consec(int num)</code> Adds <code>num</code> to the stream of integers. Returns <code>true</code> if the last <code>k</code> integers are equal to <code>value</code>, and <code>false</code> otherwise. If there are less than <code>k</code> integers, the condition does not hold true, so returns <code>false</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;DataStream&quot;, &quot;consec&quot;, &quot;consec&quot;, &quot;consec&quot;, &quot;consec&quot;]
[[4, 3], [4], [4], [4], [3]]
<strong>Output</strong>
[null, false, false, true, false]

<strong>Explanation</strong>
DataStream dataStream = new DataStream(4, 3); //value = 4, k = 3 
dataStream.consec(4); // Only 1 integer is parsed, so returns False. 
dataStream.consec(4); // Only 2 integers are parsed.
                      // Since 2 is less than k, returns False. 
dataStream.consec(4); // The 3 integers parsed are all equal to value, so returns True. 
dataStream.consec(3); // The last k integers parsed in the stream are [4,4,3].
                      // Since 3 is not equal to value, it returns False.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= value, num &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
	<li>At most <code>10<sup>5</sup></code> calls will be made to <code>consec</code>.</li>
</ul>
",2.0,False,"class DataStream {
public:
    DataStream(int value, int k) {
        
    }
    
    bool consec(int num) {
        
    }
};

/**
 * Your DataStream object will be instantiated and called as such:
 * DataStream* obj = new DataStream(value, k);
 * bool param_1 = obj->consec(num);
 */","class DataStream {

    public DataStream(int value, int k) {
        
    }
    
    public boolean consec(int num) {
        
    }
}

/**
 * Your DataStream object will be instantiated and called as such:
 * DataStream obj = new DataStream(value, k);
 * boolean param_1 = obj.consec(num);
 */","class DataStream(object):

    def __init__(self, value, k):
        """"""
        :type value: int
        :type k: int
        """"""
        

    def consec(self, num):
        """"""
        :type num: int
        :rtype: bool
        """"""
        


# Your DataStream object will be instantiated and called as such:
# obj = DataStream(value, k)
# param_1 = obj.consec(num)","class DataStream:

    def __init__(self, value: int, k: int):
        

    def consec(self, num: int) -> bool:
        


# Your DataStream object will be instantiated and called as such:
# obj = DataStream(value, k)
# param_1 = obj.consec(num)","


typedef struct {
    
} DataStream;


DataStream* dataStreamCreate(int value, int k) {
    
}

bool dataStreamConsec(DataStream* obj, int num) {
  
}

void dataStreamFree(DataStream* obj) {
    
}

/**
 * Your DataStream struct will be instantiated and called as such:
 * DataStream* obj = dataStreamCreate(value, k);
 * bool param_1 = dataStreamConsec(obj, num);
 
 * dataStreamFree(obj);
*/","public class DataStream {

    public DataStream(int value, int k) {
        
    }
    
    public bool Consec(int num) {
        
    }
}

/**
 * Your DataStream object will be instantiated and called as such:
 * DataStream obj = new DataStream(value, k);
 * bool param_1 = obj.Consec(num);
 */","/**
 * @param {number} value
 * @param {number} k
 */
var DataStream = function(value, k) {
    
};

/** 
 * @param {number} num
 * @return {boolean}
 */
DataStream.prototype.consec = function(num) {
    
};

/** 
 * Your DataStream object will be instantiated and called as such:
 * var obj = new DataStream(value, k)
 * var param_1 = obj.consec(num)
 */","class DataStream

=begin
    :type value: Integer
    :type k: Integer
=end
    def initialize(value, k)
        
    end


=begin
    :type num: Integer
    :rtype: Boolean
=end
    def consec(num)
        
    end


end

# Your DataStream object will be instantiated and called as such:
# obj = DataStream.new(value, k)
# param_1 = obj.consec(num)","
class DataStream {

    init(_ value: Int, _ k: Int) {
        
    }
    
    func consec(_ num: Int) -> Bool {
        
    }
}

/**
 * Your DataStream object will be instantiated and called as such:
 * let obj = DataStream(value, k)
 * let ret_1: Bool = obj.consec(num)
 */","type DataStream struct {
    
}


func Constructor(value int, k int) DataStream {
    
}


func (this *DataStream) Consec(num int) bool {
    
}


/**
 * Your DataStream object will be instantiated and called as such:
 * obj := Constructor(value, k);
 * param_1 := obj.Consec(num);
 */","class DataStream(_value: Int, _k: Int) {

    def consec(num: Int): Boolean = {
        
    }

}

/**
 * Your DataStream object will be instantiated and called as such:
 * var obj = new DataStream(value, k)
 * var param_1 = obj.consec(num)
 */","class DataStream(value: Int, k: Int) {

    fun consec(num: Int): Boolean {
        
    }

}

/**
 * Your DataStream object will be instantiated and called as such:
 * var obj = DataStream(value, k)
 * var param_1 = obj.consec(num)
 */","struct DataStream {

}


/** 
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl DataStream {

    fn new(value: i32, k: i32) -> Self {
        
    }
    
    fn consec(&self, num: i32) -> bool {
        
    }
}

/**
 * Your DataStream object will be instantiated and called as such:
 * let obj = DataStream::new(value, k);
 * let ret_1: bool = obj.consec(num);
 */","class DataStream {
    /**
     * @param Integer $value
     * @param Integer $k
     */
    function __construct($value, $k) {
        
    }
  
    /**
     * @param Integer $num
     * @return Boolean
     */
    function consec($num) {
        
    }
}

/**
 * Your DataStream object will be instantiated and called as such:
 * $obj = DataStream($value, $k);
 * $ret_1 = $obj->consec($num);
 */","class DataStream {
    constructor(value: number, k: number) {

    }

    consec(num: number): boolean {

    }
}

/**
 * Your DataStream object will be instantiated and called as such:
 * var obj = new DataStream(value, k)
 * var param_1 = obj.consec(num)
 */","(define data-stream%
  (class object%
    (super-new)
    
    ; value : exact-integer?
    ; k : exact-integer?
    (init-field
      value
      k)
    
    ; consec : exact-integer? -> boolean?
    (define/public (consec num)

      )))

;; Your data-stream% object will be instantiated and called as such:
;; (define obj (new data-stream% [value value] [k k]))
;; (define param_1 (send obj consec num))","-spec data_stream_init_(Value :: integer(), K :: integer()) -> any().
data_stream_init_(Value, K) ->
  .

-spec data_stream_consec(Num :: integer()) -> boolean().
data_stream_consec(Num) ->
  .


%% Your functions will be called as such:
%% data_stream_init_(Value, K),
%% Param_1 = data_stream_consec(Num),

%% data_stream_init_ will be called before every test case, in which you can do some necessary initializations.","defmodule DataStream do
  @spec init_(value :: integer, k :: integer) :: any
  def init_(value, k) do

  end

  @spec consec(num :: integer) :: boolean
  def consec(num) do

  end
end

# Your functions will be called as such:
# DataStream.init_(value, k)
# param_1 = DataStream.consec(num)

# DataStream.init_ will be called before every test case, in which you can do some necessary initializations.","class DataStream {

  DataStream(int value, int k) {

  }
  
  bool consec(int num) {

  }
}

/**
 * Your DataStream object will be instantiated and called as such:
 * DataStream obj = DataStream(value, k);
 * bool param1 = obj.consec(num);
 */",
categorize-box-according-to-criteria,Categorize Box According to Criteria,2525.0,2619.0,"<p>Given four integers <code>length</code>, <code>width</code>, <code>height</code>, and <code>mass</code>, representing the dimensions and mass of a box, respectively, return <em>a string representing the <strong>category</strong> of the box</em>.</p>

<ul>
	<li>The box is <code>&quot;Bulky&quot;</code> if:

	<ul>
		<li><strong>Any</strong> of the dimensions of the box is greater or equal to <code>10<sup>4</sup></code>.</li>
		<li>Or, the <strong>volume</strong> of the box is greater or equal to <code>10<sup>9</sup></code>.</li>
	</ul>
	</li>
	<li>If the mass of the box is greater or equal to <code>100</code>, it is <code>&quot;Heavy&quot;.</code></li>
	<li>If the box is both <code>&quot;Bulky&quot;</code> and <code>&quot;Heavy&quot;</code>, then its category is <code>&quot;Both&quot;</code>.</li>
	<li>If the box is neither <code>&quot;Bulky&quot;</code> nor <code>&quot;Heavy&quot;</code>, then its category is <code>&quot;Neither&quot;</code>.</li>
	<li>If the box is <code>&quot;Bulky&quot;</code> but not <code>&quot;Heavy&quot;</code>, then its category is <code>&quot;Bulky&quot;</code>.</li>
	<li>If the box is <code>&quot;Heavy&quot;</code> but not <code>&quot;Bulky&quot;</code>, then its category is <code>&quot;Heavy&quot;</code>.</li>
</ul>

<p><strong>Note</strong> that the volume of the box is the product of its length, width and height.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> length = 1000, width = 35, height = 700, mass = 300
<strong>Output:</strong> &quot;Heavy&quot;
<strong>Explanation:</strong> 
None of the dimensions of the box is greater or equal to 10<sup>4</sup>. 
Its volume = 24500000 &lt;= 10<sup>9</sup>. So it cannot be categorized as &quot;Bulky&quot;.
However mass &gt;= 100, so the box is &quot;Heavy&quot;.
Since the box is not &quot;Bulky&quot; but &quot;Heavy&quot;, we return &quot;Heavy&quot;.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> length = 200, width = 50, height = 800, mass = 50
<strong>Output:</strong> &quot;Neither&quot;
<strong>Explanation:</strong> 
None of the dimensions of the box is greater or equal to 10<sup>4</sup>.
Its volume = 8 * 10<sup>6</sup> &lt;= 10<sup>9</sup>. So it cannot be categorized as &quot;Bulky&quot;.
Its mass is also less than 100, so it cannot be categorized as &quot;Heavy&quot; either. 
Since its neither of the two above categories, we return &quot;Neither&quot;.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= length, width, height &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= mass &lt;= 10<sup>3</sup></code></li>
</ul>
",1.0,False,"class Solution {
public:
    string categorizeBox(int length, int width, int height, int mass) {
        
    }
};","class Solution {
    public String categorizeBox(int length, int width, int height, int mass) {
        
    }
}","class Solution(object):
    def categorizeBox(self, length, width, height, mass):
        """"""
        :type length: int
        :type width: int
        :type height: int
        :type mass: int
        :rtype: str
        """"""
        ","class Solution:
    def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:
        ","char * categorizeBox(int length, int width, int height, int mass){

}","public class Solution {
    public string CategorizeBox(int length, int width, int height, int mass) {
        
    }
}","/**
 * @param {number} length
 * @param {number} width
 * @param {number} height
 * @param {number} mass
 * @return {string}
 */
var categorizeBox = function(length, width, height, mass) {
    
};","# @param {Integer} length
# @param {Integer} width
# @param {Integer} height
# @param {Integer} mass
# @return {String}
def categorize_box(length, width, height, mass)
    
end","class Solution {
    func categorizeBox(_ length: Int, _ width: Int, _ height: Int, _ mass: Int) -> String {
        
    }
}","func categorizeBox(length int, width int, height int, mass int) string {
    
}","object Solution {
    def categorizeBox(length: Int, width: Int, height: Int, mass: Int): String = {
        
    }
}","class Solution {
    fun categorizeBox(length: Int, width: Int, height: Int, mass: Int): String {
        
    }
}","impl Solution {
    pub fn categorize_box(length: i32, width: i32, height: i32, mass: i32) -> String {
        
    }
}","class Solution {

    /**
     * @param Integer $length
     * @param Integer $width
     * @param Integer $height
     * @param Integer $mass
     * @return String
     */
    function categorizeBox($length, $width, $height, $mass) {
        
    }
}","function categorizeBox(length: number, width: number, height: number, mass: number): string {

};","(define/contract (categorize-box length width height mass)
  (-> exact-integer? exact-integer? exact-integer? exact-integer? string?)

  )","-spec categorize_box(Length :: integer(), Width :: integer(), Height :: integer(), Mass :: integer()) -> unicode:unicode_binary().
categorize_box(Length, Width, Height, Mass) ->
  .","defmodule Solution do
  @spec categorize_box(length :: integer, width :: integer, height :: integer, mass :: integer) :: String.t
  def categorize_box(length, width, height, mass) do

  end
end","class Solution {
  String categorizeBox(int length, int width, int height, int mass) {

  }
}",
maximize-the-minimum-powered-city,Maximize the Minimum Powered City,2528.0,2618.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>stations</code> of length <code>n</code>, where <code>stations[i]</code> represents the number of power stations in the <code>i<sup>th</sup></code> city.</p>

<p>Each power station can provide power to every city in a fixed <strong>range</strong>. In other words, if the range is denoted by <code>r</code>, then a power station at city <code>i</code> can provide power to all cities <code>j</code> such that <code>|i - j| &lt;= r</code> and <code>0 &lt;= i, j &lt;= n - 1</code>.</p>

<ul>
	<li>Note that <code>|x|</code> denotes <strong>absolute</strong> value. For example, <code>|7 - 5| = 2</code> and <code>|3 - 10| = 7</code>.</li>
</ul>

<p>The <strong>power</strong> of a city is the total number of power stations it is being provided power from.</p>

<p>The government has sanctioned building <code>k</code> more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.</p>

<p>Given the two integers <code>r</code> and <code>k</code>, return <em>the <strong>maximum possible minimum power</strong> of a city, if the additional power stations are built optimally.</em></p>

<p><strong>Note</strong> that you can build the <code>k</code> power stations in multiple cities.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> stations = [1,2,4,5,0], r = 1, k = 2
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
One of the optimal ways is to install both the power stations at city 1. 
So stations will become [1,4,4,5,0].
- City 0 is provided by 1 + 4 = 5 power stations.
- City 1 is provided by 1 + 4 + 4 = 9 power stations.
- City 2 is provided by 4 + 4 + 5 = 13 power stations.
- City 3 is provided by 5 + 4 = 9 power stations.
- City 4 is provided by 5 + 0 = 5 power stations.
So the minimum power of a city is 5.
Since it is not possible to obtain a larger power, we return 5.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> stations = [4,4,4,4], r = 0, k = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
It can be proved that we cannot make the minimum power of a city greater than 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == stations.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= stations[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= r&nbsp;&lt;= n - 1</code></li>
	<li><code>0 &lt;= k&nbsp;&lt;= 10<sup>9</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    long long maxPower(vector<int>& stations, int r, int k) {
        
    }
};","class Solution {
    public long maxPower(int[] stations, int r, int k) {
        
    }
}","class Solution(object):
    def maxPower(self, stations, r, k):
        """"""
        :type stations: List[int]
        :type r: int
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        ","long long maxPower(int* stations, int stationsSize, int r, int k){

}","public class Solution {
    public long MaxPower(int[] stations, int r, int k) {
        
    }
}","/**
 * @param {number[]} stations
 * @param {number} r
 * @param {number} k
 * @return {number}
 */
var maxPower = function(stations, r, k) {
    
};","# @param {Integer[]} stations
# @param {Integer} r
# @param {Integer} k
# @return {Integer}
def max_power(stations, r, k)
    
end","class Solution {
    func maxPower(_ stations: [Int], _ r: Int, _ k: Int) -> Int {
        
    }
}","func maxPower(stations []int, r int, k int) int64 {
    
}","object Solution {
    def maxPower(stations: Array[Int], r: Int, k: Int): Long = {
        
    }
}","class Solution {
    fun maxPower(stations: IntArray, r: Int, k: Int): Long {
        
    }
}","impl Solution {
    pub fn max_power(stations: Vec<i32>, r: i32, k: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $stations
     * @param Integer $r
     * @param Integer $k
     * @return Integer
     */
    function maxPower($stations, $r, $k) {
        
    }
}","function maxPower(stations: number[], r: number, k: number): number {

};","(define/contract (max-power stations r k)
  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)

  )","-spec max_power(Stations :: [integer()], R :: integer(), K :: integer()) -> integer().
max_power(Stations, R, K) ->
  .","defmodule Solution do
  @spec max_power(stations :: [integer], r :: integer, k :: integer) :: integer
  def max_power(stations, r, k) do

  end
end","class Solution {
  int maxPower(List<int> stations, int r, int k) {

  }
}",
maximal-score-after-applying-k-operations,Maximal Score After Applying K Operations,2530.0,2616.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>k</code>. You have a <strong>starting score</strong> of <code>0</code>.</p>

<p>In one <strong>operation</strong>:</p>

<ol>
	<li>choose an index <code>i</code> such that <code>0 &lt;= i &lt; nums.length</code>,</li>
	<li>increase your <strong>score</strong> by <code>nums[i]</code>, and</li>
	<li>replace <code>nums[i]</code> with <code>ceil(nums[i] / 3)</code>.</li>
</ol>

<p>Return <em>the maximum possible <strong>score</strong> you can attain after applying <strong>exactly</strong></em> <code>k</code> <em>operations</em>.</p>

<p>The ceiling function <code>ceil(val)</code> is the least integer greater than or equal to <code>val</code>.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,10,10,10,10], k = 5
<strong>Output:</strong> 50
<strong>Explanation:</strong> Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50.
</pre>

<p><strong>Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,10,3,3,3], k = 3
<strong>Output:</strong> 17
<strong>Explanation: </strong>You can do the following operations:
Operation 1: Select i = 1, so nums becomes [1,<strong><u>4</u></strong>,3,3,3]. Your score increases by 10.
Operation 2: Select i = 1, so nums becomes [1,<strong><u>2</u></strong>,3,3,3]. Your score increases by 4.
Operation 3: Select i = 2, so nums becomes [1,1,<u><strong>1</strong></u>,3,3]. Your score increases by 3.
The final score is 10 + 4 + 3 = 17.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length, k &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long maxKelements(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public long maxKelements(int[] nums, int k) {
        
    }
}","class Solution(object):
    def maxKelements(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maxKelements(self, nums: List[int], k: int) -> int:
        ","long long maxKelements(int* nums, int numsSize, int k){

}","public class Solution {
    public long MaxKelements(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maxKelements = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def max_kelements(nums, k)
    
end","class Solution {
    func maxKelements(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func maxKelements(nums []int, k int) int64 {
    
}","object Solution {
    def maxKelements(nums: Array[Int], k: Int): Long = {
        
    }
}","class Solution {
    fun maxKelements(nums: IntArray, k: Int): Long {
        
    }
}","impl Solution {
    pub fn max_kelements(nums: Vec<i32>, k: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function maxKelements($nums, $k) {
        
    }
}","function maxKelements(nums: number[], k: number): number {

};","(define/contract (max-kelements nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec max_kelements(Nums :: [integer()], K :: integer()) -> integer().
max_kelements(Nums, K) ->
  .","defmodule Solution do
  @spec max_kelements(nums :: [integer], k :: integer) :: integer
  def max_kelements(nums, k) do

  end
end","class Solution {
  int maxKelements(List<int> nums, int k) {

  }
}",
make-number-of-distinct-characters-equal,Make Number of Distinct Characters Equal,2531.0,2615.0,"<p>You are given two <strong>0-indexed</strong> strings <code>word1</code> and <code>word2</code>.</p>

<p>A <strong>move</strong> consists of choosing two indices <code>i</code> and <code>j</code> such that <code>0 &lt;= i &lt; word1.length</code> and <code>0 &lt;= j &lt; word2.length</code> and swapping <code>word1[i]</code> with <code>word2[j]</code>.</p>

<p>Return <code>true</code> <em>if it is possible to get the number of distinct characters in</em> <code>word1</code> <em>and</em> <code>word2</code> <em>to be equal with <strong>exactly one</strong> move. </em>Return <code>false</code> <em>otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;ac&quot;, word2 = &quot;b&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> Any pair of swaps would yield two distinct characters in the first string, and one in the second string.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;abcc&quot;, word2 = &quot;aab&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = &quot;abac&quot; and word2 = &quot;cab&quot;, which both have 3 distinct characters.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;abcde&quot;, word2 = &quot;fghij&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> Both resulting strings will have 5 distinct characters, regardless of which indices we swap.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word1.length, word2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>word1</code> and <code>word2</code> consist of only lowercase English letters.</li>
</ul>
",2.0,False,"class Solution {
public:
    bool isItPossible(string word1, string word2) {
        
    }
};","class Solution {
    public boolean isItPossible(String word1, String word2) {
        
    }
}","class Solution(object):
    def isItPossible(self, word1, word2):
        """"""
        :type word1: str
        :type word2: str
        :rtype: bool
        """"""
        ","class Solution:
    def isItPossible(self, word1: str, word2: str) -> bool:
        ","bool isItPossible(char * word1, char * word2){

}","public class Solution {
    public bool IsItPossible(string word1, string word2) {
        
    }
}","/**
 * @param {string} word1
 * @param {string} word2
 * @return {boolean}
 */
var isItPossible = function(word1, word2) {
    
};","# @param {String} word1
# @param {String} word2
# @return {Boolean}
def is_it_possible(word1, word2)
    
end","class Solution {
    func isItPossible(_ word1: String, _ word2: String) -> Bool {
        
    }
}","func isItPossible(word1 string, word2 string) bool {
    
}","object Solution {
    def isItPossible(word1: String, word2: String): Boolean = {
        
    }
}","class Solution {
    fun isItPossible(word1: String, word2: String): Boolean {
        
    }
}","impl Solution {
    pub fn is_it_possible(word1: String, word2: String) -> bool {
        
    }
}","class Solution {

    /**
     * @param String $word1
     * @param String $word2
     * @return Boolean
     */
    function isItPossible($word1, $word2) {
        
    }
}","function isItPossible(word1: string, word2: string): boolean {

};","(define/contract (is-it-possible word1 word2)
  (-> string? string? boolean?)

  )","-spec is_it_possible(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> boolean().
is_it_possible(Word1, Word2) ->
  .","defmodule Solution do
  @spec is_it_possible(word1 :: String.t, word2 :: String.t) :: boolean
  def is_it_possible(word1, word2) do

  end
end","class Solution {
  bool isItPossible(String word1, String word2) {

  }
}",
maximum-count-of-positive-integer-and-negative-integer,Maximum Count of Positive Integer and Negative Integer,2529.0,2614.0,"<p>Given an array <code>nums</code> sorted in <strong>non-decreasing</strong> order, return <em>the maximum between the number of positive integers and the number of negative integers.</em></p>

<ul>
	<li>In other words, if the number of positive integers in <code>nums</code> is <code>pos</code> and the number of negative integers is <code>neg</code>, then return the maximum of <code>pos</code> and <code>neg</code>.</li>
</ul>

<p><strong>Note</strong> that <code>0</code> is neither positive nor negative.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-2,-1,-1,1,2,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 positive integers and 3 negative integers. The maximum count among them is 3.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-3,-2,-1,0,0,1,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 2 positive integers and 3 negative integers. The maximum count among them is 3.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,20,66,1314]
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 4 positive integers and 0 negative integers. The maximum count among them is 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2000</code></li>
	<li><code>-2000 &lt;= nums[i] &lt;= 2000</code></li>
	<li><code>nums</code> is sorted in a <strong>non-decreasing order</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Can you solve the problem in <code>O(log(n))</code> time complexity?</p>
",1.0,False,"class Solution {
public:
    int maximumCount(vector<int>& nums) {
        
    }
};","class Solution {
    public int maximumCount(int[] nums) {
        
    }
}","class Solution(object):
    def maximumCount(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maximumCount(self, nums: List[int]) -> int:
        ","int maximumCount(int* nums, int numsSize){

}","public class Solution {
    public int MaximumCount(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumCount = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def maximum_count(nums)
    
end","class Solution {
    func maximumCount(_ nums: [Int]) -> Int {
        
    }
}","func maximumCount(nums []int) int {
    
}","object Solution {
    def maximumCount(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maximumCount(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn maximum_count(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maximumCount($nums) {
        
    }
}","function maximumCount(nums: number[]): number {

};","(define/contract (maximum-count nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec maximum_count(Nums :: [integer()]) -> integer().
maximum_count(Nums) ->
  .","defmodule Solution do
  @spec maximum_count(nums :: [integer]) :: integer
  def maximum_count(nums) do

  end
end","class Solution {
  int maximumCount(List<int> nums) {

  }
}",
closest-prime-numbers-in-range,Closest Prime Numbers in Range,2523.0,2610.0,"<p>Given two positive integers <code>left</code> and <code>right</code>, find the two integers <code>num1</code> and <code>num2</code> such that:</p>

<ul>
	<li><code>left &lt;= nums1 &lt; nums2 &lt;= right </code>.</li>
	<li><code>nums1</code> and <code>nums2</code> are both <strong>prime</strong> numbers.</li>
	<li><code>nums2 - nums1</code> is the <strong>minimum</strong> amongst all other pairs satisfying the above conditions.</li>
</ul>

<p>Return <em>the positive integer array</em> <code>ans = [nums1, nums2]</code>. <em>If there are multiple pairs satisfying these conditions, return the one with the minimum</em> <code>nums1</code> <em>value or</em> <code>[-1, -1]</code> <em>if such numbers do not exist.</em></p>

<p>A number greater than <code>1</code> is called <b>prime</b> if it is only divisible by <code>1</code> and itself.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> left = 10, right = 19
<strong>Output:</strong> [11,13]
<strong>Explanation:</strong> The prime numbers between 10 and 19 are 11, 13, 17, and 19.
The closest gap between any pair is 2, which can be achieved by [11,13] or [17,19].
Since 11 is smaller than 17, we return the first pair.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> left = 4, right = 6
<strong>Output:</strong> [-1,-1]
<strong>Explanation:</strong> There exists only one prime number in the given range, so the conditions cannot be satisfied.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>6</sup></code></li>
</ul>

<p>&nbsp;</p>
<style type=""text/css"">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value=""Show Message""] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value=""Hide Message""] + .spoiler {padding:5px;}
</style>
",2.0,False,"class Solution {
public:
    vector<int> closestPrimes(int left, int right) {
        
    }
};","class Solution {
    public int[] closestPrimes(int left, int right) {
        
    }
}","class Solution(object):
    def closestPrimes(self, left, right):
        """"""
        :type left: int
        :type right: int
        :rtype: List[int]
        """"""
        ","class Solution:
    def closestPrimes(self, left: int, right: int) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* closestPrimes(int left, int right, int* returnSize){

}","public class Solution {
    public int[] ClosestPrimes(int left, int right) {
        
    }
}","/**
 * @param {number} left
 * @param {number} right
 * @return {number[]}
 */
var closestPrimes = function(left, right) {
    
};","# @param {Integer} left
# @param {Integer} right
# @return {Integer[]}
def closest_primes(left, right)
    
end","class Solution {
    func closestPrimes(_ left: Int, _ right: Int) -> [Int] {
        
    }
}","func closestPrimes(left int, right int) []int {
    
}","object Solution {
    def closestPrimes(left: Int, right: Int): Array[Int] = {
        
    }
}","class Solution {
    fun closestPrimes(left: Int, right: Int): IntArray {
        
    }
}","impl Solution {
    pub fn closest_primes(left: i32, right: i32) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer $left
     * @param Integer $right
     * @return Integer[]
     */
    function closestPrimes($left, $right) {
        
    }
}","function closestPrimes(left: number, right: number): number[] {

};","(define/contract (closest-primes left right)
  (-> exact-integer? exact-integer? (listof exact-integer?))

  )","-spec closest_primes(Left :: integer(), Right :: integer()) -> [integer()].
closest_primes(Left, Right) ->
  .","defmodule Solution do
  @spec closest_primes(left :: integer, right :: integer) :: [integer]
  def closest_primes(left, right) do

  end
end","class Solution {
  List<int> closestPrimes(int left, int right) {

  }
}",
distinct-prime-factors-of-product-of-array,Distinct Prime Factors of Product of Array,2521.0,2609.0,"<p>Given an array of positive integers <code>nums</code>, return <em>the number of <strong>distinct prime factors</strong> in the product of the elements of</em> <code>nums</code>.</p>

<p><strong>Note</strong> that:</p>

<ul>
	<li>A number greater than <code>1</code> is called <strong>prime</strong> if it is divisible by only <code>1</code> and itself.</li>
	<li>An integer <code>val1</code> is a factor of another integer <code>val2</code> if <code>val2 / val1</code> is an integer.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,3,7,10,6]
<strong>Output:</strong> 4
<strong>Explanation:</strong>
The product of all the elements in nums is: 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 2<sup>5</sup> * 3<sup>2</sup> * 5 * 7.
There are 4 distinct prime factors so we return 4.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,8,16]
<strong>Output:</strong> 1
<strong>Explanation:</strong>
The product of all the elements in nums is: 2 * 4 * 8 * 16 = 1024 = 2<sup>10</sup>.
There is 1 distinct prime factor so we return 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>2 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int distinctPrimeFactors(vector<int>& nums) {
        
    }
};","class Solution {
    public int distinctPrimeFactors(int[] nums) {
        
    }
}","class Solution(object):
    def distinctPrimeFactors(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def distinctPrimeFactors(self, nums: List[int]) -> int:
        ","int distinctPrimeFactors(int* nums, int numsSize){

}","public class Solution {
    public int DistinctPrimeFactors(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var distinctPrimeFactors = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def distinct_prime_factors(nums)
    
end","class Solution {
    func distinctPrimeFactors(_ nums: [Int]) -> Int {
        
    }
}","func distinctPrimeFactors(nums []int) int {
    
}","object Solution {
    def distinctPrimeFactors(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun distinctPrimeFactors(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn distinct_prime_factors(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function distinctPrimeFactors($nums) {
        
    }
}","function distinctPrimeFactors(nums: number[]): number {

};","(define/contract (distinct-prime-factors nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec distinct_prime_factors(Nums :: [integer()]) -> integer().
distinct_prime_factors(Nums) ->
  .","defmodule Solution do
  @spec distinct_prime_factors(nums :: [integer]) :: integer
  def distinct_prime_factors(nums) do

  end
end","class Solution {
  int distinctPrimeFactors(List<int> nums) {

  }
}",
count-the-digits-that-divide-a-number,Count the Digits That Divide a Number,2520.0,2608.0,"<p>Given an integer <code>num</code>, return <em>the number of digits in <code>num</code> that divide </em><code>num</code>.</p>

<p>An integer <code>val</code> divides <code>nums</code> if <code>nums % val == 0</code>.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre>
<strong>Input:</strong> num = 7
<strong>Output:</strong> 1
<strong>Explanation:</strong> 7 divides itself, hence the answer is 1.
</pre>

<p><strong>Example 2:</strong></p>

<pre>
<strong>Input:</strong> num = 121
<strong>Output:</strong> 2
<strong>Explanation:</strong> 121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2.
</pre>

<p><strong>Example 3:</strong></p>

<pre>
<strong>Input:</strong> num = 1248
<strong>Output:</strong> 4
<strong>Explanation:</strong> 1248 is divisible by all of its digits, hence the answer is 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= num &lt;= 10<sup>9</sup></code></li>
	<li><code>num</code> does not contain <code>0</code> as one of its digits.</li>
</ul>
",1.0,False,"class Solution {
public:
    int countDigits(int num) {
        
    }
};","class Solution {
    public int countDigits(int num) {
        
    }
}","class Solution(object):
    def countDigits(self, num):
        """"""
        :type num: int
        :rtype: int
        """"""
        ","class Solution:
    def countDigits(self, num: int) -> int:
        ","int countDigits(int num){

}","public class Solution {
    public int CountDigits(int num) {
        
    }
}","/**
 * @param {number} num
 * @return {number}
 */
var countDigits = function(num) {
    
};","# @param {Integer} num
# @return {Integer}
def count_digits(num)
    
end","class Solution {
    func countDigits(_ num: Int) -> Int {
        
    }
}","func countDigits(num int) int {
    
}","object Solution {
    def countDigits(num: Int): Int = {
        
    }
}","class Solution {
    fun countDigits(num: Int): Int {
        
    }
}","impl Solution {
    pub fn count_digits(num: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $num
     * @return Integer
     */
    function countDigits($num) {
        
    }
}","function countDigits(num: number): number {

};","(define/contract (count-digits num)
  (-> exact-integer? exact-integer?)

  )","-spec count_digits(Num :: integer()) -> integer().
count_digits(Num) ->
  .","defmodule Solution do
  @spec count_digits(num :: integer) :: integer
  def count_digits(num) do

  end
end","class Solution {
  int countDigits(int num) {

  }
}",
difference-between-ones-and-zeros-in-row-and-column,Difference Between Ones and Zeros in Row and Column,2482.0,2606.0,"<p>You are given a <strong>0-indexed</strong> <code>m x n</code> binary matrix <code>grid</code>.</p>

<p>A <strong>0-indexed</strong> <code>m x n</code> difference matrix <code>diff</code> is created with the following procedure:</p>

<ul>
	<li>Let the number of ones in the <code>i<sup>th</sup></code> row be <code>onesRow<sub>i</sub></code>.</li>
	<li>Let the number of ones in the <code>j<sup>th</sup></code> column be <code>onesCol<sub>j</sub></code>.</li>
	<li>Let the number of zeros in the <code>i<sup>th</sup></code> row be <code>zerosRow<sub>i</sub></code>.</li>
	<li>Let the number of zeros in the <code>j<sup>th</sup></code> column be <code>zerosCol<sub>j</sub></code>.</li>
	<li><code>diff[i][j] = onesRow<sub>i</sub> + onesCol<sub>j</sub> - zerosRow<sub>i</sub> - zerosCol<sub>j</sub></code></li>
</ul>

<p>Return <em>the difference matrix </em><code>diff</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img src=""https://assets.leetcode.com/uploads/2022/11/06/image-20221106171729-5.png"" style=""width: 400px; height: 208px;"" />
<pre>
<strong>Input:</strong> grid = [[0,1,1],[1,0,1],[0,0,1]]
<strong>Output:</strong> [[0,0,4],[0,0,4],[-2,-2,2]]
<strong>Explanation:</strong>
- diff[0][0] = <code>onesRow<sub>0</sub> + onesCol<sub>0</sub> - zerosRow<sub>0</sub> - zerosCol<sub>0</sub></code> = 2 + 1 - 1 - 2 = 0 
- diff[0][1] = <code>onesRow<sub>0</sub> + onesCol<sub>1</sub> - zerosRow<sub>0</sub> - zerosCol<sub>1</sub></code> = 2 + 1 - 1 - 2 = 0 
- diff[0][2] = <code>onesRow<sub>0</sub> + onesCol<sub>2</sub> - zerosRow<sub>0</sub> - zerosCol<sub>2</sub></code> = 2 + 3 - 1 - 0 = 4 
- diff[1][0] = <code>onesRow<sub>1</sub> + onesCol<sub>0</sub> - zerosRow<sub>1</sub> - zerosCol<sub>0</sub></code> = 2 + 1 - 1 - 2 = 0 
- diff[1][1] = <code>onesRow<sub>1</sub> + onesCol<sub>1</sub> - zerosRow<sub>1</sub> - zerosCol<sub>1</sub></code> = 2 + 1 - 1 - 2 = 0 
- diff[1][2] = <code>onesRow<sub>1</sub> + onesCol<sub>2</sub> - zerosRow<sub>1</sub> - zerosCol<sub>2</sub></code> = 2 + 3 - 1 - 0 = 4 
- diff[2][0] = <code>onesRow<sub>2</sub> + onesCol<sub>0</sub> - zerosRow<sub>2</sub> - zerosCol<sub>0</sub></code> = 1 + 1 - 2 - 2 = -2
- diff[2][1] = <code>onesRow<sub>2</sub> + onesCol<sub>1</sub> - zerosRow<sub>2</sub> - zerosCol<sub>1</sub></code> = 1 + 1 - 2 - 2 = -2
- diff[2][2] = <code>onesRow<sub>2</sub> + onesCol<sub>2</sub> - zerosRow<sub>2</sub> - zerosCol<sub>2</sub></code> = 1 + 3 - 2 - 0 = 2
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img src=""https://assets.leetcode.com/uploads/2022/11/06/image-20221106171747-6.png"" style=""width: 358px; height: 150px;"" />
<pre>
<strong>Input:</strong> grid = [[1,1,1],[1,1,1]]
<strong>Output:</strong> [[5,5,5],[5,5,5]]
<strong>Explanation:</strong>
- diff[0][0] = onesRow<sub>0</sub> + onesCol<sub>0</sub> - zerosRow<sub>0</sub> - zerosCol<sub>0</sub> = 3 + 2 - 0 - 0 = 5
- diff[0][1] = onesRow<sub>0</sub> + onesCol<sub>1</sub> - zerosRow<sub>0</sub> - zerosCol<sub>1</sub> = 3 + 2 - 0 - 0 = 5
- diff[0][2] = onesRow<sub>0</sub> + onesCol<sub>2</sub> - zerosRow<sub>0</sub> - zerosCol<sub>2</sub> = 3 + 2 - 0 - 0 = 5
- diff[1][0] = onesRow<sub>1</sub> + onesCol<sub>0</sub> - zerosRow<sub>1</sub> - zerosCol<sub>0</sub> = 3 + 2 - 0 - 0 = 5
- diff[1][1] = onesRow<sub>1</sub> + onesCol<sub>1</sub> - zerosRow<sub>1</sub> - zerosCol<sub>1</sub> = 3 + 2 - 0 - 0 = 5
- diff[1][2] = onesRow<sub>1</sub> + onesCol<sub>2</sub> - zerosRow<sub>1</sub> - zerosCol<sub>2</sub> = 3 + 2 - 0 - 0 = 5
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
",2.0,False,"class Solution {
public:
    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int[][] onesMinusZeros(int[][] grid) {
        
    }
}","class Solution(object):
    def onesMinusZeros(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** onesMinusZeros(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public int[][] OnesMinusZeros(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number[][]}
 */
var onesMinusZeros = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer[][]}
def ones_minus_zeros(grid)
    
end","class Solution {
    func onesMinusZeros(_ grid: [[Int]]) -> [[Int]] {
        
    }
}","func onesMinusZeros(grid [][]int) [][]int {
    
}","object Solution {
    def onesMinusZeros(grid: Array[Array[Int]]): Array[Array[Int]] = {
        
    }
}","class Solution {
    fun onesMinusZeros(grid: Array<IntArray>): Array<IntArray> {
        
    }
}","impl Solution {
    pub fn ones_minus_zeros(grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer[][]
     */
    function onesMinusZeros($grid) {
        
    }
}","function onesMinusZeros(grid: number[][]): number[][] {

};","(define/contract (ones-minus-zeros grid)
  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)))

  )","-spec ones_minus_zeros(Grid :: [[integer()]]) -> [[integer()]].
ones_minus_zeros(Grid) ->
  .","defmodule Solution do
  @spec ones_minus_zeros(grid :: [[integer]]) :: [[integer]]
  def ones_minus_zeros(grid) do

  end
end","class Solution {
  List<List<int>> onesMinusZeros(List<List<int>> grid) {

  }
}",
count-anagrams,Count Anagrams,2514.0,2605.0,"<p>You are given a string <code>s</code> containing one or more words. Every consecutive pair of words is separated by a single space <code>&#39; &#39;</code>.</p>

<p>A string <code>t</code> is an <strong>anagram</strong> of string <code>s</code> if the <code>i<sup>th</sup></code> word of <code>t</code> is a <strong>permutation</strong> of the <code>i<sup>th</sup></code> word of <code>s</code>.</p>

<ul>
	<li>For example, <code>&quot;acb dfe&quot;</code> is an anagram of <code>&quot;abc def&quot;</code>, but <code>&quot;def cab&quot;</code>&nbsp;and <code>&quot;adc bef&quot;</code> are not.</li>
</ul>

<p>Return <em>the number of <strong>distinct anagrams</strong> of </em><code>s</code>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;too hot&quot;
<strong>Output:</strong> 18
<strong>Explanation:</strong> Some of the anagrams of the given string are &quot;too hot&quot;, &quot;oot hot&quot;, &quot;oto toh&quot;, &quot;too toh&quot;, and &quot;too oht&quot;.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aa&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is only one anagram possible for the given string.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters and spaces <code>&#39; &#39;</code>.</li>
	<li>There is single space between consecutive words.</li>
</ul>
",3.0,False,"class Solution {
public:
    int countAnagrams(string s) {
        
    }
};","class Solution {
    public int countAnagrams(String s) {
        
    }
}","class Solution(object):
    def countAnagrams(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def countAnagrams(self, s: str) -> int:
        ","int countAnagrams(char * s){

}","public class Solution {
    public int CountAnagrams(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var countAnagrams = function(s) {
    
};","# @param {String} s
# @return {Integer}
def count_anagrams(s)
    
end","class Solution {
    func countAnagrams(_ s: String) -> Int {
        
    }
}","func countAnagrams(s string) int {
    
}","object Solution {
    def countAnagrams(s: String): Int = {
        
    }
}","class Solution {
    fun countAnagrams(s: String): Int {
        
    }
}","impl Solution {
    pub fn count_anagrams(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function countAnagrams($s) {
        
    }
}","function countAnagrams(s: string): number {

};","(define/contract (count-anagrams s)
  (-> string? exact-integer?)

  )","-spec count_anagrams(S :: unicode:unicode_binary()) -> integer().
count_anagrams(S) ->
  .","defmodule Solution do
  @spec count_anagrams(s :: String.t) :: integer
  def count_anagrams(s) do

  end
end","class Solution {
  int countAnagrams(String s) {

  }
}",
minimum-operations-to-make-array-equal-ii,Minimum Operations to Make Array Equal II,2541.0,2604.0,"<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> of equal length <code>n</code> and an integer <code>k</code>. You can perform the following operation on <code>nums1</code>:</p>

<ul>
	<li>Choose two indexes <code>i</code> and <code>j</code> and increment <code>nums1[i]</code> by <code>k</code> and decrement <code>nums1[j]</code> by <code>k</code>. In other words, <code>nums1[i] = nums1[i] + k</code> and <code>nums1[j] = nums1[j] - k</code>.</li>
</ul>

<p><code>nums1</code> is said to be <strong>equal</strong> to <code>nums2</code> if for all indices <code>i</code> such that <code>0 &lt;= i &lt; n</code>, <code>nums1[i] == nums2[i]</code>.</p>

<p>Return <em>the <strong>minimum</strong> number of operations required to make </em><code>nums1</code><em> equal to </em><code>nums2</code>. If it is impossible to make them equal, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> In 2 operations, we can transform nums1 to nums2.
1<sup>st</sup> operation: i = 2, j = 0. After applying the operation, nums1 = [1,3,4,4].
2<sup>nd</sup> operation: i = 2, j = 3. After applying the operation, nums1 = [1,3,7,1].
One can prove that it is impossible to make arrays equal in fewer operations.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be proved that it is impossible to make the two arrays equal.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums1.length == nums2.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {
        
    }
};","class Solution {
    public long minOperations(int[] nums1, int[] nums2, int k) {
        
    }
}","class Solution(object):
    def minOperations(self, nums1, nums2, k):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
        ","long long minOperations(int* nums1, int nums1Size, int* nums2, int nums2Size, int k){

}","public class Solution {
    public long MinOperations(int[] nums1, int[] nums2, int k) {
        
    }
}","/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number}
 */
var minOperations = function(nums1, nums2, k) {
    
};","# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @param {Integer} k
# @return {Integer}
def min_operations(nums1, nums2, k)
    
end","class Solution {
    func minOperations(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> Int {
        
    }
}","func minOperations(nums1 []int, nums2 []int, k int) int64 {
    
}","object Solution {
    def minOperations(nums1: Array[Int], nums2: Array[Int], k: Int): Long = {
        
    }
}","class Solution {
    fun minOperations(nums1: IntArray, nums2: IntArray, k: Int): Long {
        
    }
}","impl Solution {
    pub fn min_operations(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @param Integer $k
     * @return Integer
     */
    function minOperations($nums1, $nums2, $k) {
        
    }
}","function minOperations(nums1: number[], nums2: number[], k: number): number {

};","(define/contract (min-operations nums1 nums2 k)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec min_operations(Nums1 :: [integer()], Nums2 :: [integer()], K :: integer()) -> integer().
min_operations(Nums1, Nums2, K) ->
  .","defmodule Solution do
  @spec min_operations(nums1 :: [integer], nums2 :: [integer], k :: integer) :: integer
  def min_operations(nums1, nums2, k) do

  end
end","class Solution {
  int minOperations(List<int> nums1, List<int> nums2, int k) {

  }
}",
reward-top-k-students,Reward Top K Students,2512.0,2603.0,"<p>You are given two string arrays <code>positive_feedback</code> and <code>negative_feedback</code>, containing the words denoting positive and negative feedback, respectively. Note that <strong>no</strong> word is both positive and negative.</p>

<p>Initially every student has <code>0</code> points. Each positive word in a feedback report <strong>increases</strong> the points of a student by <code>3</code>, whereas each negative word <strong>decreases</strong> the points by <code>1</code>.</p>

<p>You are given <code>n</code> feedback reports, represented by a <strong>0-indexed</strong> string array <code>report</code>&nbsp;and a <strong>0-indexed</strong> integer array <code>student_id</code>, where <code>student_id[i]</code> represents the ID of the student who has received the feedback report <code>report[i]</code>. The ID of each student is <strong>unique</strong>.</p>

<p>Given an integer <code>k</code>, return <em>the top </em><code>k</code><em> students after ranking them in <strong>non-increasing</strong> order by their points</em>. In case more than one student has the same points, the one with the lower ID ranks higher.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> positive_feedback = [&quot;smart&quot;,&quot;brilliant&quot;,&quot;studious&quot;], negative_feedback = [&quot;not&quot;], report = [&quot;this student is studious&quot;,&quot;the student is smart&quot;], student_id = [1,2], k = 2
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> 
Both the students have 1 positive feedback and 3 points but since student 1 has a lower ID he ranks higher.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> positive_feedback = [&quot;smart&quot;,&quot;brilliant&quot;,&quot;studious&quot;], negative_feedback = [&quot;not&quot;], report = [&quot;this student is not studious&quot;,&quot;the student is smart&quot;], student_id = [1,2], k = 2
<strong>Output:</strong> [2,1]
<strong>Explanation:</strong> 
- The student with ID 1 has 1 positive feedback and 1 negative feedback, so he has 3-1=2 points. 
- The student with ID 2 has 1 positive feedback, so he has 3 points. 
Since student 2 has more points, [2,1] is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= positive_feedback.length, negative_feedback.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= positive_feedback[i].length, negative_feedback[j].length &lt;= 100</code></li>
	<li>Both <code>positive_feedback[i]</code> and <code>negative_feedback[j]</code> consists of lowercase English letters.</li>
	<li>No word is present in both <code>positive_feedback</code> and <code>negative_feedback</code>.</li>
	<li><code>n == report.length == student_id.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>report[i]</code> consists of lowercase English letters and spaces <code>&#39; &#39;</code>.</li>
	<li>There is a single space between consecutive words of <code>report[i]</code>.</li>
	<li><code>1 &lt;= report[i].length &lt;= 100</code></li>
	<li><code>1 &lt;= student_id[i] &lt;= 10<sup>9</sup></code></li>
	<li>All the values of <code>student_id[i]</code> are <strong>unique</strong>.</li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
",2.0,False,"class Solution {
public:
    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {
        
    }
};","class Solution {
    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {
        
    }
}","class Solution(object):
    def topStudents(self, positive_feedback, negative_feedback, report, student_id, k):
        """"""
        :type positive_feedback: List[str]
        :type negative_feedback: List[str]
        :type report: List[str]
        :type student_id: List[int]
        :type k: int
        :rtype: List[int]
        """"""
        ","class Solution:
    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* topStudents(char ** positive_feedback, int positive_feedbackSize, char ** negative_feedback, int negative_feedbackSize, char ** report, int reportSize, int* student_id, int student_idSize, int k, int* returnSize){

}","public class Solution {
    public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k) {
        
    }
}","/**
 * @param {string[]} positive_feedback
 * @param {string[]} negative_feedback
 * @param {string[]} report
 * @param {number[]} student_id
 * @param {number} k
 * @return {number[]}
 */
var topStudents = function(positive_feedback, negative_feedback, report, student_id, k) {
    
};","# @param {String[]} positive_feedback
# @param {String[]} negative_feedback
# @param {String[]} report
# @param {Integer[]} student_id
# @param {Integer} k
# @return {Integer[]}
def top_students(positive_feedback, negative_feedback, report, student_id, k)
    
end","class Solution {
    func topStudents(_ positive_feedback: [String], _ negative_feedback: [String], _ report: [String], _ student_id: [Int], _ k: Int) -> [Int] {
        
    }
}","func topStudents(positive_feedback []string, negative_feedback []string, report []string, student_id []int, k int) []int {
    
}","object Solution {
    def topStudents(positive_feedback: Array[String], negative_feedback: Array[String], report: Array[String], student_id: Array[Int], k: Int): List[Int] = {
        
    }
}","class Solution {
    fun topStudents(positive_feedback: Array<String>, negative_feedback: Array<String>, report: Array<String>, student_id: IntArray, k: Int): List<Int> {
        
    }
}","impl Solution {
    pub fn top_students(positive_feedback: Vec<String>, negative_feedback: Vec<String>, report: Vec<String>, student_id: Vec<i32>, k: i32) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param String[] $positive_feedback
     * @param String[] $negative_feedback
     * @param String[] $report
     * @param Integer[] $student_id
     * @param Integer $k
     * @return Integer[]
     */
    function topStudents($positive_feedback, $negative_feedback, $report, $student_id, $k) {
        
    }
}","function topStudents(positive_feedback: string[], negative_feedback: string[], report: string[], student_id: number[], k: number): number[] {

};","(define/contract (top-students positive_feedback negative_feedback report student_id k)
  (-> (listof string?) (listof string?) (listof string?) (listof exact-integer?) exact-integer? (listof exact-integer?))

  )","-spec top_students(Positive_feedback :: [unicode:unicode_binary()], Negative_feedback :: [unicode:unicode_binary()], Report :: [unicode:unicode_binary()], Student_id :: [integer()], K :: integer()) -> [integer()].
top_students(Positive_feedback, Negative_feedback, Report, Student_id, K) ->
  .","defmodule Solution do
  @spec top_students(positive_feedback :: [String.t], negative_feedback :: [String.t], report :: [String.t], student_id :: [integer], k :: integer) :: [integer]
  def top_students(positive_feedback, negative_feedback, report, student_id, k) do

  end
end","class Solution {
  List<int> topStudents(List<String> positive_feedback, List<String> negative_feedback, List<String> report, List<int> student_id, int k) {

  }
}",
maximum-enemy-forts-that-can-be-captured,Maximum Enemy Forts That Can Be Captured,2511.0,2602.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>forts</code> of length <code>n</code> representing the positions of several forts. <code>forts[i]</code> can be <code>-1</code>, <code>0</code>, or <code>1</code> where:</p>

<ul>
	<li><code>-1</code> represents there is <strong>no fort</strong> at the <code>i<sup>th</sup></code> position.</li>
	<li><code>0</code> indicates there is an <strong>enemy</strong> fort at the <code>i<sup>th</sup></code> position.</li>
	<li><code>1</code> indicates the fort at the <code>i<sup>th</sup></code> the position is under your command.</li>
</ul>

<p>Now you have decided to move your army from one of your forts at position <code>i</code> to an empty position <code>j</code> such that:</p>

<ul>
	<li><code>0 &lt;= i, j &lt;= n - 1</code></li>
	<li>The army travels over enemy forts <strong>only</strong>. Formally, for all <code>k</code> where <code>min(i,j) &lt; k &lt; max(i,j)</code>, <code>forts[k] == 0.</code></li>
</ul>

<p>While moving the army, all the enemy forts that come in the way are <strong>captured</strong>.</p>

<p>Return<em> the <strong>maximum</strong> number of enemy forts that can be captured</em>. In case it is <strong>impossible</strong> to move your army, or you do not have any fort under your command, return <code>0</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> forts = [1,0,0,-1,0,0,0,0,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong>
- Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.
- Moving the army from position 8 to position 3 captures 4 enemy forts.
Since 4 is the maximum number of enemy forts that can be captured, we return 4.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> forts = [0,0,1,-1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Since no enemy fort can be captured, 0 is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= forts.length &lt;= 1000</code></li>
	<li><code>-1 &lt;= forts[i] &lt;= 1</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int captureForts(vector<int>& forts) {
        
    }
};","class Solution {
    public int captureForts(int[] forts) {
        
    }
}","class Solution(object):
    def captureForts(self, forts):
        """"""
        :type forts: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def captureForts(self, forts: List[int]) -> int:
        ","int captureForts(int* forts, int fortsSize){

}","public class Solution {
    public int CaptureForts(int[] forts) {
        
    }
}","/**
 * @param {number[]} forts
 * @return {number}
 */
var captureForts = function(forts) {
    
};","# @param {Integer[]} forts
# @return {Integer}
def capture_forts(forts)
    
end","class Solution {
    func captureForts(_ forts: [Int]) -> Int {
        
    }
}","func captureForts(forts []int) int {
    
}","object Solution {
    def captureForts(forts: Array[Int]): Int = {
        
    }
}","class Solution {
    fun captureForts(forts: IntArray): Int {
        
    }
}","impl Solution {
    pub fn capture_forts(forts: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $forts
     * @return Integer
     */
    function captureForts($forts) {
        
    }
}","function captureForts(forts: number[]): number {

};","(define/contract (capture-forts forts)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec capture_forts(Forts :: [integer()]) -> integer().
capture_forts(Forts) ->
  .","defmodule Solution do
  @spec capture_forts(forts :: [integer]) :: integer
  def capture_forts(forts) do

  end
end","class Solution {
  int captureForts(List<int> forts) {

  }
}",
number-of-great-partitions,Number of Great Partitions,2518.0,2601.0,"<p>You are given an array <code>nums</code> consisting of <strong>positive</strong> integers and an integer <code>k</code>.</p>

<p><strong>Partition</strong> the array into two ordered <strong>groups</strong> such that each element is in exactly <strong>one</strong> group. A partition is called great if the <strong>sum</strong> of elements of each group is greater than or equal to <code>k</code>.</p>

<p>Return <em>the number of <strong>distinct</strong> great partitions</em>. Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>Two partitions are considered distinct if some element <code>nums[i]</code> is in different groups in the two partitions.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], k = 4
<strong>Output:</strong> 6
<strong>Explanation:</strong> The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and ([4], [1,2,3]).
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,3,3], k = 4
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no great partitions for this array.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,6], k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can either put nums[0] in the first partition or in the second partition.
The great partitions will be ([6], [6]) and ([6], [6]).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length, k &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    int countPartitions(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int countPartitions(int[] nums, int k) {
        
    }
}","class Solution(object):
    def countPartitions(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def countPartitions(self, nums: List[int], k: int) -> int:
        ","int countPartitions(int* nums, int numsSize, int k){

}","public class Solution {
    public int CountPartitions(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var countPartitions = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def count_partitions(nums, k)
    
end","class Solution {
    func countPartitions(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func countPartitions(nums []int, k int) int {
    
}","object Solution {
    def countPartitions(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun countPartitions(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn count_partitions(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function countPartitions($nums, $k) {
        
    }
}","function countPartitions(nums: number[], k: number): number {

};","(define/contract (count-partitions nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec count_partitions(Nums :: [integer()], K :: integer()) -> integer().
count_partitions(Nums, K) ->
  .","defmodule Solution do
  @spec count_partitions(nums :: [integer], k :: integer) :: integer
  def count_partitions(nums, k) do

  end
end","class Solution {
  int countPartitions(List<int> nums, int k) {

  }
}",
maximum-tastiness-of-candy-basket,Maximum Tastiness of Candy Basket,2517.0,2600.0,"<p>You are given an array of positive integers <code>price</code> where <code>price[i]</code> denotes the price of the <code>i<sup>th</sup></code> candy and a positive integer <code>k</code>.</p>

<p>The store sells baskets of <code>k</code> <strong>distinct</strong> candies. The <strong>tastiness</strong> of a candy basket is the smallest absolute difference of the <strong>prices</strong> of any two candies in the basket.</p>

<p>Return <em>the <strong>maximum</strong> tastiness of a candy basket.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> price = [13,5,1,8,21,2], k = 3
<strong>Output:</strong> 8
<strong>Explanation:</strong> Choose the candies with the prices [13,5,21].
The tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.
It can be proven that 8 is the maximum tastiness that can be achieved.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> price = [1,3,1], k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> Choose the candies with the prices [1,3].
The tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.
It can be proven that 2 is the maximum tastiness that can be achieved.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> price = [7,7,7,7], k = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong> Choosing any two distinct candies from the candies we have will result in a tastiness of 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= k &lt;= price.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= price[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int maximumTastiness(vector<int>& price, int k) {
        
    }
};","class Solution {
    public int maximumTastiness(int[] price, int k) {
        
    }
}","class Solution(object):
    def maximumTastiness(self, price, k):
        """"""
        :type price: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maximumTastiness(self, price: List[int], k: int) -> int:
        ","int maximumTastiness(int* price, int priceSize, int k){

}","public class Solution {
    public int MaximumTastiness(int[] price, int k) {
        
    }
}","/**
 * @param {number[]} price
 * @param {number} k
 * @return {number}
 */
var maximumTastiness = function(price, k) {
    
};","# @param {Integer[]} price
# @param {Integer} k
# @return {Integer}
def maximum_tastiness(price, k)
    
end","class Solution {
    func maximumTastiness(_ price: [Int], _ k: Int) -> Int {
        
    }
}","func maximumTastiness(price []int, k int) int {
    
}","object Solution {
    def maximumTastiness(price: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun maximumTastiness(price: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn maximum_tastiness(price: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $price
     * @param Integer $k
     * @return Integer
     */
    function maximumTastiness($price, $k) {
        
    }
}","function maximumTastiness(price: number[], k: number): number {

};","(define/contract (maximum-tastiness price k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec maximum_tastiness(Price :: [integer()], K :: integer()) -> integer().
maximum_tastiness(Price, K) ->
  .","defmodule Solution do
  @spec maximum_tastiness(price :: [integer], k :: integer) :: integer
  def maximum_tastiness(price, k) do

  end
end","class Solution {
  int maximumTastiness(List<int> price, int k) {

  }
}",
take-k-of-each-character-from-left-and-right,Take K of Each Character From Left and Right,2516.0,2599.0,"<p>You are given a string <code>s</code> consisting of the characters <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, and <code>&#39;c&#39;</code> and a non-negative integer <code>k</code>. Each minute, you may take either the <strong>leftmost</strong> character of <code>s</code>, or the <strong>rightmost</strong> character of <code>s</code>.</p>

<p>Return<em> the <strong>minimum</strong> number of minutes needed for you to take <strong>at least</strong> </em><code>k</code><em> of each character, or return </em><code>-1</code><em> if it is not possible to take </em><code>k</code><em> of each character.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aabaaaacaabc&quot;, k = 2
<strong>Output:</strong> 8
<strong>Explanation:</strong> 
Take three characters from the left of s. You now have two &#39;a&#39; characters, and one &#39;b&#39; character.
Take five characters from the right of s. You now have four &#39;a&#39; characters, two &#39;b&#39; characters, and two &#39;c&#39; characters.
A total of 3 + 5 = 8 minutes is needed.
It can be proven that 8 is the minimum number of minutes needed.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;a&quot;, k = 1
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is not possible to take one &#39;b&#39; or &#39;c&#39; so return -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of only the letters <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, and <code>&#39;c&#39;</code>.</li>
	<li><code>0 &lt;= k &lt;= s.length</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int takeCharacters(string s, int k) {
        
    }
};","class Solution {
    public int takeCharacters(String s, int k) {
        
    }
}","class Solution(object):
    def takeCharacters(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def takeCharacters(self, s: str, k: int) -> int:
        ","int takeCharacters(char * s, int k){

}","public class Solution {
    public int TakeCharacters(string s, int k) {
        
    }
}","/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var takeCharacters = function(s, k) {
    
};","# @param {String} s
# @param {Integer} k
# @return {Integer}
def take_characters(s, k)
    
end","class Solution {
    func takeCharacters(_ s: String, _ k: Int) -> Int {
        
    }
}","func takeCharacters(s string, k int) int {
    
}","object Solution {
    def takeCharacters(s: String, k: Int): Int = {
        
    }
}","class Solution {
    fun takeCharacters(s: String, k: Int): Int {
        
    }
}","impl Solution {
    pub fn take_characters(s: String, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param Integer $k
     * @return Integer
     */
    function takeCharacters($s, $k) {
        
    }
}","function takeCharacters(s: string, k: number): number {

};","(define/contract (take-characters s k)
  (-> string? exact-integer? exact-integer?)

  )","-spec take_characters(S :: unicode:unicode_binary(), K :: integer()) -> integer().
take_characters(S, K) ->
  .","defmodule Solution do
  @spec take_characters(s :: String.t, k :: integer) :: integer
  def take_characters(s, k) do

  end
end","class Solution {
  int takeCharacters(String s, int k) {

  }
}",
shortest-distance-to-target-string-in-a-circular-array,Shortest Distance to Target String in a Circular Array,2515.0,2598.0,"<p>You are given a <strong>0-indexed</strong> <strong>circular</strong> string array <code>words</code> and a string <code>target</code>. A <strong>circular array</strong> means that the array&#39;s end connects to the array&#39;s beginning.</p>

<ul>
	<li>Formally, the next element of <code>words[i]</code> is <code>words[(i + 1) % n]</code> and the previous element of <code>words[i]</code> is <code>words[(i - 1 + n) % n]</code>, where <code>n</code> is the length of <code>words</code>.</li>
</ul>

<p>Starting from <code>startIndex</code>, you can move to either the next word or the previous word with <code>1</code> step at a time.</p>

<p>Return <em>the <strong>shortest</strong> distance needed to reach the string</em> <code>target</code>. If the string <code>target</code> does not exist in <code>words</code>, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;hello&quot;,&quot;i&quot;,&quot;am&quot;,&quot;leetcode&quot;,&quot;hello&quot;], target = &quot;hello&quot;, startIndex = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> We start from index 1 and can reach &quot;hello&quot; by
- moving 3 units to the right to reach index 4.
- moving 2 units to the left to reach index 4.
- moving 4 units to the right to reach index 0.
- moving 1 unit to the left to reach index 0.
The shortest distance to reach &quot;hello&quot; is 1.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;b&quot;,&quot;leetcode&quot;], target = &quot;leetcode&quot;, startIndex = 0
<strong>Output:</strong> 1
<strong>Explanation:</strong> We start from index 0 and can reach &quot;leetcode&quot; by
- moving 2 units to the right to reach index 3.
- moving 1 unit to the left to reach index 3.
The shortest distance to reach &quot;leetcode&quot; is 1.</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;i&quot;,&quot;eat&quot;,&quot;leetcode&quot;], target = &quot;ate&quot;, startIndex = 0
<strong>Output:</strong> -1
<strong>Explanation:</strong> Since &quot;ate&quot; does not exist in <code>words</code>, we return -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 100</code></li>
	<li><code>words[i]</code> and <code>target</code> consist of only lowercase English letters.</li>
	<li><code>0 &lt;= startIndex &lt; words.length</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int closetTarget(vector<string>& words, string target, int startIndex) {
        
    }
};","class Solution {
    public int closetTarget(String[] words, String target, int startIndex) {
        
    }
}","class Solution(object):
    def closetTarget(self, words, target, startIndex):
        """"""
        :type words: List[str]
        :type target: str
        :type startIndex: int
        :rtype: int
        """"""
        ","class Solution:
    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:
        ","int closetTarget(char ** words, int wordsSize, char * target, int startIndex){

}","public class Solution {
    public int ClosetTarget(string[] words, string target, int startIndex) {
        
    }
}","/**
 * @param {string[]} words
 * @param {string} target
 * @param {number} startIndex
 * @return {number}
 */
var closetTarget = function(words, target, startIndex) {
    
};","# @param {String[]} words
# @param {String} target
# @param {Integer} start_index
# @return {Integer}
def closet_target(words, target, start_index)
    
end","class Solution {
    func closetTarget(_ words: [String], _ target: String, _ startIndex: Int) -> Int {
        
    }
}","func closetTarget(words []string, target string, startIndex int) int {
    
}","object Solution {
    def closetTarget(words: Array[String], target: String, startIndex: Int): Int = {
        
    }
}","class Solution {
    fun closetTarget(words: Array<String>, target: String, startIndex: Int): Int {
        
    }
}","impl Solution {
    pub fn closet_target(words: Vec<String>, target: String, start_index: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @param String $target
     * @param Integer $startIndex
     * @return Integer
     */
    function closetTarget($words, $target, $startIndex) {
        
    }
}","function closetTarget(words: string[], target: string, startIndex: number): number {

};","(define/contract (closet-target words target startIndex)
  (-> (listof string?) string? exact-integer? exact-integer?)

  )","-spec closet_target(Words :: [unicode:unicode_binary()], Target :: unicode:unicode_binary(), StartIndex :: integer()) -> integer().
closet_target(Words, Target, StartIndex) ->
  .","defmodule Solution do
  @spec closet_target(words :: [String.t], target :: String.t, start_index :: integer) :: integer
  def closet_target(words, target, start_index) do

  end
end","class Solution {
  int closetTarget(List<String> words, String target, int startIndex) {

  }
}",
cycle-length-queries-in-a-tree,Cycle Length Queries in a Tree,2509.0,2597.0,"<p>You are given an integer <code>n</code>. There is a <strong>complete binary tree</strong> with <code>2<sup>n</sup> - 1</code> nodes. The root of that tree is the node with the value <code>1</code>, and every node with a value <code>val</code> in the range <code>[1, 2<sup>n - 1</sup> - 1]</code> has two children where:</p>

<ul>
	<li>The left node has the value <code>2 * val</code>, and</li>
	<li>The right node has the value <code>2 * val + 1</code>.</li>
</ul>

<p>You are also given a 2D integer array <code>queries</code> of length <code>m</code>, where <code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>. For each query, solve the following problem:</p>

<ol>
	<li>Add an edge between the nodes with values <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</li>
	<li>Find the length of the cycle in the graph.</li>
	<li>Remove the added edge between nodes with values <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</li>
</ol>

<p><strong>Note</strong> that:</p>

<ul>
	<li>A <strong>cycle</strong> is a path that starts and ends at the same node, and each edge in the path is visited only once.</li>
	<li>The length of a cycle is the number of edges visited in the cycle.</li>
	<li>There could be multiple edges between two nodes in the tree after adding the edge of the query.</li>
</ul>

<p>Return <em>an array </em><code>answer</code><em> of length </em><code>m</code><em> where</em> <code>answer[i]</code> <em>is the answer to the</em> <code>i<sup>th</sup></code> <em>query.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/25/bexample1.png"" style=""width: 647px; height: 128px;"" />
<pre>
<strong>Input:</strong> n = 3, queries = [[5,3],[4,7],[2,3]]
<strong>Output:</strong> [4,5,3]
<strong>Explanation:</strong> The diagrams above show the tree of 2<sup>3</sup> - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.
- After adding the edge between nodes 3 and 5, the graph contains a cycle of nodes [5,2,1,3]. Thus answer to the first query is 4. We delete the added edge and process the next query.
- After adding the edge between nodes 4 and 7, the graph contains a cycle of nodes [4,2,1,3,7]. Thus answer to the second query is 5. We delete the added edge and process the next query.
- After adding the edge between nodes 2 and 3, the graph contains a cycle of nodes [2,1,3]. Thus answer to the third query is 3. We delete the added edge.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/25/aexample2.png"" style=""width: 146px; height: 71px;"" />
<pre>
<strong>Input:</strong> n = 2, queries = [[1,2]]
<strong>Output:</strong> [2]
<strong>Explanation:</strong> The diagram above shows the tree of 2<sup>2</sup> - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.
- After adding the edge between nodes 1 and 2, the graph contains a cycle of nodes [2,1]. Thus answer for the first query is 2. We delete the added edge.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 30</code></li>
	<li><code>m == queries.length</code></li>
	<li><code>1 &lt;= m &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= 2<sup>n</sup> - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
</ul>
",3.0,False,"class Solution {
public:
    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {
        
    }
};","class Solution {
    public int[] cycleLengthQueries(int n, int[][] queries) {
        
    }
}","class Solution(object):
    def cycleLengthQueries(self, n, queries):
        """"""
        :type n: int
        :type queries: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* cycleLengthQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize){

}","public class Solution {
    public int[] CycleLengthQueries(int n, int[][] queries) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} queries
 * @return {number[]}
 */
var cycleLengthQueries = function(n, queries) {
    
};","# @param {Integer} n
# @param {Integer[][]} queries
# @return {Integer[]}
def cycle_length_queries(n, queries)
    
end","class Solution {
    func cycleLengthQueries(_ n: Int, _ queries: [[Int]]) -> [Int] {
        
    }
}","func cycleLengthQueries(n int, queries [][]int) []int {
    
}","object Solution {
    def cycleLengthQueries(n: Int, queries: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun cycleLengthQueries(n: Int, queries: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn cycle_length_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $queries
     * @return Integer[]
     */
    function cycleLengthQueries($n, $queries) {
        
    }
}","function cycleLengthQueries(n: number, queries: number[][]): number[] {

};","(define/contract (cycle-length-queries n queries)
  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec cycle_length_queries(N :: integer(), Queries :: [[integer()]]) -> [integer()].
cycle_length_queries(N, Queries) ->
  .","defmodule Solution do
  @spec cycle_length_queries(n :: integer, queries :: [[integer]]) :: [integer]
  def cycle_length_queries(n, queries) do

  end
end","class Solution {
  List<int> cycleLengthQueries(int n, List<List<int>> queries) {

  }
}",
add-edges-to-make-degrees-of-all-nodes-even,Add Edges to Make Degrees of All Nodes Even,2508.0,2596.0,"<p>There is an <strong>undirected</strong> graph consisting of <code>n</code> nodes numbered from <code>1</code> to <code>n</code>. You are given the integer <code>n</code> and a <strong>2D</strong> array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. The graph can be disconnected.</p>

<p>You can add <strong>at most</strong> two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.</p>

<p>Return <code>true</code><em> if it is possible to make the degree of each node in the graph even, otherwise return </em><code>false</code><em>.</em></p>

<p>The degree of a node is the number of edges connected to it.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/26/agraphdrawio.png"" style=""width: 500px; height: 190px;"" />
<pre>
<strong>Input:</strong> n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]
<strong>Output:</strong> true
<strong>Explanation:</strong> The above diagram shows a valid way of adding an edge.
Every node in the resulting graph is connected to an even number of edges.
</pre>

<p><strong>Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/26/aagraphdrawio.png"" style=""width: 400px; height: 120px;"" />
<pre>
<strong>Input:</strong> n = 4, edges = [[1,2],[3,4]]
<strong>Output:</strong> true
<strong>Explanation:</strong> The above diagram shows a valid way of adding two edges.</pre>

<p><strong>Example 3:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/26/aaagraphdrawio.png"" style=""width: 150px; height: 158px;"" />
<pre>
<strong>Input:</strong> n = 4, edges = [[1,2],[1,3],[1,4]]
<strong>Output:</strong> false
<strong>Explanation:</strong> It is not possible to obtain a valid graph with adding at most 2 edges.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
</ul>
",3.0,False,"class Solution {
public:
    bool isPossible(int n, vector<vector<int>>& edges) {
        
    }
};","class Solution {
    public boolean isPossible(int n, List<List<Integer>> edges) {
        
    }
}","class Solution(object):
    def isPossible(self, n, edges):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :rtype: bool
        """"""
        ","class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        ","bool isPossible(int n, int** edges, int edgesSize, int* edgesColSize){

}","public class Solution {
    public bool IsPossible(int n, IList<IList<int>> edges) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {boolean}
 */
var isPossible = function(n, edges) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @return {Boolean}
def is_possible(n, edges)
    
end","class Solution {
    func isPossible(_ n: Int, _ edges: [[Int]]) -> Bool {
        
    }
}","func isPossible(n int, edges [][]int) bool {
    
}","object Solution {
    def isPossible(n: Int, edges: List[List[Int]]): Boolean = {
        
    }
}","class Solution {
    fun isPossible(n: Int, edges: List<List<Int>>): Boolean {
        
    }
}","impl Solution {
    pub fn is_possible(n: i32, edges: Vec<Vec<i32>>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @return Boolean
     */
    function isPossible($n, $edges) {
        
    }
}","function isPossible(n: number, edges: number[][]): boolean {

};","(define/contract (is-possible n edges)
  (-> exact-integer? (listof (listof exact-integer?)) boolean?)

  )","-spec is_possible(N :: integer(), Edges :: [[integer()]]) -> boolean().
is_possible(N, Edges) ->
  .","defmodule Solution do
  @spec is_possible(n :: integer, edges :: [[integer]]) :: boolean
  def is_possible(n, edges) do

  end
end","class Solution {
  bool isPossible(int n, List<List<int>> edges) {

  }
}",
smallest-value-after-replacing-with-sum-of-prime-factors,Smallest Value After Replacing With Sum of Prime Factors,2507.0,2595.0,"<p>You are given a positive integer <code>n</code>.</p>

<p>Continuously replace <code>n</code> with the sum of its <strong>prime factors</strong>.</p>

<ul>
	<li>Note that if a prime factor divides <code>n</code> multiple times, it should be included in the sum as many times as it divides <code>n</code>.</li>
</ul>

<p>Return <em>the smallest value </em><code>n</code><em> will take on.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 15
<strong>Output:</strong> 5
<strong>Explanation:</strong> Initially, n = 15.
15 = 3 * 5, so replace n with 3 + 5 = 8.
8 = 2 * 2 * 2, so replace n with 2 + 2 + 2 = 6.
6 = 2 * 3, so replace n with 2 + 3 = 5.
5 is the smallest value n will take on.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> Initially, n = 3.
3 is the smallest value n will take on.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int smallestValue(int n) {
        
    }
};","class Solution {
    public int smallestValue(int n) {
        
    }
}","class Solution(object):
    def smallestValue(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def smallestValue(self, n: int) -> int:
        ","int smallestValue(int n){

}","public class Solution {
    public int SmallestValue(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var smallestValue = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def smallest_value(n)
    
end","class Solution {
    func smallestValue(_ n: Int) -> Int {
        
    }
}","func smallestValue(n int) int {
    
}","object Solution {
    def smallestValue(n: Int): Int = {
        
    }
}","class Solution {
    fun smallestValue(n: Int): Int {
        
    }
}","impl Solution {
    pub fn smallest_value(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function smallestValue($n) {
        
    }
}","function smallestValue(n: number): number {

};","(define/contract (smallest-value n)
  (-> exact-integer? exact-integer?)

  )","-spec smallest_value(N :: integer()) -> integer().
smallest_value(N) ->
  .","defmodule Solution do
  @spec smallest_value(n :: integer) :: integer
  def smallest_value(n) do

  end
end","class Solution {
  int smallestValue(int n) {

  }
}",
count-pairs-of-similar-strings,Count Pairs Of Similar Strings,2506.0,2594.0,"<p>You are given a <strong>0-indexed</strong> string array <code>words</code>.</p>

<p>Two strings are <strong>similar</strong> if they consist of the same characters.</p>

<ul>
	<li>For example, <code>&quot;abca&quot;</code> and <code>&quot;cba&quot;</code> are similar since both consist of characters <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, and <code>&#39;c&#39;</code>.</li>
	<li>However, <code>&quot;abacba&quot;</code> and <code>&quot;bcfd&quot;</code> are not similar since they do not consist of the same characters.</li>
</ul>

<p>Return <em>the number of pairs </em><code>(i, j)</code><em> such that </em><code>0 &lt;= i &lt; j &lt;= word.length - 1</code><em> and the two strings </em><code>words[i]</code><em> and </em><code>words[j]</code><em> are similar</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;aba&quot;,&quot;aabb&quot;,&quot;abcd&quot;,&quot;bac&quot;,&quot;aabc&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 2 pairs that satisfy the conditions:
- i = 0 and j = 1 : both words[0] and words[1] only consist of characters &#39;a&#39; and &#39;b&#39;. 
- i = 3 and j = 4 : both words[3] and words[4] only consist of characters &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;. 
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;aabb&quot;,&quot;ab&quot;,&quot;ba&quot;]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 pairs that satisfy the conditions:
- i = 0 and j = 1 : both words[0] and words[1] only consist of characters &#39;a&#39; and &#39;b&#39;. 
- i = 0 and j = 2 : both words[0] and words[2] only consist of characters &#39;a&#39; and &#39;b&#39;.
- i = 1 and j = 2 : both words[1] and words[2] only consist of characters &#39;a&#39; and &#39;b&#39;.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;nba&quot;,&quot;cba&quot;,&quot;dba&quot;]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Since there does not exist any pair that satisfies the conditions, we return 0.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 100</code></li>
	<li><code>words[i]</code> consist of only lowercase English letters.</li>
</ul>
",1.0,False,"class Solution {
public:
    int similarPairs(vector<string>& words) {
        
    }
};","class Solution {
    public int similarPairs(String[] words) {
        
    }
}","class Solution(object):
    def similarPairs(self, words):
        """"""
        :type words: List[str]
        :rtype: int
        """"""
        ","class Solution:
    def similarPairs(self, words: List[str]) -> int:
        ","int similarPairs(char ** words, int wordsSize){

}","public class Solution {
    public int SimilarPairs(string[] words) {
        
    }
}","/**
 * @param {string[]} words
 * @return {number}
 */
var similarPairs = function(words) {
    
};","# @param {String[]} words
# @return {Integer}
def similar_pairs(words)
    
end","class Solution {
    func similarPairs(_ words: [String]) -> Int {
        
    }
}","func similarPairs(words []string) int {
    
}","object Solution {
    def similarPairs(words: Array[String]): Int = {
        
    }
}","class Solution {
    fun similarPairs(words: Array<String>): Int {
        
    }
}","impl Solution {
    pub fn similar_pairs(words: Vec<String>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @return Integer
     */
    function similarPairs($words) {
        
    }
}","function similarPairs(words: string[]): number {

};","(define/contract (similar-pairs words)
  (-> (listof string?) exact-integer?)

  )","-spec similar_pairs(Words :: [unicode:unicode_binary()]) -> integer().
similar_pairs(Words) ->
  .","defmodule Solution do
  @spec similar_pairs(words :: [String.t]) :: integer
  def similar_pairs(words) do

  end
end","class Solution {
  int similarPairs(List<String> words) {

  }
}",
minimum-total-cost-to-make-arrays-unequal,Minimum Total Cost to Make Arrays Unequal,2499.0,2592.0,"<p>You are given two <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, of equal length <code>n</code>.</p>

<p>In one operation, you can swap the values of any two indices of <code>nums1</code>. The <strong>cost</strong> of this operation is the <strong>sum</strong> of the indices.</p>

<p>Find the <strong>minimum</strong> total cost of performing the given operation <strong>any</strong> number of times such that <code>nums1[i] != nums2[i]</code> for all <code>0 &lt;= i &lt;= n - 1</code> after performing all the operations.</p>

<p>Return <em>the <strong>minimum total cost</strong> such that </em><code>nums1</code> and <code>nums2</code><em> satisfy the above condition</em>. In case it is not possible, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]
<strong>Output:</strong> 10
<strong>Explanation:</strong> 
One of the ways we can perform the operations is:
- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]
- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].
- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].
We can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.
Note that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]
<strong>Output:</strong> 10
<strong>Explanation:</strong> 
One of the ways we can perform the operations is:
- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].
- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].
The total cost needed here is 10, which is the minimum possible.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,2], nums2 = [1,2,2]
<strong>Output:</strong> -1
<strong>Explanation:</strong> 
It can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.
Hence, we return -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums1.length == nums2.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[i] &lt;= n</code></li>
</ul>
",3.0,False,"class Solution {
public:
    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        
    }
};","class Solution {
    public long minimumTotalCost(int[] nums1, int[] nums2) {
        
    }
}","class Solution(object):
    def minimumTotalCost(self, nums1, nums2):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        ","long long minimumTotalCost(int* nums1, int nums1Size, int* nums2, int nums2Size){

}","public class Solution {
    public long MinimumTotalCost(int[] nums1, int[] nums2) {
        
    }
}","/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var minimumTotalCost = function(nums1, nums2) {
    
};","# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @return {Integer}
def minimum_total_cost(nums1, nums2)
    
end","class Solution {
    func minimumTotalCost(_ nums1: [Int], _ nums2: [Int]) -> Int {
        
    }
}","func minimumTotalCost(nums1 []int, nums2 []int) int64 {
    
}","object Solution {
    def minimumTotalCost(nums1: Array[Int], nums2: Array[Int]): Long = {
        
    }
}","class Solution {
    fun minimumTotalCost(nums1: IntArray, nums2: IntArray): Long {
        
    }
}","impl Solution {
    pub fn minimum_total_cost(nums1: Vec<i32>, nums2: Vec<i32>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @return Integer
     */
    function minimumTotalCost($nums1, $nums2) {
        
    }
}","function minimumTotalCost(nums1: number[], nums2: number[]): number {

};","(define/contract (minimum-total-cost nums1 nums2)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)

  )","-spec minimum_total_cost(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().
minimum_total_cost(Nums1, Nums2) ->
  .","defmodule Solution do
  @spec minimum_total_cost(nums1 :: [integer], nums2 :: [integer]) :: integer
  def minimum_total_cost(nums1, nums2) do

  end
end","class Solution {
  int minimumTotalCost(List<int> nums1, List<int> nums2) {

  }
}",
frog-jump-ii,Frog Jump II,2498.0,2591.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>stones</code> sorted in <strong>strictly increasing order</strong> representing the positions of stones in a river.</p>

<p>A frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone <strong>at most once</strong>.</p>

<p>The <strong>length</strong> of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps.</p>

<ul>
	<li>More formally, if the frog is at <code>stones[i]</code> and is jumping to <code>stones[j]</code>, the length of the jump is <code>|stones[i] - stones[j]|</code>.</li>
</ul>

<p>The <strong>cost</strong> of a path is the <strong>maximum length of a jump</strong> among all jumps in the path.</p>

<p>Return <em>the <strong>minimum</strong> cost of a path for the frog</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/11/14/example-1.png"" style=""width: 600px; height: 219px;"" />
<pre>
<strong>Input:</strong> stones = [0,2,5,6,7]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The above figure represents one of the optimal paths the frog can take.
The cost of this path is 5, which is the maximum length of a jump.
Since it is not possible to achieve a cost of less than 5, we return it.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/11/14/example-2.png"" style=""width: 500px; height: 171px;"" />
<pre>
<strong>Input:</strong> stones = [0,3,9]
<strong>Output:</strong> 9
<strong>Explanation:</strong> 
The frog can jump directly to the last stone and come back to the first stone. 
In this case, the length of each jump will be 9. The cost for the path will be max(9, 9) = 9.
It can be shown that this is the minimum achievable cost.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= stones.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= stones[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>stones[0] == 0</code></li>
	<li><code>stones</code> is sorted in a strictly increasing order.</li>
</ul>
",2.0,False,"class Solution {
public:
    int maxJump(vector<int>& stones) {
        
    }
};","class Solution {
    public int maxJump(int[] stones) {
        
    }
}","class Solution(object):
    def maxJump(self, stones):
        """"""
        :type stones: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxJump(self, stones: List[int]) -> int:
        ","int maxJump(int* stones, int stonesSize){

}","public class Solution {
    public int MaxJump(int[] stones) {
        
    }
}","/**
 * @param {number[]} stones
 * @return {number}
 */
var maxJump = function(stones) {
    
};","# @param {Integer[]} stones
# @return {Integer}
def max_jump(stones)
    
end","class Solution {
    func maxJump(_ stones: [Int]) -> Int {
        
    }
}","func maxJump(stones []int) int {
    
}","object Solution {
    def maxJump(stones: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxJump(stones: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_jump(stones: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $stones
     * @return Integer
     */
    function maxJump($stones) {
        
    }
}","function maxJump(stones: number[]): number {

};","(define/contract (max-jump stones)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec max_jump(Stones :: [integer()]) -> integer().
max_jump(Stones) ->
  .","defmodule Solution do
  @spec max_jump(stones :: [integer]) :: integer
  def max_jump(stones) do

  end
end","class Solution {
  int maxJump(List<int> stones) {

  }
}",
maximum-star-sum-of-a-graph,Maximum Star Sum of a Graph,2497.0,2590.0,"<p>There is an undirected graph consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>. You are given a <strong>0-indexed</strong> integer array <code>vals</code> of length <code>n</code> where <code>vals[i]</code> denotes the value of the <code>i<sup>th</sup></code> node.</p>

<p>You are also given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting nodes <code>a<sub>i</sub></code> and <code>b<sub>i.</sub></code></p>

<p>A <strong>star graph</strong> is a subgraph of the given graph having a center node containing <code>0</code> or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.</p>

<p>The image below shows star graphs with <code>3</code> and <code>4</code> neighbors respectively, centered at the blue node.</p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-descdrawio.png"" style=""width: 400px; height: 179px;"" />
<p>The <strong>star sum</strong> is the sum of the values of all the nodes present in the star graph.</p>

<p>Given an integer <code>k</code>, return <em>the <strong>maximum star sum</strong> of a star graph containing <strong>at most</strong> </em><code>k</code><em> edges.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-example1drawio.png"" style=""width: 300px; height: 291px;"" />
<pre>
<strong>Input:</strong> vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2
<strong>Output:</strong> 16
<strong>Explanation:</strong> The above diagram represents the input graph.
The star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.
It can be shown it is not possible to get a star graph with a sum greater than 16.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> vals = [-5], edges = [], k = 0
<strong>Output:</strong> -5
<strong>Explanation:</strong> There is only one possible star graph, which is node 0 itself.
Hence, we return -5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == vals.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= vals[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2</code><code>, 10<sup>5</sup>)</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>0 &lt;= k &lt;= n - 1</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {
        
    }
};","class Solution {
    public int maxStarSum(int[] vals, int[][] edges, int k) {
        
    }
}","class Solution(object):
    def maxStarSum(self, vals, edges, k):
        """"""
        :type vals: List[int]
        :type edges: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:
        ","int maxStarSum(int* vals, int valsSize, int** edges, int edgesSize, int* edgesColSize, int k){

}","public class Solution {
    public int MaxStarSum(int[] vals, int[][] edges, int k) {
        
    }
}","/**
 * @param {number[]} vals
 * @param {number[][]} edges
 * @param {number} k
 * @return {number}
 */
var maxStarSum = function(vals, edges, k) {
    
};","# @param {Integer[]} vals
# @param {Integer[][]} edges
# @param {Integer} k
# @return {Integer}
def max_star_sum(vals, edges, k)
    
end","class Solution {
    func maxStarSum(_ vals: [Int], _ edges: [[Int]], _ k: Int) -> Int {
        
    }
}","func maxStarSum(vals []int, edges [][]int, k int) int {
    
}","object Solution {
    def maxStarSum(vals: Array[Int], edges: Array[Array[Int]], k: Int): Int = {
        
    }
}","class Solution {
    fun maxStarSum(vals: IntArray, edges: Array<IntArray>, k: Int): Int {
        
    }
}","impl Solution {
    pub fn max_star_sum(vals: Vec<i32>, edges: Vec<Vec<i32>>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $vals
     * @param Integer[][] $edges
     * @param Integer $k
     * @return Integer
     */
    function maxStarSum($vals, $edges, $k) {
        
    }
}","function maxStarSum(vals: number[], edges: number[][], k: number): number {

};","(define/contract (max-star-sum vals edges k)
  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer? exact-integer?)

  )","-spec max_star_sum(Vals :: [integer()], Edges :: [[integer()]], K :: integer()) -> integer().
max_star_sum(Vals, Edges, K) ->
  .","defmodule Solution do
  @spec max_star_sum(vals :: [integer], edges :: [[integer]], k :: integer) :: integer
  def max_star_sum(vals, edges, k) do

  end
end","class Solution {
  int maxStarSum(List<int> vals, List<List<int>> edges, int k) {

  }
}",
maximum-value-of-a-string-in-an-array,Maximum Value of a String in an Array,2496.0,2589.0,"<p>The <strong>value</strong> of an alphanumeric string can be defined as:</p>

<ul>
	<li>The <strong>numeric</strong> representation of the string in base <code>10</code>, if it comprises of digits <strong>only</strong>.</li>
	<li>The <strong>length</strong> of the string, otherwise.</li>
</ul>

<p>Given an array <code>strs</code> of alphanumeric strings, return <em>the <strong>maximum value</strong> of any string in </em><code>strs</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> strs = [&quot;alic3&quot;,&quot;bob&quot;,&quot;3&quot;,&quot;4&quot;,&quot;00000&quot;]
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
- &quot;alic3&quot; consists of both letters and digits, so its value is its length, i.e. 5.
- &quot;bob&quot; consists only of letters, so its value is also its length, i.e. 3.
- &quot;3&quot; consists only of digits, so its value is its numeric equivalent, i.e. 3.
- &quot;4&quot; also consists only of digits, so its value is 4.
- &quot;00000&quot; consists only of digits, so its value is 0.
Hence, the maximum value is 5, of &quot;alic3&quot;.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> strs = [&quot;1&quot;,&quot;01&quot;,&quot;001&quot;,&quot;0001&quot;]
<strong>Output:</strong> 1
<strong>Explanation:</strong> 
Each string in the array has value 1. Hence, we return 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= strs.length &lt;= 100</code></li>
	<li><code>1 &lt;= strs[i].length &lt;= 9</code></li>
	<li><code>strs[i]</code> consists of only lowercase English letters and digits.</li>
</ul>
",1.0,False,"class Solution {
public:
    int maximumValue(vector<string>& strs) {
        
    }
};","class Solution {
    public int maximumValue(String[] strs) {
        
    }
}","class Solution(object):
    def maximumValue(self, strs):
        """"""
        :type strs: List[str]
        :rtype: int
        """"""
        ","class Solution:
    def maximumValue(self, strs: List[str]) -> int:
        ","int maximumValue(char ** strs, int strsSize){

}","public class Solution {
    public int MaximumValue(string[] strs) {
        
    }
}","/**
 * @param {string[]} strs
 * @return {number}
 */
var maximumValue = function(strs) {
    
};","# @param {String[]} strs
# @return {Integer}
def maximum_value(strs)
    
end","class Solution {
    func maximumValue(_ strs: [String]) -> Int {
        
    }
}","func maximumValue(strs []string) int {
    
}","object Solution {
    def maximumValue(strs: Array[String]): Int = {
        
    }
}","class Solution {
    fun maximumValue(strs: Array<String>): Int {
        
    }
}","impl Solution {
    pub fn maximum_value(strs: Vec<String>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $strs
     * @return Integer
     */
    function maximumValue($strs) {
        
    }
}","function maximumValue(strs: string[]): number {

};","(define/contract (maximum-value strs)
  (-> (listof string?) exact-integer?)

  )","-spec maximum_value(Strs :: [unicode:unicode_binary()]) -> integer().
maximum_value(Strs) ->
  .","defmodule Solution do
  @spec maximum_value(strs :: [String.t]) :: integer
  def maximum_value(strs) do

  end
end","class Solution {
  int maximumValue(List<String> strs) {

  }
}",
maximum-number-of-points-from-grid-queries,Maximum Number of Points From Grid Queries,2503.0,2588.0,"<p>You are given an <code>m x n</code> integer matrix <code>grid</code> and an array <code>queries</code> of size <code>k</code>.</p>

<p>Find an array <code>answer</code> of size <code>k</code> such that for each integer <code>queries[i]</code> you start in the <strong>top left</strong> cell of the matrix and repeat the following process:</p>

<ul>
	<li>If <code>queries[i]</code> is <strong>strictly</strong> greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any <strong>adjacent</strong> cell in all <code>4</code> directions: up, down, left, and right.</li>
	<li>Otherwise, you do not get any points, and you end this process.</li>
</ul>

<p>After the process, <code>answer[i]</code> is the <strong>maximum</strong> number of points you can get. <strong>Note</strong> that for each query you are allowed to visit the same cell <strong>multiple</strong> times.</p>

<p>Return <em>the resulting array</em> <code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/19/yetgriddrawio.png"" style=""width: 571px; height: 151px;"" />
<pre>
<strong>Input:</strong> grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]
<strong>Output:</strong> [5,8,1]
<strong>Explanation:</strong> The diagrams above show which cells we visit to get points for each query.</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png"" />
<pre>
<strong>Input:</strong> grid = [[5,2,1],[1,1,2]], queries = [3]
<strong>Output:</strong> [0]
<strong>Explanation:</strong> We can not get any points because the value of the top left cell is already greater than or equal to 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>k == queries.length</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= grid[i][j], queries[i] &lt;= 10<sup>6</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {
        
    }
};","class Solution {
    public int[] maxPoints(int[][] grid, int[] queries) {
        
    }
}","class Solution(object):
    def maxPoints(self, grid, queries):
        """"""
        :type grid: List[List[int]]
        :type queries: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* maxPoints(int** grid, int gridSize, int* gridColSize, int* queries, int queriesSize, int* returnSize){

}","public class Solution {
    public int[] MaxPoints(int[][] grid, int[] queries) {
        
    }
}","/**
 * @param {number[][]} grid
 * @param {number[]} queries
 * @return {number[]}
 */
var maxPoints = function(grid, queries) {
    
};","# @param {Integer[][]} grid
# @param {Integer[]} queries
# @return {Integer[]}
def max_points(grid, queries)
    
end","class Solution {
    func maxPoints(_ grid: [[Int]], _ queries: [Int]) -> [Int] {
        
    }
}","func maxPoints(grid [][]int, queries []int) []int {
    
}","object Solution {
    def maxPoints(grid: Array[Array[Int]], queries: Array[Int]): Array[Int] = {
        
    }
}","class Solution {
    fun maxPoints(grid: Array<IntArray>, queries: IntArray): IntArray {
        
    }
}","impl Solution {
    pub fn max_points(grid: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @param Integer[] $queries
     * @return Integer[]
     */
    function maxPoints($grid, $queries) {
        
    }
}","function maxPoints(grid: number[][], queries: number[]): number[] {

};","(define/contract (max-points grid queries)
  (-> (listof (listof exact-integer?)) (listof exact-integer?) (listof exact-integer?))

  )","-spec max_points(Grid :: [[integer()]], Queries :: [integer()]) -> [integer()].
max_points(Grid, Queries) ->
  .","defmodule Solution do
  @spec max_points(grid :: [[integer]], queries :: [integer]) :: [integer]
  def max_points(grid, queries) do

  end
end","class Solution {
  List<int> maxPoints(List<List<int>> grid, List<int> queries) {

  }
}",
design-memory-allocator,Design Memory Allocator,2502.0,2587.0,"<p>You are given an integer <code>n</code> representing the size of a <strong>0-indexed</strong> memory array. All memory units are initially free.</p>

<p>You have a memory allocator with the following functionalities:</p>

<ol>
	<li><strong>Allocate </strong>a block of <code>size</code> consecutive free memory units and assign it the id <code>mID</code>.</li>
	<li><strong>Free</strong> all memory units with the given id <code>mID</code>.</li>
</ol>

<p><strong>Note</strong> that:</p>

<ul>
	<li>Multiple blocks can be allocated to the same <code>mID</code>.</li>
	<li>You should free all the memory units with <code>mID</code>, even if they were allocated in different blocks.</li>
</ul>

<p>Implement the <code>Allocator</code> class:</p>

<ul>
	<li><code>Allocator(int n)</code> Initializes an <code>Allocator</code> object with a memory array of size <code>n</code>.</li>
	<li><code>int allocate(int size, int mID)</code> Find the <strong>leftmost</strong> block of <code>size</code> <strong>consecutive</strong> free memory units and allocate it with the id <code>mID</code>. Return the block&#39;s first index. If such a block does not exist, return <code>-1</code>.</li>
	<li><code>int free(int mID)</code> Free all memory units with the id <code>mID</code>. Return the number of memory units you have freed.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;Allocator&quot;, &quot;allocate&quot;, &quot;allocate&quot;, &quot;allocate&quot;, &quot;free&quot;, &quot;allocate&quot;, &quot;allocate&quot;, &quot;allocate&quot;, &quot;free&quot;, &quot;allocate&quot;, &quot;free&quot;]
[[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]
<strong>Output</strong>
[null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]

<strong>Explanation</strong>
Allocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free.
loc.allocate(1, 1); // The leftmost block&#39;s first index is 0. The memory array becomes [<strong>1</strong>,_,_,_,_,_,_,_,_,_]. We return 0.
loc.allocate(1, 2); // The leftmost block&#39;s first index is 1. The memory array becomes [1,<strong>2</strong>,_,_,_,_,_,_,_,_]. We return 1.
loc.allocate(1, 3); // The leftmost block&#39;s first index is 2. The memory array becomes [1,2,<strong>3</strong>,_,_,_,_,_,_,_]. We return 2.
loc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2.
loc.allocate(3, 4); // The leftmost block&#39;s first index is 3. The memory array becomes [1,_,3,<strong>4</strong>,<strong>4</strong>,<strong>4</strong>,_,_,_,_]. We return 3.
loc.allocate(1, 1); // The leftmost block&#39;s first index is 1. The memory array becomes [1,<strong>1</strong>,3,4,4,4,_,_,_,_]. We return 1.
loc.allocate(1, 1); // The leftmost block&#39;s first index is 6. The memory array becomes [1,1,3,4,4,4,<strong>1</strong>,_,_,_]. We return 6.
loc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1.
loc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1.
loc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n, size, mID &lt;= 1000</code></li>
	<li>At most <code>1000</code> calls will be made to <code>allocate</code> and <code>free</code>.</li>
</ul>
",2.0,False,"class Allocator {
public:
    Allocator(int n) {
        
    }
    
    int allocate(int size, int mID) {
        
    }
    
    int free(int mID) {
        
    }
};

/**
 * Your Allocator object will be instantiated and called as such:
 * Allocator* obj = new Allocator(n);
 * int param_1 = obj->allocate(size,mID);
 * int param_2 = obj->free(mID);
 */","class Allocator {

    public Allocator(int n) {
        
    }
    
    public int allocate(int size, int mID) {
        
    }
    
    public int free(int mID) {
        
    }
}

/**
 * Your Allocator object will be instantiated and called as such:
 * Allocator obj = new Allocator(n);
 * int param_1 = obj.allocate(size,mID);
 * int param_2 = obj.free(mID);
 */","class Allocator(object):

    def __init__(self, n):
        """"""
        :type n: int
        """"""
        

    def allocate(self, size, mID):
        """"""
        :type size: int
        :type mID: int
        :rtype: int
        """"""
        

    def free(self, mID):
        """"""
        :type mID: int
        :rtype: int
        """"""
        


# Your Allocator object will be instantiated and called as such:
# obj = Allocator(n)
# param_1 = obj.allocate(size,mID)
# param_2 = obj.free(mID)","class Allocator:

    def __init__(self, n: int):
        

    def allocate(self, size: int, mID: int) -> int:
        

    def free(self, mID: int) -> int:
        


# Your Allocator object will be instantiated and called as such:
# obj = Allocator(n)
# param_1 = obj.allocate(size,mID)
# param_2 = obj.free(mID)","


typedef struct {
    
} Allocator;


Allocator* allocatorCreate(int n) {
    
}

int allocatorAllocate(Allocator* obj, int size, int mID) {
  
}

int allocatorFree(Allocator* obj, int mID) {
  
}

void allocatorFree(Allocator* obj) {
    
}

/**
 * Your Allocator struct will be instantiated and called as such:
 * Allocator* obj = allocatorCreate(n);
 * int param_1 = allocatorAllocate(obj, size, mID);
 
 * int param_2 = allocatorFree(obj, mID);
 
 * allocatorFree(obj);
*/","public class Allocator {

    public Allocator(int n) {
        
    }
    
    public int Allocate(int size, int mID) {
        
    }
    
    public int Free(int mID) {
        
    }
}

/**
 * Your Allocator object will be instantiated and called as such:
 * Allocator obj = new Allocator(n);
 * int param_1 = obj.Allocate(size,mID);
 * int param_2 = obj.Free(mID);
 */","/**
 * @param {number} n
 */
var Allocator = function(n) {
    
};

/** 
 * @param {number} size 
 * @param {number} mID
 * @return {number}
 */
Allocator.prototype.allocate = function(size, mID) {
    
};

/** 
 * @param {number} mID
 * @return {number}
 */
Allocator.prototype.free = function(mID) {
    
};

/** 
 * Your Allocator object will be instantiated and called as such:
 * var obj = new Allocator(n)
 * var param_1 = obj.allocate(size,mID)
 * var param_2 = obj.free(mID)
 */","class Allocator

=begin
    :type n: Integer
=end
    def initialize(n)
        
    end


=begin
    :type size: Integer
    :type m_id: Integer
    :rtype: Integer
=end
    def allocate(size, m_id)
        
    end


=begin
    :type m_id: Integer
    :rtype: Integer
=end
    def free(m_id)
        
    end


end

# Your Allocator object will be instantiated and called as such:
# obj = Allocator.new(n)
# param_1 = obj.allocate(size, m_id)
# param_2 = obj.free(m_id)","
class Allocator {

    init(_ n: Int) {
        
    }
    
    func allocate(_ size: Int, _ mID: Int) -> Int {
        
    }
    
    func free(_ mID: Int) -> Int {
        
    }
}

/**
 * Your Allocator object will be instantiated and called as such:
 * let obj = Allocator(n)
 * let ret_1: Int = obj.allocate(size, mID)
 * let ret_2: Int = obj.free(mID)
 */","type Allocator struct {
    
}


func Constructor(n int) Allocator {
    
}


func (this *Allocator) Allocate(size int, mID int) int {
    
}


func (this *Allocator) Free(mID int) int {
    
}


/**
 * Your Allocator object will be instantiated and called as such:
 * obj := Constructor(n);
 * param_1 := obj.Allocate(size,mID);
 * param_2 := obj.Free(mID);
 */","class Allocator(_n: Int) {

    def allocate(size: Int, mID: Int): Int = {
        
    }

    def free(mID: Int): Int = {
        
    }

}

/**
 * Your Allocator object will be instantiated and called as such:
 * var obj = new Allocator(n)
 * var param_1 = obj.allocate(size,mID)
 * var param_2 = obj.free(mID)
 */","class Allocator(n: Int) {

    fun allocate(size: Int, mID: Int): Int {
        
    }

    fun free(mID: Int): Int {
        
    }

}

/**
 * Your Allocator object will be instantiated and called as such:
 * var obj = Allocator(n)
 * var param_1 = obj.allocate(size,mID)
 * var param_2 = obj.free(mID)
 */","struct Allocator {

}


/** 
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl Allocator {

    fn new(n: i32) -> Self {
        
    }
    
    fn allocate(&self, size: i32, m_id: i32) -> i32 {
        
    }
    
    fn free(&self, m_id: i32) -> i32 {
        
    }
}

/**
 * Your Allocator object will be instantiated and called as such:
 * let obj = Allocator::new(n);
 * let ret_1: i32 = obj.allocate(size, mID);
 * let ret_2: i32 = obj.free(mID);
 */","class Allocator {
    /**
     * @param Integer $n
     */
    function __construct($n) {
        
    }
  
    /**
     * @param Integer $size
     * @param Integer $mID
     * @return Integer
     */
    function allocate($size, $mID) {
        
    }
  
    /**
     * @param Integer $mID
     * @return Integer
     */
    function free($mID) {
        
    }
}

/**
 * Your Allocator object will be instantiated and called as such:
 * $obj = Allocator($n);
 * $ret_1 = $obj->allocate($size, $mID);
 * $ret_2 = $obj->free($mID);
 */","class Allocator {
    constructor(n: number) {

    }

    allocate(size: number, mID: number): number {

    }

    free(mID: number): number {

    }
}

/**
 * Your Allocator object will be instantiated and called as such:
 * var obj = new Allocator(n)
 * var param_1 = obj.allocate(size,mID)
 * var param_2 = obj.free(mID)
 */","(define allocator%
  (class object%
    (super-new)
    
    ; n : exact-integer?
    (init-field
      n)
    
    ; allocate : exact-integer? exact-integer? -> exact-integer?
    (define/public (allocate size m-id)

      )
    ; free : exact-integer? -> exact-integer?
    (define/public (free m-id)

      )))

;; Your allocator% object will be instantiated and called as such:
;; (define obj (new allocator% [n n]))
;; (define param_1 (send obj allocate size m-id))
;; (define param_2 (send obj free m-id))","-spec allocator_init_(N :: integer()) -> any().
allocator_init_(N) ->
  .

-spec allocator_allocate(Size :: integer(), MID :: integer()) -> integer().
allocator_allocate(Size, MID) ->
  .

-spec allocator_free(MID :: integer()) -> integer().
allocator_free(MID) ->
  .


%% Your functions will be called as such:
%% allocator_init_(N),
%% Param_1 = allocator_allocate(Size, MID),
%% Param_2 = allocator_free(MID),

%% allocator_init_ will be called before every test case, in which you can do some necessary initializations.","defmodule Allocator do
  @spec init_(n :: integer) :: any
  def init_(n) do

  end

  @spec allocate(size :: integer, m_id :: integer) :: integer
  def allocate(size, m_id) do

  end

  @spec free(m_id :: integer) :: integer
  def free(m_id) do

  end
end

# Your functions will be called as such:
# Allocator.init_(n)
# param_1 = Allocator.allocate(size, m_id)
# param_2 = Allocator.free(m_id)

# Allocator.init_ will be called before every test case, in which you can do some necessary initializations.","class Allocator {

  Allocator(int n) {

  }
  
  int allocate(int size, int mID) {

  }
  
  int free(int mID) {

  }
}

/**
 * Your Allocator object will be instantiated and called as such:
 * Allocator obj = Allocator(n);
 * int param1 = obj.allocate(size,mID);
 * int param2 = obj.free(mID);
 */",
longest-square-streak-in-an-array,Longest Square Streak in an Array,2501.0,2586.0,"<p>You are given an integer array <code>nums</code>. A subsequence of <code>nums</code> is called a <strong>square streak</strong> if:</p>

<ul>
	<li>The length of the subsequence is at least <code>2</code>, and</li>
	<li><strong>after</strong> sorting the subsequence, each element (except the first element) is the <strong>square</strong> of the previous number.</li>
</ul>

<p>Return<em> the length of the <strong>longest square streak</strong> in </em><code>nums</code><em>, or return </em><code>-1</code><em> if there is no <strong>square streak</strong>.</em></p>

<p>A <strong>subsequence</strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,6,16,8,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16].
- 4 = 2 * 2.
- 16 = 4 * 4.
Therefore, [4,16,2] is a square streak.
It can be shown that every subsequence of length 4 is not a square streak.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,5,6,7]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no square streak in nums so return -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    int longestSquareStreak(vector<int>& nums) {
        
    }
};","class Solution {
    public int longestSquareStreak(int[] nums) {
        
    }
}","class Solution(object):
    def longestSquareStreak(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def longestSquareStreak(self, nums: List[int]) -> int:
        ","int longestSquareStreak(int* nums, int numsSize){

}","public class Solution {
    public int LongestSquareStreak(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var longestSquareStreak = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def longest_square_streak(nums)
    
end","class Solution {
    func longestSquareStreak(_ nums: [Int]) -> Int {
        
    }
}","func longestSquareStreak(nums []int) int {
    
}","object Solution {
    def longestSquareStreak(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun longestSquareStreak(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn longest_square_streak(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function longestSquareStreak($nums) {
        
    }
}","function longestSquareStreak(nums: number[]): number {

};","(define/contract (longest-square-streak nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec longest_square_streak(Nums :: [integer()]) -> integer().
longest_square_streak(Nums) ->
  .","defmodule Solution do
  @spec longest_square_streak(nums :: [integer]) :: integer
  def longest_square_streak(nums) do

  end
end","class Solution {
  int longestSquareStreak(List<int> nums) {

  }
}",
delete-greatest-value-in-each-row,Delete Greatest Value in Each Row,2500.0,2585.0,"<p>You are given an <code>m x n</code> matrix <code>grid</code> consisting of positive integers.</p>

<p>Perform the following operation until <code>grid</code> becomes empty:</p>

<ul>
	<li>Delete the element with the greatest value from each row. If multiple such elements exist, delete any of them.</li>
	<li>Add the maximum of deleted elements to the answer.</li>
</ul>

<p><strong>Note</strong> that the number of columns decreases by one after each operation.</p>

<p>Return <em>the answer after performing the operations described above</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/19/q1ex1.jpg"" style=""width: 600px; height: 135px;"" />
<pre>
<strong>Input:</strong> grid = [[1,2,4],[3,3,1]]
<strong>Output:</strong> 8
<strong>Explanation:</strong> The diagram above shows the removed values in each step.
- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.
- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.
- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.
The final answer = 4 + 3 + 1 = 8.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/19/q1ex2.jpg"" style=""width: 83px; height: 83px;"" />
<pre>
<strong>Input:</strong> grid = [[10]]
<strong>Output:</strong> 10
<strong>Explanation:</strong> The diagram above shows the removed values in each step.
- In the first operation, we remove 10 from the first row. We add 10 to the answer.
The final answer = 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int deleteGreatestValue(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int deleteGreatestValue(int[][] grid) {
        
    }
}","class Solution(object):
    def deleteGreatestValue(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        ","int deleteGreatestValue(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int DeleteGreatestValue(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var deleteGreatestValue = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def delete_greatest_value(grid)
    
end","class Solution {
    func deleteGreatestValue(_ grid: [[Int]]) -> Int {
        
    }
}","func deleteGreatestValue(grid [][]int) int {
    
}","object Solution {
    def deleteGreatestValue(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun deleteGreatestValue(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn delete_greatest_value(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function deleteGreatestValue($grid) {
        
    }
}","function deleteGreatestValue(grid: number[][]): number {

};","(define/contract (delete-greatest-value grid)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec delete_greatest_value(Grid :: [[integer()]]) -> integer().
delete_greatest_value(Grid) ->
  .","defmodule Solution do
  @spec delete_greatest_value(grid :: [[integer]]) :: integer
  def delete_greatest_value(grid) do

  end
end","class Solution {
  int deleteGreatestValue(List<List<int>> grid) {

  }
}",
divide-nodes-into-the-maximum-number-of-groups,Divide Nodes Into the Maximum Number of Groups,2493.0,2583.0,"<p>You are given a positive integer <code>n</code> representing the number of nodes in an <strong>undirected</strong> graph. The nodes are labeled from <code>1</code> to <code>n</code>.</p>

<p>You are also given a 2D integer array <code>edges</code>, where <code>edges[i] = [a<sub>i, </sub>b<sub>i</sub>]</code> indicates that there is a <strong>bidirectional</strong> edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. <strong>Notice</strong> that the given graph may be disconnected.</p>

<p>Divide the nodes of the graph into <code>m</code> groups (<strong>1-indexed</strong>) such that:</p>

<ul>
	<li>Each node in the graph belongs to exactly one group.</li>
	<li>For every pair of nodes in the graph that are connected by an edge <code>[a<sub>i, </sub>b<sub>i</sub>]</code>, if <code>a<sub>i</sub></code> belongs to the group with index <code>x</code>, and <code>b<sub>i</sub></code> belongs to the group with index <code>y</code>, then <code>|y - x| = 1</code>.</li>
</ul>

<p>Return <em>the maximum number of groups (i.e., maximum </em><code>m</code><em>) into which you can divide the nodes</em>. Return <code>-1</code> <em>if it is impossible to group the nodes with the given conditions</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/13/example1.png"" style=""width: 352px; height: 201px;"" />
<pre>
<strong>Input:</strong> n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> As shown in the image we:
- Add node 5 to the first group.
- Add node 1 to the second group.
- Add nodes 2 and 4 to the third group.
- Add nodes 3 and 6 to the fourth group.
We can see that every edge is satisfied.
It can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[1,2],[2,3],[3,1]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.
It can be shown that no grouping is possible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>1 &lt;= edges.length &lt;= 10<sup>4</sup></code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There is at most one edge between any pair of vertices.</li>
</ul>
",3.0,False,"class Solution {
public:
    int magnificentSets(int n, vector<vector<int>>& edges) {
        
    }
};","class Solution {
    public int magnificentSets(int n, int[][] edges) {
        
    }
}","class Solution(object):
    def magnificentSets(self, n, edges):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:
        ","int magnificentSets(int n, int** edges, int edgesSize, int* edgesColSize){

}","public class Solution {
    public int MagnificentSets(int n, int[][] edges) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number}
 */
var magnificentSets = function(n, edges) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @return {Integer}
def magnificent_sets(n, edges)
    
end","class Solution {
    func magnificentSets(_ n: Int, _ edges: [[Int]]) -> Int {
        
    }
}","func magnificentSets(n int, edges [][]int) int {
    
}","object Solution {
    def magnificentSets(n: Int, edges: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun magnificentSets(n: Int, edges: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn magnificent_sets(n: i32, edges: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @return Integer
     */
    function magnificentSets($n, $edges) {
        
    }
}","function magnificentSets(n: number, edges: number[][]): number {

};","(define/contract (magnificent-sets n edges)
  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)

  )","-spec magnificent_sets(N :: integer(), Edges :: [[integer()]]) -> integer().
magnificent_sets(N, Edges) ->
  .","defmodule Solution do
  @spec magnificent_sets(n :: integer, edges :: [[integer]]) :: integer
  def magnificent_sets(n, edges) do

  end
end","class Solution {
  int magnificentSets(int n, List<List<int>> edges) {

  }
}",
minimum-score-of-a-path-between-two-cities,Minimum Score of a Path Between Two Cities,2492.0,2582.0,"<p>You are given a positive integer <code>n</code> representing <code>n</code> cities numbered from <code>1</code> to <code>n</code>. You are also given a <strong>2D</strong> array <code>roads</code> where <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>, distance<sub>i</sub>]</code> indicates that there is a <strong>bidirectional </strong>road between cities <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> with a distance equal to <code>distance<sub>i</sub></code>. The cities graph is not necessarily connected.</p>

<p>The <strong>score</strong> of a path between two cities is defined as the <strong>minimum </strong>distance of a road in this path.</p>

<p>Return <em>the <strong>minimum </strong>possible score of a path between cities </em><code>1</code><em> and </em><code>n</code>.</p>

<p><strong>Note</strong>:</p>

<ul>
	<li>A path is a sequence of roads between two cities.</li>
	<li>It is allowed for a path to contain the same road <strong>multiple</strong> times, and you can visit cities <code>1</code> and <code>n</code> multiple times along the path.</li>
	<li>The test cases are generated such that there is <strong>at least</strong> one path between <code>1</code> and <code>n</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/12/graph11.png"" style=""width: 190px; height: 231px;"" />
<pre>
<strong>Input:</strong> n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The path from city 1 to 4 with the minimum score is: 1 -&gt; 2 -&gt; 4. The score of this path is min(9,5) = 5.
It can be shown that no other path has less score.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/12/graph22.png"" style=""width: 190px; height: 231px;"" />
<pre>
<strong>Input:</strong> n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path from city 1 to 4 with the minimum score is: 1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4. The score of this path is min(2,2,4,7) = 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= roads.length &lt;= 10<sup>5</sup></code></li>
	<li><code>roads[i].length == 3</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>1 &lt;= distance<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li>There are no repeated edges.</li>
	<li>There is at least one path between <code>1</code> and <code>n</code>.</li>
</ul>
",2.0,False,"class Solution {
public:
    int minScore(int n, vector<vector<int>>& roads) {
        
    }
};","class Solution {
    public int minScore(int n, int[][] roads) {
        
    }
}","class Solution(object):
    def minScore(self, n, roads):
        """"""
        :type n: int
        :type roads: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minScore(self, n: int, roads: List[List[int]]) -> int:
        ","int minScore(int n, int** roads, int roadsSize, int* roadsColSize){

}","public class Solution {
    public int MinScore(int n, int[][] roads) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} roads
 * @return {number}
 */
var minScore = function(n, roads) {
    
};","# @param {Integer} n
# @param {Integer[][]} roads
# @return {Integer}
def min_score(n, roads)
    
end","class Solution {
    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {
        
    }
}","func minScore(n int, roads [][]int) int {
    
}","object Solution {
    def minScore(n: Int, roads: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun minScore(n: Int, roads: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn min_score(n: i32, roads: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $roads
     * @return Integer
     */
    function minScore($n, $roads) {
        
    }
}","function minScore(n: number, roads: number[][]): number {

};","(define/contract (min-score n roads)
  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)

  )","-spec min_score(N :: integer(), Roads :: [[integer()]]) -> integer().
min_score(N, Roads) ->
  .","defmodule Solution do
  @spec min_score(n :: integer, roads :: [[integer]]) :: integer
  def min_score(n, roads) do

  end
end","class Solution {
  int minScore(int n, List<List<int>> roads) {

  }
}",
divide-players-into-teams-of-equal-skill,Divide Players Into Teams of Equal Skill,2491.0,2581.0,"<p>You are given a positive integer array <code>skill</code> of <strong>even</strong> length <code>n</code> where <code>skill[i]</code> denotes the skill of the <code>i<sup>th</sup></code> player. Divide the players into <code>n / 2</code> teams of size <code>2</code> such that the total skill of each team is <strong>equal</strong>.</p>

<p>The <strong>chemistry</strong> of a team is equal to the <strong>product</strong> of the skills of the players on that team.</p>

<p>Return <em>the sum of the <strong>chemistry</strong> of all the teams, or return </em><code>-1</code><em> if there is no way to divide the players into teams such that the total skill of each team is equal.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> skill = [3,2,5,1,3,4]
<strong>Output:</strong> 22
<strong>Explanation:</strong> 
Divide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.
The sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> skill = [3,4]
<strong>Output:</strong> 12
<strong>Explanation:</strong> 
The two players form a team with a total skill of 7.
The chemistry of the team is 3 * 4 = 12.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> skill = [1,1,2,3]
<strong>Output:</strong> -1
<strong>Explanation:</strong> 
There is no way to divide the players into teams such that the total skill of each team is equal.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= skill.length &lt;= 10<sup>5</sup></code></li>
	<li><code>skill.length</code> is even.</li>
	<li><code>1 &lt;= skill[i] &lt;= 1000</code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        
    }
};","class Solution {
    public long dividePlayers(int[] skill) {
        
    }
}","class Solution(object):
    def dividePlayers(self, skill):
        """"""
        :type skill: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def dividePlayers(self, skill: List[int]) -> int:
        ","long long dividePlayers(int* skill, int skillSize){

}","public class Solution {
    public long DividePlayers(int[] skill) {
        
    }
}","/**
 * @param {number[]} skill
 * @return {number}
 */
var dividePlayers = function(skill) {
    
};","# @param {Integer[]} skill
# @return {Integer}
def divide_players(skill)
    
end","class Solution {
    func dividePlayers(_ skill: [Int]) -> Int {
        
    }
}","func dividePlayers(skill []int) int64 {
    
}","object Solution {
    def dividePlayers(skill: Array[Int]): Long = {
        
    }
}","class Solution {
    fun dividePlayers(skill: IntArray): Long {
        
    }
}","impl Solution {
    pub fn divide_players(skill: Vec<i32>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $skill
     * @return Integer
     */
    function dividePlayers($skill) {
        
    }
}","function dividePlayers(skill: number[]): number {

};","(define/contract (divide-players skill)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec divide_players(Skill :: [integer()]) -> integer().
divide_players(Skill) ->
  .","defmodule Solution do
  @spec divide_players(skill :: [integer]) :: integer
  def divide_players(skill) do

  end
end","class Solution {
  int dividePlayers(List<int> skill) {

  }
}",
circular-sentence,Circular Sentence,2490.0,2580.0,"<p>A <strong>sentence</strong> is a list of words that are separated by a<strong> single</strong> space with no leading or trailing spaces.</p>

<ul>
	<li>For example, <code>&quot;Hello World&quot;</code>, <code>&quot;HELLO&quot;</code>, <code>&quot;hello world hello world&quot;</code> are all sentences.</li>
</ul>

<p>Words consist of <strong>only</strong> uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different.</p>

<p>A sentence is <strong>circular </strong>if:</p>

<ul>
	<li>The last character of a word is equal to the first character of the next word.</li>
	<li>The last character of the last word is equal to the first character of the first word.</li>
</ul>

<p>For example, <code>&quot;leetcode exercises sound delightful&quot;</code>, <code>&quot;eetcode&quot;</code>, <code>&quot;leetcode eats soul&quot; </code>are all circular sentences. However, <code>&quot;Leetcode is cool&quot;</code>, <code>&quot;happy Leetcode&quot;</code>, <code>&quot;Leetcode&quot;</code> and <code>&quot;I like Leetcode&quot;</code> are <strong>not</strong> circular sentences.</p>

<p>Given a string <code>sentence</code>, return <code>true</code><em> if it is circular</em>. Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> sentence = &quot;leetcode exercises sound delightful&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> The words in sentence are [&quot;leetcode&quot;, &quot;exercises&quot;, &quot;sound&quot;, &quot;delightful&quot;].
- leetcod<u>e</u>&#39;s&nbsp;last character is equal to <u>e</u>xercises&#39;s first character.
- exercise<u>s</u>&#39;s&nbsp;last character is equal to <u>s</u>ound&#39;s first character.
- soun<u>d</u>&#39;s&nbsp;last character is equal to <u>d</u>elightful&#39;s first character.
- delightfu<u>l</u>&#39;s&nbsp;last character is equal to <u>l</u>eetcode&#39;s first character.
The sentence is circular.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> sentence = &quot;eetcode&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> The words in sentence are [&quot;eetcode&quot;].
- eetcod<u>e</u>&#39;s&nbsp;last character is equal to <u>e</u>etcode&#39;s first character.
The sentence is circular.</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> sentence = &quot;Leetcode is cool&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> The words in sentence are [&quot;Leetcode&quot;, &quot;is&quot;, &quot;cool&quot;].
- Leetcod<u>e</u>&#39;s&nbsp;last character is <strong>not</strong> equal to <u>i</u>s&#39;s first character.
The sentence is <strong>not</strong> circular.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= sentence.length &lt;= 500</code></li>
	<li><code>sentence</code> consist of only lowercase and uppercase English letters and spaces.</li>
	<li>The words in <code>sentence</code> are separated by a single space.</li>
	<li>There are no leading or trailing spaces.</li>
</ul>
",1.0,False,"class Solution {
public:
    bool isCircularSentence(string sentence) {
        
    }
};","class Solution {
    public boolean isCircularSentence(String sentence) {
        
    }
}","class Solution(object):
    def isCircularSentence(self, sentence):
        """"""
        :type sentence: str
        :rtype: bool
        """"""
        ","class Solution:
    def isCircularSentence(self, sentence: str) -> bool:
        ","bool isCircularSentence(char * sentence){

}","public class Solution {
    public bool IsCircularSentence(string sentence) {
        
    }
}","/**
 * @param {string} sentence
 * @return {boolean}
 */
var isCircularSentence = function(sentence) {
    
};","# @param {String} sentence
# @return {Boolean}
def is_circular_sentence(sentence)
    
end","class Solution {
    func isCircularSentence(_ sentence: String) -> Bool {
        
    }
}","func isCircularSentence(sentence string) bool {
    
}","object Solution {
    def isCircularSentence(sentence: String): Boolean = {
        
    }
}","class Solution {
    fun isCircularSentence(sentence: String): Boolean {
        
    }
}","impl Solution {
    pub fn is_circular_sentence(sentence: String) -> bool {
        
    }
}","class Solution {

    /**
     * @param String $sentence
     * @return Boolean
     */
    function isCircularSentence($sentence) {
        
    }
}","function isCircularSentence(sentence: string): boolean {

};","(define/contract (is-circular-sentence sentence)
  (-> string? boolean?)

  )","-spec is_circular_sentence(Sentence :: unicode:unicode_binary()) -> boolean().
is_circular_sentence(Sentence) ->
  .","defmodule Solution do
  @spec is_circular_sentence(sentence :: String.t) :: boolean
  def is_circular_sentence(sentence) do

  end
end","class Solution {
  bool isCircularSentence(String sentence) {

  }
}",
count-palindromic-subsequences,Count Palindromic Subsequences,2484.0,2577.0,"<p>Given a string of digits <code>s</code>, return <em>the number of <strong>palindromic subsequences</strong> of</em> <code>s</code><em> having length </em><code>5</code>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p><strong>Note:</strong></p>

<ul>
	<li>A string is <strong>palindromic</strong> if it reads the same forward and backward.</li>
	<li>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;103301&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
There are 6 possible subsequences of length 5: &quot;10330&quot;,&quot;10331&quot;,&quot;10301&quot;,&quot;10301&quot;,&quot;13301&quot;,&quot;03301&quot;. 
Two of them (both equal to &quot;10301&quot;) are palindromic.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;0000000&quot;
<strong>Output:</strong> 21
<strong>Explanation:</strong> All 21 subsequences are &quot;00000&quot;, which is palindromic.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;9999900000&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> The only two palindromic subsequences are &quot;99999&quot; and &quot;00000&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s</code> consists of digits.</li>
</ul>
",3.0,False,"class Solution {
public:
    int countPalindromes(string s) {
        
    }
};","class Solution {
    public int countPalindromes(String s) {
        
    }
}","class Solution(object):
    def countPalindromes(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def countPalindromes(self, s: str) -> int:
        ","int countPalindromes(char * s){

}","public class Solution {
    public int CountPalindromes(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var countPalindromes = function(s) {
    
};","# @param {String} s
# @return {Integer}
def count_palindromes(s)
    
end","class Solution {
    func countPalindromes(_ s: String) -> Int {
        
    }
}","func countPalindromes(s string) int {
    
}","object Solution {
    def countPalindromes(s: String): Int = {
        
    }
}","class Solution {
    fun countPalindromes(s: String): Int {
        
    }
}","impl Solution {
    pub fn count_palindromes(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function countPalindromes($s) {
        
    }
}","function countPalindromes(s: string): number {

};","(define/contract (count-palindromes s)
  (-> string? exact-integer?)

  )","-spec count_palindromes(S :: unicode:unicode_binary()) -> integer().
count_palindromes(S) ->
  .","defmodule Solution do
  @spec count_palindromes(s :: String.t) :: integer
  def count_palindromes(s) do

  end
end","class Solution {
  int countPalindromes(String s) {

  }
}",
minimum-penalty-for-a-shop,Minimum Penalty for a Shop,2483.0,2576.0,"<p>You are given the customer visit log of a shop represented by a <strong>0-indexed</strong> string <code>customers</code> consisting only of characters <code>&#39;N&#39;</code> and <code>&#39;Y&#39;</code>:</p>

<ul>
	<li>if the <code>i<sup>th</sup></code> character is <code>&#39;Y&#39;</code>, it means that customers come at the <code>i<sup>th</sup></code> hour</li>
	<li>whereas <code>&#39;N&#39;</code> indicates that no customers come at the <code>i<sup>th</sup></code> hour.</li>
</ul>

<p>If the shop closes at the <code>j<sup>th</sup></code> hour (<code>0 &lt;= j &lt;= n</code>), the <strong>penalty</strong> is calculated as follows:</p>

<ul>
	<li>For every hour when the shop is open and no customers come, the penalty increases by <code>1</code>.</li>
	<li>For every hour when the shop is closed and customers come, the penalty increases by <code>1</code>.</li>
</ul>

<p>Return<em> the <strong>earliest</strong> hour at which the shop must be closed to incur a <strong>minimum</strong> penalty.</em></p>

<p><strong>Note</strong> that if a shop closes at the <code>j<sup>th</sup></code> hour, it means the shop is closed at the hour <code>j</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> customers = &quot;YYNY&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
- Closing the shop at the 0<sup>th</sup> hour incurs in 1+1+0+1 = 3 penalty.
- Closing the shop at the 1<sup>st</sup> hour incurs in 0+1+0+1 = 2 penalty.
- Closing the shop at the 2<sup>nd</sup> hour incurs in 0+0+0+1 = 1 penalty.
- Closing the shop at the 3<sup>rd</sup> hour incurs in 0+0+1+1 = 2 penalty.
- Closing the shop at the 4<sup>th</sup> hour incurs in 0+0+1+0 = 1 penalty.
Closing the shop at 2<sup>nd</sup> or 4<sup>th</sup> hour gives a minimum penalty. Since 2 is earlier, the optimal closing time is 2.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> customers = &quot;NNNNN&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> It is best to close the shop at the 0<sup>th</sup> hour as no customers arrive.</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> customers = &quot;YYYY&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> It is best to close the shop at the 4<sup>th</sup> hour as customers arrive at each hour.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= customers.length &lt;= 10<sup>5</sup></code></li>
	<li><code>customers</code> consists only of characters <code>&#39;Y&#39;</code> and <code>&#39;N&#39;</code>.</li>
</ul>
",2.0,False,"class Solution {
public:
    int bestClosingTime(string customers) {
        
    }
};","class Solution {
    public int bestClosingTime(String customers) {
        
    }
}","class Solution(object):
    def bestClosingTime(self, customers):
        """"""
        :type customers: str
        :rtype: int
        """"""
        ","class Solution:
    def bestClosingTime(self, customers: str) -> int:
        ","int bestClosingTime(char * customers){

}","public class Solution {
    public int BestClosingTime(string customers) {
        
    }
}","/**
 * @param {string} customers
 * @return {number}
 */
var bestClosingTime = function(customers) {
    
};","# @param {String} customers
# @return {Integer}
def best_closing_time(customers)
    
end","class Solution {
    func bestClosingTime(_ customers: String) -> Int {
        
    }
}","func bestClosingTime(customers string) int {
    
}","object Solution {
    def bestClosingTime(customers: String): Int = {
        
    }
}","class Solution {
    fun bestClosingTime(customers: String): Int {
        
    }
}","impl Solution {
    pub fn best_closing_time(customers: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $customers
     * @return Integer
     */
    function bestClosingTime($customers) {
        
    }
}","function bestClosingTime(customers: string): number {

};","(define/contract (best-closing-time customers)
  (-> string? exact-integer?)

  )","-spec best_closing_time(Customers :: unicode:unicode_binary()) -> integer().
best_closing_time(Customers) ->
  .","defmodule Solution do
  @spec best_closing_time(customers :: String.t) :: integer
  def best_closing_time(customers) do

  end
end","class Solution {
  int bestClosingTime(String customers) {

  }
}",
minimum-cuts-to-divide-a-circle,Minimum Cuts to Divide a Circle,2481.0,2575.0,"<p>A <strong>valid cut</strong> in a circle can be:</p>

<ul>
	<li>A cut that is represented by a straight line that touches two points on the edge of the circle and passes through its center, or</li>
	<li>A cut that is represented by a straight line that touches one point on the edge of the circle and its center.</li>
</ul>

<p>Some valid and invalid cuts are shown in the figures below.</p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/29/alldrawio.png"" style=""width: 450px; height: 174px;"" />
<p>Given the integer <code>n</code>, return <em>the <strong>minimum</strong> number of cuts needed to divide a circle into </em><code>n</code><em> equal slices</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/24/11drawio.png"" style=""width: 200px; height: 200px;"" />
<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
The above figure shows how cutting the circle twice through the middle divides it into 4 equal slices.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/24/22drawio.png"" style=""width: 200px; height: 201px;"" />
<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong>
At least 3 cuts are needed to divide the circle into 3 equal slices. 
It can be shown that less than 3 cuts cannot result in 3 slices of equal size and shape.
Also note that the first cut will not divide the circle into distinct parts.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int numberOfCuts(int n) {
        
    }
};","class Solution {
    public int numberOfCuts(int n) {
        
    }
}","class Solution(object):
    def numberOfCuts(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def numberOfCuts(self, n: int) -> int:
        ","int numberOfCuts(int n){

}","public class Solution {
    public int NumberOfCuts(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var numberOfCuts = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def number_of_cuts(n)
    
end","class Solution {
    func numberOfCuts(_ n: Int) -> Int {
        
    }
}","func numberOfCuts(n int) int {
    
}","object Solution {
    def numberOfCuts(n: Int): Int = {
        
    }
}","class Solution {
    fun numberOfCuts(n: Int): Int {
        
    }
}","impl Solution {
    pub fn number_of_cuts(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function numberOfCuts($n) {
        
    }
}","function numberOfCuts(n: number): number {

};","(define/contract (number-of-cuts n)
  (-> exact-integer? exact-integer?)

  )","-spec number_of_cuts(N :: integer()) -> integer().
number_of_cuts(N) ->
  .","defmodule Solution do
  @spec number_of_cuts(n :: integer) :: integer
  def number_of_cuts(n) do

  end
end","class Solution {
  int numberOfCuts(int n) {

  }
}",
count-subarrays-with-median-k,Count Subarrays With Median K,2488.0,2574.0,"<p>You are given an array <code>nums</code> of size <code>n</code> consisting of <strong>distinct </strong>integers from <code>1</code> to <code>n</code> and a positive integer <code>k</code>.</p>

<p>Return <em>the number of non-empty subarrays in </em><code>nums</code><em> that have a <strong>median</strong> equal to </em><code>k</code>.</p>

<p><strong>Note</strong>:</p>

<ul>
	<li>The median of an array is the <strong>middle </strong>element after sorting the array in <strong>ascending </strong>order. If the array is of even length, the median is the <strong>left </strong>middle element.

	<ul>
		<li>For example, the median of <code>[2,3,1,4]</code> is <code>2</code>, and the median of <code>[8,4,3,5,1]</code> is <code>4</code>.</li>
	</ul>
	</li>
	<li>A subarray is a contiguous part of an array.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,1,4,5], k = 4
<strong>Output:</strong> 3
<strong>Explanation:</strong> The subarrays that have a median equal to 4 are: [4], [4,5] and [1,4,5].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,1], k = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> [3] is the only subarray that has a median equal to 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], k &lt;= n</code></li>
	<li>The integers in <code>nums</code> are distinct.</li>
</ul>
",3.0,False,"class Solution {
public:
    int countSubarrays(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int countSubarrays(int[] nums, int k) {
        
    }
}","class Solution(object):
    def countSubarrays(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        ","int countSubarrays(int* nums, int numsSize, int k){

}","public class Solution {
    public int CountSubarrays(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var countSubarrays = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def count_subarrays(nums, k)
    
end","class Solution {
    func countSubarrays(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func countSubarrays(nums []int, k int) int {
    
}","object Solution {
    def countSubarrays(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun countSubarrays(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn count_subarrays(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function countSubarrays($nums, $k) {
        
    }
}","function countSubarrays(nums: number[], k: number): number {

};","(define/contract (count-subarrays nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec count_subarrays(Nums :: [integer()], K :: integer()) -> integer().
count_subarrays(Nums, K) ->
  .","defmodule Solution do
  @spec count_subarrays(nums :: [integer], k :: integer) :: integer
  def count_subarrays(nums, k) do

  end
end","class Solution {
  int countSubarrays(List<int> nums, int k) {

  }
}",
remove-nodes-from-linked-list,Remove Nodes From Linked List,2487.0,2573.0,"<p>You are given the <code>head</code> of a linked list.</p>

<p>Remove every node which has a node with a <strong>strictly greater</strong> value anywhere to the right side of it.</p>

<p>Return <em>the </em><code>head</code><em> of the modified linked list.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/02/drawio.png"" style=""width: 631px; height: 51px;"" />
<pre>
<strong>Input:</strong> head = [5,2,13,3,8]
<strong>Output:</strong> [13,8]
<strong>Explanation:</strong> The nodes that should be removed are 5, 2 and 3.
- Node 13 is to the right of node 5.
- Node 13 is to the right of node 2.
- Node 8 is to the right of node 3.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [1,1,1,1]
<strong>Output:</strong> [1,1,1,1]
<strong>Explanation:</strong> Every node has value 1, so no nodes are removed.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of the nodes in the given list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
",2.0,False,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNodes(ListNode* head) {
        
    }
};","/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNodes(ListNode head) {
        
    }
}","# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def removeNodes(self, head):
        """"""
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """"""
        ","# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        ","/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* removeNodes(struct ListNode* head){

}","/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public int val;
 *     public ListNode next;
 *     public ListNode(int val=0, ListNode next=null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */
public class Solution {
    public ListNode RemoveNodes(ListNode head) {
        
    }
}","/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var removeNodes = function(head) {
    
};","# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @return {ListNode}
def remove_nodes(head)
    
end","/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public var val: Int
 *     public var next: ListNode?
 *     public init() { self.val = 0; self.next = nil; }
 *     public init(_ val: Int) { self.val = val; self.next = nil; }
 *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }
 * }
 */
class Solution {
    func removeNodes(_ head: ListNode?) -> ListNode? {
        
    }
}","/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNodes(head *ListNode) *ListNode {
    
}","/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def removeNodes(head: ListNode): ListNode = {
        
    }
}","/**
 * Example:
 * var li = ListNode(5)
 * var v = li.`val`
 * Definition for singly-linked list.
 * class ListNode(var `val`: Int) {
 *     var next: ListNode? = null
 * }
 */
class Solution {
    fun removeNodes(head: ListNode?): ListNode? {
        
    }
}","// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn remove_nodes(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        
    }
}","/**
 * Definition for a singly-linked list.
 * class ListNode {
 *     public $val = 0;
 *     public $next = null;
 *     function __construct($val = 0, $next = null) {
 *         $this->val = $val;
 *         $this->next = $next;
 *     }
 * }
 */
class Solution {

    /**
     * @param ListNode $head
     * @return ListNode
     */
    function removeNodes($head) {
        
    }
}","/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function removeNodes(head: ListNode | null): ListNode | null {

};","; Definition for singly-linked list:
#|

; val : integer?
; next : (or/c list-node? #f)
(struct list-node
  (val next) #:mutable #:transparent)

; constructor
(define (make-list-node [val 0])
  (list-node val #f))

|#

(define/contract (remove-nodes head)
  (-> (or/c list-node? #f) (or/c list-node? #f))

  )","%% Definition for singly-linked list.
%%
%% -record(list_node, {val = 0 :: integer(),
%%                     next = null :: 'null' | #list_node{}}).

-spec remove_nodes(Head :: #list_node{} | null) -> #list_node{} | null.
remove_nodes(Head) ->
  .","# Definition for singly-linked list.
#
# defmodule ListNode do
#   @type t :: %__MODULE__{
#           val: integer,
#           next: ListNode.t() | nil
#         }
#   defstruct val: 0, next: nil
# end

defmodule Solution do
  @spec remove_nodes(head :: ListNode.t | nil) :: ListNode.t | nil
  def remove_nodes(head) do

  end
end","/**
 * Definition for singly-linked list.
 * class ListNode {
 *   int val;
 *   ListNode? next;
 *   ListNode([this.val = 0, this.next]);
 * }
 */
class Solution {
  ListNode? removeNodes(ListNode? head) {

  }
}",
append-characters-to-string-to-make-subsequence,Append Characters to String to Make Subsequence,2486.0,2572.0,"<p>You are given two strings <code>s</code> and <code>t</code> consisting of only lowercase English letters.</p>

<p>Return <em>the minimum number of characters that need to be appended to the end of </em><code>s</code><em> so that </em><code>t</code><em> becomes a <strong>subsequence</strong> of </em><code>s</code>.</p>

<p>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;coaching&quot;, t = &quot;coding&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> Append the characters &quot;ding&quot; to the end of s so that s = &quot;coachingding&quot;.
Now, t is a subsequence of s (&quot;<u><strong>co</strong></u>aching<u><strong>ding</strong></u>&quot;).
It can be shown that appending any 3 characters to the end of s will never make t a subsequence.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcde&quot;, t = &quot;a&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> t is already a subsequence of s (&quot;<u><strong>a</strong></u>bcde&quot;).
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;z&quot;, t = &quot;abcde&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> Append the characters &quot;abcde&quot; to the end of s so that s = &quot;zabcde&quot;.
Now, t is a subsequence of s (&quot;z<u><strong>abcde</strong></u>&quot;).
It can be shown that appending any 4 characters to the end of s will never make t a subsequence.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> and <code>t</code> consist only of lowercase English letters.</li>
</ul>
",2.0,False,"class Solution {
public:
    int appendCharacters(string s, string t) {
        
    }
};","class Solution {
    public int appendCharacters(String s, String t) {
        
    }
}","class Solution(object):
    def appendCharacters(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: int
        """"""
        ","class Solution:
    def appendCharacters(self, s: str, t: str) -> int:
        ","int appendCharacters(char * s, char * t){

}","public class Solution {
    public int AppendCharacters(string s, string t) {
        
    }
}","/**
 * @param {string} s
 * @param {string} t
 * @return {number}
 */
var appendCharacters = function(s, t) {
    
};","# @param {String} s
# @param {String} t
# @return {Integer}
def append_characters(s, t)
    
end","class Solution {
    func appendCharacters(_ s: String, _ t: String) -> Int {
        
    }
}","func appendCharacters(s string, t string) int {
    
}","object Solution {
    def appendCharacters(s: String, t: String): Int = {
        
    }
}","class Solution {
    fun appendCharacters(s: String, t: String): Int {
        
    }
}","impl Solution {
    pub fn append_characters(s: String, t: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param String $t
     * @return Integer
     */
    function appendCharacters($s, $t) {
        
    }
}","function appendCharacters(s: string, t: string): number {

};","(define/contract (append-characters s t)
  (-> string? string? exact-integer?)

  )","-spec append_characters(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> integer().
append_characters(S, T) ->
  .","defmodule Solution do
  @spec append_characters(s :: String.t, t :: String.t) :: integer
  def append_characters(s, t) do

  end
end","class Solution {
  int appendCharacters(String s, String t) {

  }
}",
find-the-pivot-integer,Find the Pivot Integer,2485.0,2571.0,"<p>Given a positive integer <code>n</code>, find the <strong>pivot integer</strong> <code>x</code> such that:</p>

<ul>
	<li>The sum of all elements between <code>1</code> and <code>x</code> inclusively equals the sum of all elements between <code>x</code> and <code>n</code> inclusively.</li>
</ul>

<p>Return <em>the pivot integer </em><code>x</code>. If no such integer exists, return <code>-1</code>. It is guaranteed that there will be at most one pivot index for the given input.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 8
<strong>Output:</strong> 6
<strong>Explanation:</strong> 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> 1 is the pivot integer since: 1 = 1.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be proved that no such integer exist.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int pivotInteger(int n) {
        
    }
};","class Solution {
    public int pivotInteger(int n) {
        
    }
}","class Solution(object):
    def pivotInteger(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def pivotInteger(self, n: int) -> int:
        ","int pivotInteger(int n){

}","public class Solution {
    public int PivotInteger(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var pivotInteger = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def pivot_integer(n)
    
end","class Solution {
    func pivotInteger(_ n: Int) -> Int {
        
    }
}","func pivotInteger(n int) int {
    
}","object Solution {
    def pivotInteger(n: Int): Int = {
        
    }
}","class Solution {
    fun pivotInteger(n: Int): Int {
        
    }
}","impl Solution {
    pub fn pivot_integer(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function pivotInteger($n) {
        
    }
}","function pivotInteger(n: number): number {

};","(define/contract (pivot-integer n)
  (-> exact-integer? exact-integer?)

  )","-spec pivot_integer(N :: integer()) -> integer().
pivot_integer(N) ->
  .","defmodule Solution do
  @spec pivot_integer(n :: integer) :: integer
  def pivot_integer(n) do

  end
end","class Solution {
  int pivotInteger(int n) {

  }
}",
number-of-beautiful-partitions,Number of Beautiful Partitions,2478.0,2569.0,"<p>You are given a string <code>s</code> that consists of the digits <code>&#39;1&#39;</code> to <code>&#39;9&#39;</code> and two integers <code>k</code> and <code>minLength</code>.</p>

<p>A partition of <code>s</code> is called <strong>beautiful</strong> if:</p>

<ul>
	<li><code>s</code> is partitioned into <code>k</code> non-intersecting substrings.</li>
	<li>Each substring has a length of <strong>at least</strong> <code>minLength</code>.</li>
	<li>Each substring starts with a <strong>prime</strong> digit and ends with a <strong>non-prime</strong> digit. Prime digits are <code>&#39;2&#39;</code>, <code>&#39;3&#39;</code>, <code>&#39;5&#39;</code>, and <code>&#39;7&#39;</code>, and the rest of the digits are non-prime.</li>
</ul>

<p>Return<em> the number of <strong>beautiful</strong> partitions of </em><code>s</code>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>A <strong>substring</strong> is a contiguous sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;23542185131&quot;, k = 3, minLength = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong> There exists three ways to create a beautiful partition:
&quot;2354 | 218 | 5131&quot;
&quot;2354 | 21851 | 31&quot;
&quot;2354218 | 51 | 31&quot;
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;23542185131&quot;, k = 3, minLength = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> There exists one way to create a beautiful partition: &quot;2354 | 218 | 5131&quot;.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;3312958&quot;, k = 3, minLength = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> There exists one way to create a beautiful partition: &quot;331 | 29 | 58&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k, minLength &lt;= s.length &lt;= 1000</code></li>
	<li><code>s</code> consists of the digits <code>&#39;1&#39;</code> to <code>&#39;9&#39;</code>.</li>
</ul>
",3.0,False,"class Solution {
public:
    int beautifulPartitions(string s, int k, int minLength) {
        
    }
};","class Solution {
    public int beautifulPartitions(String s, int k, int minLength) {
        
    }
}","class Solution(object):
    def beautifulPartitions(self, s, k, minLength):
        """"""
        :type s: str
        :type k: int
        :type minLength: int
        :rtype: int
        """"""
        ","class Solution:
    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:
        ","int beautifulPartitions(char * s, int k, int minLength){

}","public class Solution {
    public int BeautifulPartitions(string s, int k, int minLength) {
        
    }
}","/**
 * @param {string} s
 * @param {number} k
 * @param {number} minLength
 * @return {number}
 */
var beautifulPartitions = function(s, k, minLength) {
    
};","# @param {String} s
# @param {Integer} k
# @param {Integer} min_length
# @return {Integer}
def beautiful_partitions(s, k, min_length)
    
end","class Solution {
    func beautifulPartitions(_ s: String, _ k: Int, _ minLength: Int) -> Int {
        
    }
}","func beautifulPartitions(s string, k int, minLength int) int {
    
}","object Solution {
    def beautifulPartitions(s: String, k: Int, minLength: Int): Int = {
        
    }
}","class Solution {
    fun beautifulPartitions(s: String, k: Int, minLength: Int): Int {
        
    }
}","impl Solution {
    pub fn beautiful_partitions(s: String, k: i32, min_length: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param Integer $k
     * @param Integer $minLength
     * @return Integer
     */
    function beautifulPartitions($s, $k, $minLength) {
        
    }
}","function beautifulPartitions(s: string, k: number, minLength: number): number {

};","(define/contract (beautiful-partitions s k minLength)
  (-> string? exact-integer? exact-integer? exact-integer?)

  )","-spec beautiful_partitions(S :: unicode:unicode_binary(), K :: integer(), MinLength :: integer()) -> integer().
beautiful_partitions(S, K, MinLength) ->
  .","defmodule Solution do
  @spec beautiful_partitions(s :: String.t, k :: integer, min_length :: integer) :: integer
  def beautiful_partitions(s, k, min_length) do

  end
end","class Solution {
  int beautifulPartitions(String s, int k, int minLength) {

  }
}",
minimum-fuel-cost-to-report-to-the-capital,Minimum Fuel Cost to Report to the Capital,2477.0,2568.0,"<p>There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code> and exactly <code>n - 1</code> roads. The capital city is city <code>0</code>. You are given a 2D integer array <code>roads</code> where <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists a <strong>bidirectional road</strong> connecting cities <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>There is a meeting for the representatives of each city. The meeting is in the capital city.</p>

<p>There is a car in each city. You are given an integer <code>seats</code> that indicates the number of seats in each car.</p>

<p>A representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.</p>

<p>Return <em>the minimum number of liters of fuel to reach the capital city</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/09/22/a4c380025e3ff0c379525e96a7d63a3.png"" style=""width: 303px; height: 332px;"" />
<pre>
<strong>Input:</strong> roads = [[0,1],[0,2],[0,3]], seats = 5
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
- Representative<sub>1</sub> goes directly to the capital with 1 liter of fuel.
- Representative<sub>2</sub> goes directly to the capital with 1 liter of fuel.
- Representative<sub>3</sub> goes directly to the capital with 1 liter of fuel.
It costs 3 liters of fuel at minimum. 
It can be proven that 3 is the minimum number of liters of fuel needed.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/11/16/2.png"" style=""width: 274px; height: 340px;"" />
<pre>
<strong>Input:</strong> roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2
<strong>Output:</strong> 7
<strong>Explanation:</strong> 
- Representative<sub>2</sub> goes directly to city 3 with 1 liter of fuel.
- Representative<sub>2</sub> and representative<sub>3</sub> go together to city 1 with 1 liter of fuel.
- Representative<sub>2</sub> and representative<sub>3</sub> go together to the capital with 1 liter of fuel.
- Representative<sub>1</sub> goes directly to the capital with 1 liter of fuel.
- Representative<sub>5</sub> goes directly to the capital with 1 liter of fuel.
- Representative<sub>6</sub> goes directly to city 4 with 1 liter of fuel.
- Representative<sub>4</sub> and representative<sub>6</sub> go together to the capital with 1 liter of fuel.
It costs 7 liters of fuel at minimum. 
It can be proven that 7 is the minimum number of liters of fuel needed.
</pre>

<p><strong class=""example"">Example 3:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/09/27/efcf7f7be6830b8763639cfd01b690a.png"" style=""width: 108px; height: 86px;"" />
<pre>
<strong>Input:</strong> roads = [], seats = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> No representatives need to travel to the capital city.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>roads.length == n - 1</code></li>
	<li><code>roads[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>roads</code> represents a valid tree.</li>
	<li><code>1 &lt;= seats &lt;= 10<sup>5</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {
        
    }
};","class Solution {
    public long minimumFuelCost(int[][] roads, int seats) {
        
    }
}","class Solution(object):
    def minimumFuelCost(self, roads, seats):
        """"""
        :type roads: List[List[int]]
        :type seats: int
        :rtype: int
        """"""
        ","class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        ","long long minimumFuelCost(int** roads, int roadsSize, int* roadsColSize, int seats){

}","public class Solution {
    public long MinimumFuelCost(int[][] roads, int seats) {
        
    }
}","/**
 * @param {number[][]} roads
 * @param {number} seats
 * @return {number}
 */
var minimumFuelCost = function(roads, seats) {
    
};","# @param {Integer[][]} roads
# @param {Integer} seats
# @return {Integer}
def minimum_fuel_cost(roads, seats)
    
end","class Solution {
    func minimumFuelCost(_ roads: [[Int]], _ seats: Int) -> Int {
        
    }
}","func minimumFuelCost(roads [][]int, seats int) int64 {
    
}","object Solution {
    def minimumFuelCost(roads: Array[Array[Int]], seats: Int): Long = {
        
    }
}","class Solution {
    fun minimumFuelCost(roads: Array<IntArray>, seats: Int): Long {
        
    }
}","impl Solution {
    pub fn minimum_fuel_cost(roads: Vec<Vec<i32>>, seats: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $roads
     * @param Integer $seats
     * @return Integer
     */
    function minimumFuelCost($roads, $seats) {
        
    }
}","function minimumFuelCost(roads: number[][], seats: number): number {

};","(define/contract (minimum-fuel-cost roads seats)
  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)

  )","-spec minimum_fuel_cost(Roads :: [[integer()]], Seats :: integer()) -> integer().
minimum_fuel_cost(Roads, Seats) ->
  .","defmodule Solution do
  @spec minimum_fuel_cost(roads :: [[integer]], seats :: integer) :: integer
  def minimum_fuel_cost(roads, seats) do

  end
end","class Solution {
  int minimumFuelCost(List<List<int>> roads, int seats) {

  }
}",
closest-nodes-queries-in-a-binary-search-tree,Closest Nodes Queries in a Binary Search Tree,2476.0,2567.0,"<p>You are given the <code>root</code> of a <strong>binary search tree </strong>and an array <code>queries</code> of size <code>n</code> consisting of positive integers.</p>

<p>Find a <strong>2D</strong> array <code>answer</code> of size <code>n</code> where <code>answer[i] = [min<sub>i</sub>, max<sub>i</sub>]</code>:</p>

<ul>
	<li><code>min<sub>i</sub></code> is the <strong>largest</strong> value in the tree that is smaller than or equal to <code>queries[i]</code>. If a such value does not exist, add <code>-1</code> instead.</li>
	<li><code>max<sub>i</sub></code> is the <strong>smallest</strong> value in the tree that is greater than or equal to <code>queries[i]</code>. If a such value does not exist, add <code>-1</code> instead.</li>
</ul>

<p>Return <em>the array</em> <code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/09/28/bstreeedrawioo.png"" style=""width: 261px; height: 281px;"" />
<pre>
<strong>Input:</strong> root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]
<strong>Output:</strong> [[2,2],[4,6],[15,-1]]
<strong>Explanation:</strong> We answer the queries in the following way:
- The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].
- The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].
- The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/09/28/bstttreee.png"" style=""width: 101px; height: 121px;"" />
<pre>
<strong>Input:</strong> root = [4,null,9], queries = [3]
<strong>Output:</strong> [[-1,4]]
<strong>Explanation:</strong> The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
	<li><code>n == queries.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries[i] &lt;= 10<sup>6</sup></code></li>
</ul>
",2.0,False,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        
    }
};","/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {
        
    }
}","# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def closestNodes(self, root, queries):
        """"""
        :type root: Optional[TreeNode]
        :type queries: List[int]
        :rtype: List[List[int]]
        """"""
        ","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:
        ","/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** closestNodes(struct TreeNode* root, int* queries, int queriesSize, int* returnSize, int** returnColumnSizes){

}","/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public IList<IList<int>> ClosestNodes(TreeNode root, IList<int> queries) {
        
    }
}","/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number[]} queries
 * @return {number[][]}
 */
var closestNodes = function(root, queries) {
    
};","# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @param {Integer[]} queries
# @return {Integer[][]}
def closest_nodes(root, queries)
    
end","/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func closestNodes(_ root: TreeNode?, _ queries: [Int]) -> [[Int]] {
        
    }
}","/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func closestNodes(root *TreeNode, queries []int) [][]int {
    
}","/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    def closestNodes(root: TreeNode, queries: List[Int]): List[List[Int]] = {
        
    }
}","/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */
class Solution {
    fun closestNodes(root: TreeNode?, queries: List<Int>): List<List<Int>> {
        
    }
}","// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn closest_nodes(root: Option<Rc<RefCell<TreeNode>>>, queries: Vec<i32>) -> Vec<Vec<i32>> {
        
    }
}","/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     public $val = null;
 *     public $left = null;
 *     public $right = null;
 *     function __construct($val = 0, $left = null, $right = null) {
 *         $this->val = $val;
 *         $this->left = $left;
 *         $this->right = $right;
 *     }
 * }
 */
class Solution {

    /**
     * @param TreeNode $root
     * @param Integer[] $queries
     * @return Integer[][]
     */
    function closestNodes($root, $queries) {
        
    }
}","/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function closestNodes(root: TreeNode | null, queries: number[]): number[][] {

};","; Definition for a binary tree node.
#|

; val : integer?
; left : (or/c tree-node? #f)
; right : (or/c tree-node? #f)
(struct tree-node
  (val left right) #:mutable #:transparent)

; constructor
(define (make-tree-node [val 0])
  (tree-node val #f #f))

|#

(define/contract (closest-nodes root queries)
  (-> (or/c tree-node? #f) (listof exact-integer?) (listof (listof exact-integer?)))

  )","%% Definition for a binary tree node.
%%
%% -record(tree_node, {val = 0 :: integer(),
%%                     left = null  :: 'null' | #tree_node{},
%%                     right = null :: 'null' | #tree_node{}}).

-spec closest_nodes(Root :: #tree_node{} | null, Queries :: [integer()]) -> [[integer()]].
closest_nodes(Root, Queries) ->
  .","# Definition for a binary tree node.
#
# defmodule TreeNode do
#   @type t :: %__MODULE__{
#           val: integer,
#           left: TreeNode.t() | nil,
#           right: TreeNode.t() | nil
#         }
#   defstruct val: 0, left: nil, right: nil
# end

defmodule Solution do
  @spec closest_nodes(root :: TreeNode.t | nil, queries :: [integer]) :: [[integer]]
  def closest_nodes(root, queries) do

  end
end","/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   int val;
 *   TreeNode? left;
 *   TreeNode? right;
 *   TreeNode([this.val = 0, this.left, this.right]);
 * }
 */
class Solution {
  List<List<int>> closestNodes(TreeNode? root, List<int> queries) {

  }
}",
number-of-unequal-triplets-in-array,Number of Unequal Triplets in Array,2475.0,2566.0,"<p>You are given a <strong>0-indexed</strong> array of positive integers <code>nums</code>. Find the number of triplets <code>(i, j, k)</code> that meet the following conditions:</p>

<ul>
	<li><code>0 &lt;= i &lt; j &lt; k &lt; nums.length</code></li>
	<li><code>nums[i]</code>, <code>nums[j]</code>, and <code>nums[k]</code> are <strong>pairwise distinct</strong>.
	<ul>
		<li>In other words, <code>nums[i] != nums[j]</code>, <code>nums[i] != nums[k]</code>, and <code>nums[j] != nums[k]</code>.</li>
	</ul>
	</li>
</ul>

<p>Return <em>the number of triplets that meet the conditions.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,4,2,4,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The following triplets meet the conditions:
- (0, 2, 4) because 4 != 2 != 3
- (1, 2, 4) because 4 != 2 != 3
- (2, 3, 4) because 2 != 4 != 3
Since there are 3 triplets, we return 3.
Note that (2, 0, 4) is not a valid triplet because 2 &gt; 0.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,1,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> No triplets meet the conditions so we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int unequalTriplets(vector<int>& nums) {
        
    }
};","class Solution {
    public int unequalTriplets(int[] nums) {
        
    }
}","class Solution(object):
    def unequalTriplets(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        ","int unequalTriplets(int* nums, int numsSize){

}","public class Solution {
    public int UnequalTriplets(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var unequalTriplets = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def unequal_triplets(nums)
    
end","class Solution {
    func unequalTriplets(_ nums: [Int]) -> Int {
        
    }
}","func unequalTriplets(nums []int) int {
    
}","object Solution {
    def unequalTriplets(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun unequalTriplets(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn unequal_triplets(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function unequalTriplets($nums) {
        
    }
}","function unequalTriplets(nums: number[]): number {

};","(define/contract (unequal-triplets nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec unequal_triplets(Nums :: [integer()]) -> integer().
unequal_triplets(Nums) ->
  .","defmodule Solution do
  @spec unequal_triplets(nums :: [integer]) :: integer
  def unequal_triplets(nums) do

  end
end","class Solution {
  int unequalTriplets(List<int> nums) {

  }
}",
most-profitable-path-in-a-tree,Most Profitable Path in a Tree,2467.0,2564.0,"<p>There is an undirected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, rooted at node <code>0</code>. You are given a 2D integer array <code>edges</code> of length <code>n - 1</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>

<p>At every node <code>i</code>, there is a gate. You are also given an array of even integers <code>amount</code>, where <code>amount[i]</code> represents:</p>

<ul>
	<li>the price needed to open the gate at node <code>i</code>, if <code>amount[i]</code> is negative, or,</li>
	<li>the cash reward obtained on opening the gate at node <code>i</code>, otherwise.</li>
</ul>

<p>The game goes on as follows:</p>

<ul>
	<li>Initially, Alice is at node <code>0</code> and Bob is at node <code>bob</code>.</li>
	<li>At every second, Alice and Bob <b>each</b> move to an adjacent node. Alice moves towards some <strong>leaf node</strong>, while Bob moves towards node <code>0</code>.</li>
	<li>For <strong>every</strong> node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:
	<ul>
		<li>If the gate is <strong>already open</strong>, no price will be required, nor will there be any cash reward.</li>
		<li>If Alice and Bob reach the node <strong>simultaneously</strong>, they share the price/reward for opening the gate there. In other words, if the price to open the gate is <code>c</code>, then both Alice and Bob pay&nbsp;<code>c / 2</code> each. Similarly, if the reward at the gate is <code>c</code>, both of them receive <code>c / 2</code> each.</li>
	</ul>
	</li>
	<li>If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node <code>0</code>, he stops moving. Note that these events are <strong>independent</strong> of each other.</li>
</ul>

<p>Return<em> the <strong>maximum</strong> net income Alice can have if she travels towards the optimal leaf node.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/29/eg1.png"" style=""width: 275px; height: 275px;"" />
<pre>
<strong>Input:</strong> edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]
<strong>Output:</strong> 6
<strong>Explanation:</strong> 
The above diagram represents the given tree. The game goes as follows:
- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.
  Alice&#39;s net income is now -2.
- Both Alice and Bob move to node 1. 
&nbsp; Since they reach here simultaneously, they open the gate together and share the reward.
&nbsp; Alice&#39;s net income becomes -2 + (4 / 2) = 0.
- Alice moves on to node 3. Since Bob already opened its gate, Alice&#39;s income remains unchanged.
&nbsp; Bob moves on to node 0, and stops moving.
- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.
Now, neither Alice nor Bob can make any further moves, and the game ends.
It is not possible for Alice to get a higher net income.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/10/29/eg2.png"" style=""width: 250px; height: 78px;"" />
<pre>
<strong>Input:</strong> edges = [[0,1]], bob = 1, amount = [-7280,2350]
<strong>Output:</strong> -7280
<strong>Explanation:</strong> 
Alice follows the path 0-&gt;1 whereas Bob follows the path 1-&gt;0.
Thus, Alice opens the gate at node 0 only. Hence, her net income is -7280. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
	<li><code>1 &lt;= bob &lt; n</code></li>
	<li><code>amount.length == n</code></li>
	<li><code>amount[i]</code> is an <strong>even</strong> integer in the range <code>[-10<sup>4</sup>, 10<sup>4</sup>]</code>.</li>
</ul>
",2.0,False,"class Solution {
public:
    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {
        
    }
};","class Solution {
    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {
        
    }
}","class Solution(object):
    def mostProfitablePath(self, edges, bob, amount):
        """"""
        :type edges: List[List[int]]
        :type bob: int
        :type amount: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        ","int mostProfitablePath(int** edges, int edgesSize, int* edgesColSize, int bob, int* amount, int amountSize){

}","public class Solution {
    public int MostProfitablePath(int[][] edges, int bob, int[] amount) {
        
    }
}","/**
 * @param {number[][]} edges
 * @param {number} bob
 * @param {number[]} amount
 * @return {number}
 */
var mostProfitablePath = function(edges, bob, amount) {
    
};","# @param {Integer[][]} edges
# @param {Integer} bob
# @param {Integer[]} amount
# @return {Integer}
def most_profitable_path(edges, bob, amount)
    
end","class Solution {
    func mostProfitablePath(_ edges: [[Int]], _ bob: Int, _ amount: [Int]) -> Int {
        
    }
}","func mostProfitablePath(edges [][]int, bob int, amount []int) int {
    
}","object Solution {
    def mostProfitablePath(edges: Array[Array[Int]], bob: Int, amount: Array[Int]): Int = {
        
    }
}","class Solution {
    fun mostProfitablePath(edges: Array<IntArray>, bob: Int, amount: IntArray): Int {
        
    }
}","impl Solution {
    pub fn most_profitable_path(edges: Vec<Vec<i32>>, bob: i32, amount: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $edges
     * @param Integer $bob
     * @param Integer[] $amount
     * @return Integer
     */
    function mostProfitablePath($edges, $bob, $amount) {
        
    }
}","function mostProfitablePath(edges: number[][], bob: number, amount: number[]): number {

};","(define/contract (most-profitable-path edges bob amount)
  (-> (listof (listof exact-integer?)) exact-integer? (listof exact-integer?) exact-integer?)

  )","-spec most_profitable_path(Edges :: [[integer()]], Bob :: integer(), Amount :: [integer()]) -> integer().
most_profitable_path(Edges, Bob, Amount) ->
  .","defmodule Solution do
  @spec most_profitable_path(edges :: [[integer]], bob :: integer, amount :: [integer]) :: integer
  def most_profitable_path(edges, bob, amount) do

  end
end","class Solution {
  int mostProfitablePath(List<List<int>> edges, int bob, List<int> amount) {

  }
}",
split-message-based-on-limit,Split Message Based on Limit,2468.0,2563.0,"<p>You are given a string, <code>message</code>, and a positive integer, <code>limit</code>.</p>

<p>You must <strong>split</strong> <code>message</code> into one or more <strong>parts</strong> based on <code>limit</code>. Each resulting part should have the suffix <code>&quot;&lt;a/b&gt;&quot;</code>, where <code>&quot;b&quot;</code> is to be <strong>replaced</strong> with the total number of parts and <code>&quot;a&quot;</code> is to be <strong>replaced</strong> with the index of the part, starting from <code>1</code> and going up to <code>b</code>. Additionally, the length of each resulting part (including its suffix) should be <strong>equal</strong> to <code>limit</code>, except for the last part whose length can be <strong>at most</strong> <code>limit</code>.</p>

<p>The resulting parts should be formed such that when their suffixes are removed and they are all concatenated <strong>in order</strong>, they should be equal to <code>message</code>. Also, the result should contain as few parts as possible.</p>

<p>Return<em> the parts </em><code>message</code><em> would be split into as an array of strings</em>. If it is impossible to split <code>message</code> as required, return<em> an empty array</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> message = &quot;this is really a very awesome message&quot;, limit = 9
<strong>Output:</strong> [&quot;thi&lt;1/14&gt;&quot;,&quot;s i&lt;2/14&gt;&quot;,&quot;s r&lt;3/14&gt;&quot;,&quot;eal&lt;4/14&gt;&quot;,&quot;ly &lt;5/14&gt;&quot;,&quot;a v&lt;6/14&gt;&quot;,&quot;ery&lt;7/14&gt;&quot;,&quot; aw&lt;8/14&gt;&quot;,&quot;eso&lt;9/14&gt;&quot;,&quot;me&lt;10/14&gt;&quot;,&quot; m&lt;11/14&gt;&quot;,&quot;es&lt;12/14&gt;&quot;,&quot;sa&lt;13/14&gt;&quot;,&quot;ge&lt;14/14&gt;&quot;]
<strong>Explanation:</strong>
The first 9 parts take 3 characters each from the beginning of message.
The next 5 parts take 2 characters each to finish splitting message. 
In this example, each part, including the last, has length 9. 
It can be shown it is not possible to split message into less than 14 parts.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> message = &quot;short message&quot;, limit = 15
<strong>Output:</strong> [&quot;short mess&lt;1/2&gt;&quot;,&quot;age&lt;2/2&gt;&quot;]
<strong>Explanation:</strong>
Under the given constraints, the string can be split into two parts: 
- The first part comprises of the first 10 characters, and has a length 15.
- The next part comprises of the last 3 characters, and has a length 8.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= message.length &lt;= 10<sup>4</sup></code></li>
	<li><code>message</code> consists only of lowercase English letters and <code>&#39; &#39;</code>.</li>
	<li><code>1 &lt;= limit &lt;= 10<sup>4</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    vector<string> splitMessage(string message, int limit) {
        
    }
};","class Solution {
    public String[] splitMessage(String message, int limit) {
        
    }
}","class Solution(object):
    def splitMessage(self, message, limit):
        """"""
        :type message: str
        :type limit: int
        :rtype: List[str]
        """"""
        ","class Solution:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** splitMessage(char * message, int limit, int* returnSize){

}","public class Solution {
    public string[] SplitMessage(string message, int limit) {
        
    }
}","/**
 * @param {string} message
 * @param {number} limit
 * @return {string[]}
 */
var splitMessage = function(message, limit) {
    
};","# @param {String} message
# @param {Integer} limit
# @return {String[]}
def split_message(message, limit)
    
end","class Solution {
    func splitMessage(_ message: String, _ limit: Int) -> [String] {
        
    }
}","func splitMessage(message string, limit int) []string {
    
}","object Solution {
    def splitMessage(message: String, limit: Int): Array[String] = {
        
    }
}","class Solution {
    fun splitMessage(message: String, limit: Int): Array<String> {
        
    }
}","impl Solution {
    pub fn split_message(message: String, limit: i32) -> Vec<String> {
        
    }
}","class Solution {

    /**
     * @param String $message
     * @param Integer $limit
     * @return String[]
     */
    function splitMessage($message, $limit) {
        
    }
}","function splitMessage(message: string, limit: number): string[] {

};","(define/contract (split-message message limit)
  (-> string? exact-integer? (listof string?))

  )","-spec split_message(Message :: unicode:unicode_binary(), Limit :: integer()) -> [unicode:unicode_binary()].
split_message(Message, Limit) ->
  .","defmodule Solution do
  @spec split_message(message :: String.t, limit :: integer) :: [String.t]
  def split_message(message, limit) do

  end
end","class Solution {
  List<String> splitMessage(String message, int limit) {

  }
}",
count-ways-to-build-good-strings,Count Ways To Build Good Strings,2466.0,2562.0,"<p>Given the integers <code>zero</code>, <code>one</code>, <code>low</code>, and <code>high</code>, we can construct a string by starting with an empty string, and then at each step perform either of the following:</p>

<ul>
	<li>Append the character <code>&#39;0&#39;</code> <code>zero</code> times.</li>
	<li>Append the character <code>&#39;1&#39;</code> <code>one</code> times.</li>
</ul>

<p>This can be performed any number of times.</p>

<p>A <strong>good</strong> string is a string constructed by the above process having a <strong>length</strong> between <code>low</code> and <code>high</code> (<strong>inclusive</strong>).</p>

<p>Return <em>the number of <strong>different</strong> good strings that can be constructed satisfying these properties.</em> Since the answer can be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> low = 3, high = 3, zero = 1, one = 1
<strong>Output:</strong> 8
<strong>Explanation:</strong> 
One possible valid good string is &quot;011&quot;. 
It can be constructed as follows: &quot;&quot; -&gt; &quot;0&quot; -&gt; &quot;01&quot; -&gt; &quot;011&quot;. 
All binary strings from &quot;000&quot; to &quot;111&quot; are good strings in this example.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> low = 2, high = 3, zero = 1, one = 2
<strong>Output:</strong> 5
<strong>Explanation:</strong> The good strings are &quot;00&quot;, &quot;11&quot;, &quot;000&quot;, &quot;110&quot;, and &quot;011&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= low&nbsp;&lt;= high&nbsp;&lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= zero, one &lt;= low</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int countGoodStrings(int low, int high, int zero, int one) {
        
    }
};","class Solution {
    public int countGoodStrings(int low, int high, int zero, int one) {
        
    }
}","class Solution(object):
    def countGoodStrings(self, low, high, zero, one):
        """"""
        :type low: int
        :type high: int
        :type zero: int
        :type one: int
        :rtype: int
        """"""
        ","class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        ","int countGoodStrings(int low, int high, int zero, int one){

}","public class Solution {
    public int CountGoodStrings(int low, int high, int zero, int one) {
        
    }
}","/**
 * @param {number} low
 * @param {number} high
 * @param {number} zero
 * @param {number} one
 * @return {number}
 */
var countGoodStrings = function(low, high, zero, one) {
    
};","# @param {Integer} low
# @param {Integer} high
# @param {Integer} zero
# @param {Integer} one
# @return {Integer}
def count_good_strings(low, high, zero, one)
    
end","class Solution {
    func countGoodStrings(_ low: Int, _ high: Int, _ zero: Int, _ one: Int) -> Int {
        
    }
}","func countGoodStrings(low int, high int, zero int, one int) int {
    
}","object Solution {
    def countGoodStrings(low: Int, high: Int, zero: Int, one: Int): Int = {
        
    }
}","class Solution {
    fun countGoodStrings(low: Int, high: Int, zero: Int, one: Int): Int {
        
    }
}","impl Solution {
    pub fn count_good_strings(low: i32, high: i32, zero: i32, one: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $low
     * @param Integer $high
     * @param Integer $zero
     * @param Integer $one
     * @return Integer
     */
    function countGoodStrings($low, $high, $zero, $one) {
        
    }
}","function countGoodStrings(low: number, high: number, zero: number, one: number): number {

};","(define/contract (count-good-strings low high zero one)
  (-> exact-integer? exact-integer? exact-integer? exact-integer? exact-integer?)

  )","-spec count_good_strings(Low :: integer(), High :: integer(), Zero :: integer(), One :: integer()) -> integer().
count_good_strings(Low, High, Zero, One) ->
  .","defmodule Solution do
  @spec count_good_strings(low :: integer, high :: integer, zero :: integer, one :: integer) :: integer
  def count_good_strings(low, high, zero, one) do

  end
end","class Solution {
  int countGoodStrings(int low, int high, int zero, int one) {

  }
}",
number-of-distinct-averages,Number of Distinct Averages,2465.0,2561.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of <strong>even</strong> length.</p>

<p>As long as <code>nums</code> is <strong>not</strong> empty, you must repetitively:</p>

<ul>
	<li>Find the minimum number in <code>nums</code> and remove it.</li>
	<li>Find the maximum number in <code>nums</code> and remove it.</li>
	<li>Calculate the average of the two removed numbers.</li>
</ul>

<p>The <strong>average</strong> of two numbers <code>a</code> and <code>b</code> is <code>(a + b) / 2</code>.</p>

<ul>
	<li>For example, the average of <code>2</code> and <code>3</code> is <code>(2 + 3) / 2 = 2.5</code>.</li>
</ul>

<p>Return<em> the number of <strong>distinct</strong> averages calculated using the above process</em>.</p>

<p><strong>Note</strong> that when there is a tie for a minimum or maximum number, any can be removed.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,1,4,0,3,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong>
1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, nums = [4,1,4,3].
2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and nums = [4,3].
3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.
Since there are 2 distinct numbers among 2.5, 2.5, and 3.5, we return 2.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,100]
<strong>Output:</strong> 1
<strong>Explanation:</strong>
There is only one average to be calculated after removing 1 and 100, so we return 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 100</code></li>
	<li><code>nums.length</code> is even.</li>
	<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
",1.0,False,"class Solution {
public:
    int distinctAverages(vector<int>& nums) {
        
    }
};","class Solution {
    public int distinctAverages(int[] nums) {
        
    }
}","class Solution(object):
    def distinctAverages(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def distinctAverages(self, nums: List[int]) -> int:
        ","int distinctAverages(int* nums, int numsSize){

}","public class Solution {
    public int DistinctAverages(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var distinctAverages = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def distinct_averages(nums)
    
end","class Solution {
    func distinctAverages(_ nums: [Int]) -> Int {
        
    }
}","func distinctAverages(nums []int) int {
    
}","object Solution {
    def distinctAverages(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun distinctAverages(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn distinct_averages(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function distinctAverages($nums) {
        
    }
}","function distinctAverages(nums: number[]): number {

};","(define/contract (distinct-averages nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec distinct_averages(Nums :: [integer()]) -> integer().
distinct_averages(Nums) ->
  .","defmodule Solution do
  @spec distinct_averages(nums :: [integer]) :: integer
  def distinct_averages(nums) do

  end
end","class Solution {
  int distinctAverages(List<int> nums) {

  }
}",
maximum-number-of-non-overlapping-palindrome-substrings,Maximum Number of Non-overlapping Palindrome Substrings,2472.0,2559.0,"<p>You are given a string <code>s</code> and a <strong>positive</strong> integer <code>k</code>.</p>

<p>Select a set of <strong>non-overlapping</strong> substrings from the string <code>s</code> that satisfy the following conditions:</p>

<ul>
	<li>The <strong>length</strong> of each substring is <strong>at least</strong> <code>k</code>.</li>
	<li>Each substring is a <strong>palindrome</strong>.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of substrings in an optimal selection</em>.</p>

<p>A <strong>substring</strong> is a contiguous sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abaccdbbd&quot;, k = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can select the substrings underlined in s = &quot;<u><strong>aba</strong></u>cc<u><strong>dbbd</strong></u>&quot;. Both &quot;aba&quot; and &quot;dbbd&quot; are palindromes and have a length of at least k = 3.
It can be shown that we cannot find a selection with more than two valid substrings.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;adbcda&quot;, k = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no palindrome substring of length at least 2 in the string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= s.length &lt;= 2000</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
",3.0,False,"class Solution {
public:
    int maxPalindromes(string s, int k) {
        
    }
};","class Solution {
    public int maxPalindromes(String s, int k) {
        
    }
}","class Solution(object):
    def maxPalindromes(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maxPalindromes(self, s: str, k: int) -> int:
        ","int maxPalindromes(char * s, int k){

}","public class Solution {
    public int MaxPalindromes(string s, int k) {
        
    }
}","/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var maxPalindromes = function(s, k) {
    
};","# @param {String} s
# @param {Integer} k
# @return {Integer}
def max_palindromes(s, k)
    
end","class Solution {
    func maxPalindromes(_ s: String, _ k: Int) -> Int {
        
    }
}","func maxPalindromes(s string, k int) int {
    
}","object Solution {
    def maxPalindromes(s: String, k: Int): Int = {
        
    }
}","class Solution {
    fun maxPalindromes(s: String, k: Int): Int {
        
    }
}","impl Solution {
    pub fn max_palindromes(s: String, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param Integer $k
     * @return Integer
     */
    function maxPalindromes($s, $k) {
        
    }
}","function maxPalindromes(s: string, k: number): number {

};","(define/contract (max-palindromes s k)
  (-> string? exact-integer? exact-integer?)

  )","-spec max_palindromes(S :: unicode:unicode_binary(), K :: integer()) -> integer().
max_palindromes(S, K) ->
  .","defmodule Solution do
  @spec max_palindromes(s :: String.t, k :: integer) :: integer
  def max_palindromes(s, k) do

  end
end","class Solution {
  int maxPalindromes(String s, int k) {

  }
}",
minimum-number-of-operations-to-sort-a-binary-tree-by-level,Minimum Number of Operations to Sort a Binary Tree by Level,2471.0,2558.0,"<p>You are given the <code>root</code> of a binary tree with <strong>unique values</strong>.</p>

<p>In one operation, you can choose any two nodes <strong>at the same level</strong> and swap their values.</p>

<p>Return <em>the minimum number of operations needed to make the values at each level sorted in a <strong>strictly increasing order</strong></em>.</p>

<p>The <strong>level</strong> of a node is the number of edges along the path between it and the root node<em>.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img src=""https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png"" style=""width: 500px; height: 324px;"" />
<pre>
<strong>Input:</strong> root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
- Swap 4 and 3. The 2<sup>nd</sup> level becomes [3,4].
- Swap 7 and 5. The 3<sup>rd</sup> level becomes [5,6,8,7].
- Swap 8 and 7. The 3<sup>rd</sup> level becomes [5,6,7,8].
We used 3 operations so return 3.
It can be proven that 3 is the minimum number of operations needed.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img src=""https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png"" style=""width: 400px; height: 303px;"" />
<pre>
<strong>Input:</strong> root = [1,3,2,7,6,5,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
- Swap 3 and 2. The 2<sup>nd</sup> level becomes [2,3].
- Swap 7 and 4. The 3<sup>rd</sup> level becomes [4,6,5,7].
- Swap 6 and 5. The 3<sup>rd</sup> level becomes [4,5,6,7].
We used 3 operations so return 3.
It can be proven that 3 is the minimum number of operations needed.
</pre>

<p><strong class=""example"">Example 3:</strong></p>
<img src=""https://assets.leetcode.com/uploads/2022/09/18/image-20220918174052-4.png"" style=""width: 400px; height: 274px;"" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Each level is already sorted in increasing order so return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li>All the values of the tree are <strong>unique</strong>.</li>
</ul>
",2.0,False,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minimumOperations(TreeNode* root) {
        
    }
};","/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minimumOperations(TreeNode root) {
        
    }
}","# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def minimumOperations(self, root):
        """"""
        :type root: Optional[TreeNode]
        :rtype: int
        """"""
        ","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minimumOperations(self, root: Optional[TreeNode]) -> int:
        ","/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
int minimumOperations(struct TreeNode* root){

}","/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public int MinimumOperations(TreeNode root) {
        
    }
}","/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minimumOperations = function(root) {
    
};","# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def minimum_operations(root)
    
end","/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    func minimumOperations(_ root: TreeNode?) -> Int {
        
    }
}","/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func minimumOperations(root *TreeNode) int {
    
}","/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    def minimumOperations(root: TreeNode): Int = {
        
    }
}","/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */
class Solution {
    fun minimumOperations(root: TreeNode?): Int {
        
    }
}","// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn minimum_operations(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        
    }
}","/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     public $val = null;
 *     public $left = null;
 *     public $right = null;
 *     function __construct($val = 0, $left = null, $right = null) {
 *         $this->val = $val;
 *         $this->left = $left;
 *         $this->right = $right;
 *     }
 * }
 */
class Solution {

    /**
     * @param TreeNode $root
     * @return Integer
     */
    function minimumOperations($root) {
        
    }
}","/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function minimumOperations(root: TreeNode | null): number {

};","; Definition for a binary tree node.
#|

; val : integer?
; left : (or/c tree-node? #f)
; right : (or/c tree-node? #f)
(struct tree-node
  (val left right) #:mutable #:transparent)

; constructor
(define (make-tree-node [val 0])
  (tree-node val #f #f))

|#

(define/contract (minimum-operations root)
  (-> (or/c tree-node? #f) exact-integer?)

  )","%% Definition for a binary tree node.
%%
%% -record(tree_node, {val = 0 :: integer(),
%%                     left = null  :: 'null' | #tree_node{},
%%                     right = null :: 'null' | #tree_node{}}).

-spec minimum_operations(Root :: #tree_node{} | null) -> integer().
minimum_operations(Root) ->
  .","# Definition for a binary tree node.
#
# defmodule TreeNode do
#   @type t :: %__MODULE__{
#           val: integer,
#           left: TreeNode.t() | nil,
#           right: TreeNode.t() | nil
#         }
#   defstruct val: 0, left: nil, right: nil
# end

defmodule Solution do
  @spec minimum_operations(root :: TreeNode.t | nil) :: integer
  def minimum_operations(root) do

  end
end","/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   int val;
 *   TreeNode? left;
 *   TreeNode? right;
 *   TreeNode([this.val = 0, this.left, this.right]);
 * }
 */
class Solution {
  int minimumOperations(TreeNode? root) {

  }
}",
number-of-subarrays-with-lcm-equal-to-k,Number of Subarrays With LCM Equal to K,2470.0,2557.0,"<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the number of <strong>subarrays</strong> of </em><code>nums</code><em> where the least common multiple of the subarray&#39;s elements is </em><code>k</code>.</p>

<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>

<p>The <strong>least common multiple of an array</strong> is the smallest positive integer that is divisible by all the array elements.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,6,2,7,1], k = 6
<strong>Output:</strong> 4
<strong>Explanation:</strong> The subarrays of nums where 6 is the least common multiple of all the subarray&#39;s elements are:
- [<u><strong>3</strong></u>,<u><strong>6</strong></u>,2,7,1]
- [<u><strong>3</strong></u>,<u><strong>6</strong></u>,<u><strong>2</strong></u>,7,1]
- [3,<u><strong>6</strong></u>,2,7,1]
- [3,<u><strong>6</strong></u>,<u><strong>2</strong></u>,7,1]
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3], k = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no subarrays of nums where 2 is the least common multiple of all the subarray&#39;s elements.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i], k &lt;= 1000</code></li>
</ul>
",2.0,False,"class Solution {
public:
    int subarrayLCM(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int subarrayLCM(int[] nums, int k) {
        
    }
}","class Solution(object):
    def subarrayLCM(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def subarrayLCM(self, nums: List[int], k: int) -> int:
        ","int subarrayLCM(int* nums, int numsSize, int k){

}","public class Solution {
    public int SubarrayLCM(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarrayLCM = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def subarray_lcm(nums, k)
    
end","class Solution {
    func subarrayLCM(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func subarrayLCM(nums []int, k int) int {
    
}","object Solution {
    def subarrayLCM(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun subarrayLCM(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn subarray_lcm(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function subarrayLCM($nums, $k) {
        
    }
}","function subarrayLCM(nums: number[], k: number): number {

};","(define/contract (subarray-lcm nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec subarray_lcm(Nums :: [integer()], K :: integer()) -> integer().
subarray_lcm(Nums, K) ->
  .","defmodule Solution do
  @spec subarray_lcm(nums :: [integer], k :: integer) :: integer
  def subarray_lcm(nums, k) do

  end
end","class Solution {
  int subarrayLCM(List<int> nums, int k) {

  }
}",
convert-the-temperature,Convert the Temperature,2469.0,2556.0,"<p>You are given a non-negative floating point number rounded to two decimal places <code>celsius</code>, that denotes the <strong>temperature in Celsius</strong>.</p>

<p>You should convert Celsius into <strong>Kelvin</strong> and <strong>Fahrenheit</strong> and return it as an array <code>ans = [kelvin, fahrenheit]</code>.</p>

<p>Return <em>the array <code>ans</code>. </em>Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</p>

<p><strong>Note that:</strong></p>

<ul>
	<li><code>Kelvin = Celsius + 273.15</code></li>
	<li><code>Fahrenheit = Celsius * 1.80 + 32.00</code></li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> celsius = 36.50
<strong>Output:</strong> [309.65000,97.70000]
<strong>Explanation:</strong> Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> celsius = 122.11
<strong>Output:</strong> [395.26000,251.79800]
<strong>Explanation:</strong> Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= celsius &lt;= 1000</code></li>
</ul>
",1.0,False,"class Solution {
public:
    vector<double> convertTemperature(double celsius) {
        
    }
};","class Solution {
    public double[] convertTemperature(double celsius) {
        
    }
}","class Solution(object):
    def convertTemperature(self, celsius):
        """"""
        :type celsius: float
        :rtype: List[float]
        """"""
        ","class Solution:
    def convertTemperature(self, celsius: float) -> List[float]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
double* convertTemperature(double celsius, int* returnSize){

}","public class Solution {
    public double[] ConvertTemperature(double celsius) {
        
    }
}","/**
 * @param {number} celsius
 * @return {number[]}
 */
var convertTemperature = function(celsius) {
    
};","# @param {Float} celsius
# @return {Float[]}
def convert_temperature(celsius)
    
end","class Solution {
    func convertTemperature(_ celsius: Double) -> [Double] {
        
    }
}","func convertTemperature(celsius float64) []float64 {
    
}","object Solution {
    def convertTemperature(celsius: Double): Array[Double] = {
        
    }
}","class Solution {
    fun convertTemperature(celsius: Double): DoubleArray {
        
    }
}","impl Solution {
    pub fn convert_temperature(celsius: f64) -> Vec<f64> {
        
    }
}","class Solution {

    /**
     * @param Float $celsius
     * @return Float[]
     */
    function convertTemperature($celsius) {
        
    }
}","function convertTemperature(celsius: number): number[] {

};","(define/contract (convert-temperature celsius)
  (-> flonum? (listof flonum?))

  )","-spec convert_temperature(Celsius :: float()) -> [float()].
convert_temperature(Celsius) ->
  .","defmodule Solution do
  @spec convert_temperature(celsius :: float) :: [float]
  def convert_temperature(celsius) do

  end
end","class Solution {
  List<double> convertTemperature(double celsius) {

  }
}",
minimum-total-distance-traveled,Minimum Total Distance Traveled,2463.0,2554.0,"<p>There are some robots and factories on the X-axis. You are given an integer array <code>robot</code> where <code>robot[i]</code> is the position of the <code>i<sup>th</sup></code> robot. You are also given a 2D integer array <code>factory</code> where <code>factory[j] = [position<sub>j</sub>, limit<sub>j</sub>]</code> indicates that <code>position<sub>j</sub></code> is the position of the <code>j<sup>th</sup></code> factory and that the <code>j<sup>th</sup></code> factory can repair at most <code>limit<sub>j</sub></code> robots.</p>

<p>The positions of each robot are <strong>unique</strong>. The positions of each factory are also <strong>unique</strong>. Note that a robot can be <strong>in the same position</strong> as a factory initially.</p>

<p>All the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.</p>

<p><strong>At any moment</strong>, you can set the initial direction of moving for <strong>some</strong> robot. Your target is to minimize the total distance traveled by all the robots.</p>

<p>Return <em>the minimum total distance traveled by all the robots</em>. The test cases are generated such that all the robots can be repaired.</p>

<p><strong>Note that</strong></p>

<ul>
	<li>All robots move at the same speed.</li>
	<li>If two robots move in the same direction, they will never collide.</li>
	<li>If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.</li>
	<li>If a robot passes by a factory that reached its limits, it crosses it as if it does not exist.</li>
	<li>If the robot moved from a position <code>x</code> to a position <code>y</code>, the distance it moved is <code>|y - x|</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/09/15/example1.jpg"" style=""width: 500px; height: 320px;"" />
<pre>
<strong>Input:</strong> robot = [0,4,6], factory = [[2,2],[6,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> As shown in the figure:
- The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.
- The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.
- The third robot at position 6 will be repaired at the second factory. It does not need to move.
The limit of the first factory is 2, and it fixed 2 robots.
The limit of the second factory is 2, and it fixed 1 robot.
The total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/09/15/example-2.jpg"" style=""width: 500px; height: 329px;"" />
<pre>
<strong>Input:</strong> robot = [1,-1], factory = [[-2,1],[2,1]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> As shown in the figure:
- The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.
- The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.
The limit of the first factory is 1, and it fixed 1 robot.
The limit of the second factory is 1, and it fixed 1 robot.
The total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= robot.length, factory.length &lt;= 100</code></li>
	<li><code>factory[j].length == 2</code></li>
	<li><code>-10<sup>9</sup> &lt;= robot[i], position<sub>j</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= limit<sub>j</sub> &lt;= robot.length</code></li>
	<li>The input will be generated such that it is always possible to repair every robot.</li>
</ul>
",3.0,False,"class Solution {
public:
    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {
        
    }
};","class Solution {
    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {
        
    }
}","class Solution(object):
    def minimumTotalDistance(self, robot, factory):
        """"""
        :type robot: List[int]
        :type factory: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:
        ","long long minimumTotalDistance(int* robot, int robotSize, int** factory, int factorySize, int* factoryColSize){

}","public class Solution {
    public long MinimumTotalDistance(IList<int> robot, int[][] factory) {
        
    }
}","/**
 * @param {number[]} robot
 * @param {number[][]} factory
 * @return {number}
 */
var minimumTotalDistance = function(robot, factory) {
    
};","# @param {Integer[]} robot
# @param {Integer[][]} factory
# @return {Integer}
def minimum_total_distance(robot, factory)
    
end","class Solution {
    func minimumTotalDistance(_ robot: [Int], _ factory: [[Int]]) -> Int {
        
    }
}","func minimumTotalDistance(robot []int, factory [][]int) int64 {
    
}","object Solution {
    def minimumTotalDistance(robot: List[Int], factory: Array[Array[Int]]): Long = {
        
    }
}","class Solution {
    fun minimumTotalDistance(robot: List<Int>, factory: Array<IntArray>): Long {
        
    }
}","impl Solution {
    pub fn minimum_total_distance(robot: Vec<i32>, factory: Vec<Vec<i32>>) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $robot
     * @param Integer[][] $factory
     * @return Integer
     */
    function minimumTotalDistance($robot, $factory) {
        
    }
}","function minimumTotalDistance(robot: number[], factory: number[][]): number {

};","(define/contract (minimum-total-distance robot factory)
  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)

  )","-spec minimum_total_distance(Robot :: [integer()], Factory :: [[integer()]]) -> integer().
minimum_total_distance(Robot, Factory) ->
  .","defmodule Solution do
  @spec minimum_total_distance(robot :: [integer], factory :: [[integer]]) :: integer
  def minimum_total_distance(robot, factory) do

  end
end","class Solution {
  int minimumTotalDistance(List<int> robot, List<List<int>> factory) {

  }
}",
total-cost-to-hire-k-workers,Total Cost to Hire K Workers,2462.0,2553.0,"<p>You are given a <strong>0-indexed</strong> integer array <code>costs</code> where <code>costs[i]</code> is the cost of hiring the <code>i<sup>th</sup></code> worker.</p>

<p>You are also given two integers <code>k</code> and <code>candidates</code>. We want to hire exactly <code>k</code> workers according to the following rules:</p>

<ul>
	<li>You will run <code>k</code> sessions and hire exactly one worker in each session.</li>
	<li>In each hiring session, choose the worker with the lowest cost from either the first <code>candidates</code> workers or the last <code>candidates</code> workers. Break the tie by the smallest index.
	<ul>
		<li>For example, if <code>costs = [3,2,7,7,1,2]</code> and <code>candidates = 2</code>, then in the first hiring session, we will choose the <code>4<sup>th</sup></code> worker because they have the lowest cost <code>[<u>3,2</u>,7,7,<u><strong>1</strong>,2</u>]</code>.</li>
		<li>In the second hiring session, we will choose <code>1<sup>st</sup></code> worker because they have the same lowest cost as <code>4<sup>th</sup></code> worker but they have the smallest index <code>[<u>3,<strong>2</strong></u>,7,<u>7,2</u>]</code>. Please note that the indexing may be changed in the process.</li>
	</ul>
	</li>
	<li>If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.</li>
	<li>A worker can only be chosen once.</li>
</ul>

<p>Return <em>the total cost to hire exactly </em><code>k</code><em> workers.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4
<strong>Output:</strong> 11
<strong>Explanation:</strong> We hire 3 workers in total. The total cost is initially 0.
- In the first hiring round we choose the worker from [<u>17,12,10,2</u>,7,<u>2,11,20,8</u>]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.
- In the second hiring round we choose the worker from [<u>17,12,10,7</u>,<u>2,11,20,8</u>]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.
- In the third hiring round we choose the worker from [<u>17,12,10,7,11,20,8</u>]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.
The total hiring cost is 11.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> costs = [1,2,4,1], k = 3, candidates = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> We hire 3 workers in total. The total cost is initially 0.
- In the first hiring round we choose the worker from [<u>1,2,4,1</u>]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.
- In the second hiring round we choose the worker from [<u>2,4,1</u>]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.
- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [<u>2,4</u>]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.
The total hiring cost is 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= costs.length &lt;= 10<sup>5 </sup></code></li>
	<li><code>1 &lt;= costs[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k, candidates &lt;= costs.length</code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long totalCost(vector<int>& costs, int k, int candidates) {
        
    }
};","class Solution {
    public long totalCost(int[] costs, int k, int candidates) {
        
    }
}","class Solution(object):
    def totalCost(self, costs, k, candidates):
        """"""
        :type costs: List[int]
        :type k: int
        :type candidates: int
        :rtype: int
        """"""
        ","class Solution:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        ","long long totalCost(int* costs, int costsSize, int k, int candidates){

}","public class Solution {
    public long TotalCost(int[] costs, int k, int candidates) {
        
    }
}","/**
 * @param {number[]} costs
 * @param {number} k
 * @param {number} candidates
 * @return {number}
 */
var totalCost = function(costs, k, candidates) {
    
};","# @param {Integer[]} costs
# @param {Integer} k
# @param {Integer} candidates
# @return {Integer}
def total_cost(costs, k, candidates)
    
end","class Solution {
    func totalCost(_ costs: [Int], _ k: Int, _ candidates: Int) -> Int {
        
    }
}","func totalCost(costs []int, k int, candidates int) int64 {
    
}","object Solution {
    def totalCost(costs: Array[Int], k: Int, candidates: Int): Long = {
        
    }
}","class Solution {
    fun totalCost(costs: IntArray, k: Int, candidates: Int): Long {
        
    }
}","impl Solution {
    pub fn total_cost(costs: Vec<i32>, k: i32, candidates: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $costs
     * @param Integer $k
     * @param Integer $candidates
     * @return Integer
     */
    function totalCost($costs, $k, $candidates) {
        
    }
}","function totalCost(costs: number[], k: number, candidates: number): number {

};","(define/contract (total-cost costs k candidates)
  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)

  )","-spec total_cost(Costs :: [integer()], K :: integer(), Candidates :: integer()) -> integer().
total_cost(Costs, K, Candidates) ->
  .","defmodule Solution do
  @spec total_cost(costs :: [integer], k :: integer, candidates :: integer) :: integer
  def total_cost(costs, k, candidates) do

  end
end","class Solution {
  int totalCost(List<int> costs, int k, int candidates) {

  }
}",
maximum-sum-of-distinct-subarrays-with-length-k,Maximum Sum of Distinct Subarrays With Length K,2461.0,2552.0,"<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. Find the maximum subarray sum of all the subarrays of <code>nums</code> that meet the following conditions:</p>

<ul>
	<li>The length of the subarray is <code>k</code>, and</li>
	<li>All the elements of the subarray are <strong>distinct</strong>.</li>
</ul>

<p>Return <em>the maximum subarray sum of all the subarrays that meet the conditions</em><em>.</em> If no subarray meets the conditions, return <code>0</code>.</p>

<p><em>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,5,4,2,9,9,9], k = 3
<strong>Output:</strong> 15
<strong>Explanation:</strong> The subarrays of nums with length 3 are:
- [1,5,4] which meets the requirements and has a sum of 10.
- [5,4,2] which meets the requirements and has a sum of 11.
- [4,2,9] which meets the requirements and has a sum of 15.
- [2,9,9] which does not meet the requirements because the element 9 is repeated.
- [9,9,9] which does not meet the requirements because the element 9 is repeated.
We return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,4,4], k = 3
<strong>Output:</strong> 0
<strong>Explanation:</strong> The subarrays of nums with length 3 are:
- [4,4,4] which does not meet the requirements because the element 4 is repeated.
We return 0 because no subarrays meet the conditions.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
",2.0,False,"class Solution {
public:
    long long maximumSubarraySum(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public long maximumSubarraySum(int[] nums, int k) {
        
    }
}","class Solution(object):
    def maximumSubarraySum(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        ","long long maximumSubarraySum(int* nums, int numsSize, int k){

}","public class Solution {
    public long MaximumSubarraySum(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumSubarraySum = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def maximum_subarray_sum(nums, k)
    
end","class Solution {
    func maximumSubarraySum(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func maximumSubarraySum(nums []int, k int) int64 {
    
}","object Solution {
    def maximumSubarraySum(nums: Array[Int], k: Int): Long = {
        
    }
}","class Solution {
    fun maximumSubarraySum(nums: IntArray, k: Int): Long {
        
    }
}","impl Solution {
    pub fn maximum_subarray_sum(nums: Vec<i32>, k: i32) -> i64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function maximumSubarraySum($nums, $k) {
        
    }
}","function maximumSubarraySum(nums: number[], k: number): number {

};","(define/contract (maximum-subarray-sum nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec maximum_subarray_sum(Nums :: [integer()], K :: integer()) -> integer().
maximum_subarray_sum(Nums, K) ->
  .","defmodule Solution do
  @spec maximum_subarray_sum(nums :: [integer], k :: integer) :: integer
  def maximum_subarray_sum(nums, k) do

  end
end","class Solution {
  int maximumSubarraySum(List<int> nums, int k) {

  }
}",
apply-operations-to-an-array,Apply Operations to an Array,2460.0,2551.0,"<p>You are given a <strong>0-indexed</strong> array <code>nums</code> of size <code>n</code> consisting of <strong>non-negative</strong> integers.</p>

<p>You need to apply <code>n - 1</code> operations to this array where, in the <code>i<sup>th</sup></code> operation (<strong>0-indexed</strong>), you will apply the following on the <code>i<sup>th</sup></code> element of <code>nums</code>:</p>

<ul>
	<li>If <code>nums[i] == nums[i + 1]</code>, then multiply <code>nums[i]</code> by <code>2</code> and set <code>nums[i + 1]</code> to <code>0</code>. Otherwise, you skip this operation.</li>
</ul>

<p>After performing <strong>all</strong> the operations, <strong>shift</strong> all the <code>0</code>&#39;s to the <strong>end</strong> of the array.</p>

<ul>
	<li>For example, the array <code>[1,0,2,0,0,1]</code> after shifting all its <code>0</code>&#39;s to the end, is <code>[1,2,1,0,0,0]</code>.</li>
</ul>

<p>Return <em>the resulting array</em>.</p>

<p><strong>Note</strong> that the operations are applied <strong>sequentially</strong>, not all at once.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,2,1,1,0]
<strong>Output:</strong> [1,4,2,0,0,0]
<strong>Explanation:</strong> We do the following operations:
- i = 0: nums[0] and nums[1] are not equal, so we skip this operation.
- i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,<strong><u>4</u></strong>,<strong><u>0</u></strong>,1,1,0].
- i = 2: nums[2] and nums[3] are not equal, so we skip this operation.
- i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,<strong><u>2</u></strong>,<strong><u>0</u></strong>,0].
- i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,<strong><u>0</u></strong>,<strong><u>0</u></strong>].
After that, we shift the 0&#39;s to the end, which gives the array [1,4,2,0,0,0].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1]
<strong>Output:</strong> [1,0]
<strong>Explanation:</strong> No operation can be applied, we just shift the 0 to the end.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 2000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
",1.0,False,"class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        
    }
};","class Solution {
    public int[] applyOperations(int[] nums) {
        
    }
}","class Solution(object):
    def applyOperations(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* applyOperations(int* nums, int numsSize, int* returnSize){

}","public class Solution {
    public int[] ApplyOperations(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number[]}
 */
var applyOperations = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer[]}
def apply_operations(nums)
    
end","class Solution {
    func applyOperations(_ nums: [Int]) -> [Int] {
        
    }
}","func applyOperations(nums []int) []int {
    
}","object Solution {
    def applyOperations(nums: Array[Int]): Array[Int] = {
        
    }
}","class Solution {
    fun applyOperations(nums: IntArray): IntArray {
        
    }
}","impl Solution {
    pub fn apply_operations(nums: Vec<i32>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function applyOperations($nums) {
        
    }
}","function applyOperations(nums: number[]): number[] {

};","(define/contract (apply-operations nums)
  (-> (listof exact-integer?) (listof exact-integer?))

  )","-spec apply_operations(Nums :: [integer()]) -> [integer()].
apply_operations(Nums) ->
  .","defmodule Solution do
  @spec apply_operations(nums :: [integer]) :: [integer]
  def apply_operations(nums) do

  end
end","class Solution {
  List<int> applyOperations(List<int> nums) {

  }
}",
words-within-two-edits-of-dictionary,Words Within Two Edits of Dictionary,2452.0,2550.0,"<p>You are given two string arrays, <code>queries</code> and <code>dictionary</code>. All words in each array comprise of lowercase English letters and have the same length.</p>

<p>In one <strong>edit</strong> you can take a word from <code>queries</code>, and change any letter in it to any other letter. Find all words from <code>queries</code> that, after a <strong>maximum</strong> of two edits, equal some word from <code>dictionary</code>.</p>

<p>Return<em> a list of all words from </em><code>queries</code><em>, </em><em>that match with some word from </em><code>dictionary</code><em> after a maximum of <strong>two edits</strong></em>. Return the words in the <strong>same order</strong> they appear in <code>queries</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;word&quot;,&quot;note&quot;,&quot;ants&quot;,&quot;wood&quot;], dictionary = [&quot;wood&quot;,&quot;joke&quot;,&quot;moat&quot;]
<strong>Output:</strong> [&quot;word&quot;,&quot;note&quot;,&quot;wood&quot;]
<strong>Explanation:</strong>
- Changing the &#39;r&#39; in &quot;word&quot; to &#39;o&#39; allows it to equal the dictionary word &quot;wood&quot;.
- Changing the &#39;n&#39; to &#39;j&#39; and the &#39;t&#39; to &#39;k&#39; in &quot;note&quot; changes it to &quot;joke&quot;.
- It would take more than 2 edits for &quot;ants&quot; to equal a dictionary word.
- &quot;wood&quot; can remain unchanged (0 edits) and match the corresponding dictionary word.
Thus, we return [&quot;word&quot;,&quot;note&quot;,&quot;wood&quot;].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;yes&quot;], dictionary = [&quot;not&quot;]
<strong>Output:</strong> []
<strong>Explanation:</strong>
Applying any two edits to &quot;yes&quot; cannot make it equal to &quot;not&quot;. Thus, we return an empty array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= queries.length, dictionary.length &lt;= 100</code></li>
	<li><code>n == queries[i].length == dictionary[j].length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li>All <code>queries[i]</code> and <code>dictionary[j]</code> are composed of lowercase English letters.</li>
</ul>
",2.0,False,"class Solution {
public:
    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {
        
    }
};","class Solution {
    public List<String> twoEditWords(String[] queries, String[] dictionary) {
        
    }
}","class Solution(object):
    def twoEditWords(self, queries, dictionary):
        """"""
        :type queries: List[str]
        :type dictionary: List[str]
        :rtype: List[str]
        """"""
        ","class Solution:
    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** twoEditWords(char ** queries, int queriesSize, char ** dictionary, int dictionarySize, int* returnSize){

}","public class Solution {
    public IList<string> TwoEditWords(string[] queries, string[] dictionary) {
        
    }
}","/**
 * @param {string[]} queries
 * @param {string[]} dictionary
 * @return {string[]}
 */
var twoEditWords = function(queries, dictionary) {
    
};","# @param {String[]} queries
# @param {String[]} dictionary
# @return {String[]}
def two_edit_words(queries, dictionary)
    
end","class Solution {
    func twoEditWords(_ queries: [String], _ dictionary: [String]) -> [String] {
        
    }
}","func twoEditWords(queries []string, dictionary []string) []string {
    
}","object Solution {
    def twoEditWords(queries: Array[String], dictionary: Array[String]): List[String] = {
        
    }
}","class Solution {
    fun twoEditWords(queries: Array<String>, dictionary: Array<String>): List<String> {
        
    }
}","impl Solution {
    pub fn two_edit_words(queries: Vec<String>, dictionary: Vec<String>) -> Vec<String> {
        
    }
}","class Solution {

    /**
     * @param String[] $queries
     * @param String[] $dictionary
     * @return String[]
     */
    function twoEditWords($queries, $dictionary) {
        
    }
}","function twoEditWords(queries: string[], dictionary: string[]): string[] {

};","(define/contract (two-edit-words queries dictionary)
  (-> (listof string?) (listof string?) (listof string?))

  )","-spec two_edit_words(Queries :: [unicode:unicode_binary()], Dictionary :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].
two_edit_words(Queries, Dictionary) ->
  .","defmodule Solution do
  @spec two_edit_words(queries :: [String.t], dictionary :: [String.t]) :: [String.t]
  def two_edit_words(queries, dictionary) do

  end
end","class Solution {
  List<String> twoEditWords(List<String> queries, List<String> dictionary) {

  }
}",
next-greater-element-iv,Next Greater Element IV,2454.0,2549.0,"<p>You are given a <strong>0-indexed</strong> array of non-negative integers <code>nums</code>. For each integer in <code>nums</code>, you must find its respective <strong>second greater</strong> integer.</p>

<p>The <strong>second greater</strong> integer of <code>nums[i]</code> is <code>nums[j]</code> such that:</p>

<ul>
	<li><code>j &gt; i</code></li>
	<li><code>nums[j] &gt; nums[i]</code></li>
	<li>There exists <strong>exactly one</strong> index <code>k</code> such that <code>nums[k] &gt; nums[i]</code> and <code>i &lt; k &lt; j</code>.</li>
</ul>

<p>If there is no such <code>nums[j]</code>, the second greater integer is considered to be <code>-1</code>.</p>

<ul>
	<li>For example, in the array <code>[1, 2, 4, 3]</code>, the second greater integer of <code>1</code> is <code>4</code>, <code>2</code> is <code>3</code>,&nbsp;and that of <code>3</code> and <code>4</code> is <code>-1</code>.</li>
</ul>

<p>Return<em> an integer array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> is the second greater integer of </em><code>nums[i]</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,0,9,6]
<strong>Output:</strong> [9,6,6,-1,-1]
<strong>Explanation:</strong>
0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.
1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.
2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.
3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.
4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.
Thus, we return [9,6,6,-1,-1].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,3]
<strong>Output:</strong> [-1,-1]
<strong>Explanation:</strong>
We return [-1,-1] since neither integer has any integer greater than it.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",3.0,False,"class Solution {
public:
    vector<int> secondGreaterElement(vector<int>& nums) {
        
    }
};","class Solution {
    public int[] secondGreaterElement(int[] nums) {
        
    }
}","class Solution(object):
    def secondGreaterElement(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* secondGreaterElement(int* nums, int numsSize, int* returnSize){

}","public class Solution {
    public int[] SecondGreaterElement(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number[]}
 */
var secondGreaterElement = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer[]}
def second_greater_element(nums)
    
end","class Solution {
    func secondGreaterElement(_ nums: [Int]) -> [Int] {
        
    }
}","func secondGreaterElement(nums []int) []int {
    
}","object Solution {
    def secondGreaterElement(nums: Array[Int]): Array[Int] = {
        
    }
}","class Solution {
    fun secondGreaterElement(nums: IntArray): IntArray {
        
    }
}","impl Solution {
    pub fn second_greater_element(nums: Vec<i32>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function secondGreaterElement($nums) {
        
    }
}","function secondGreaterElement(nums: number[]): number[] {

};","(define/contract (second-greater-element nums)
  (-> (listof exact-integer?) (listof exact-integer?))

  )","-spec second_greater_element(Nums :: [integer()]) -> [integer()].
second_greater_element(Nums) ->
  .","defmodule Solution do
  @spec second_greater_element(nums :: [integer]) :: [integer]
  def second_greater_element(nums) do

  end
end","class Solution {
  List<int> secondGreaterElement(List<int> nums) {

  }
}",
